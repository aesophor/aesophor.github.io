



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="日新又新" href="https://aesophor.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="日新又新" href="https://aesophor.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="日新又新" href="https://aesophor.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  

<link rel="canonical" href="https://aesophor.github.io/leetcode/">



  <title>LeetCode 刷題紀錄 |
aesophor's Blog</title>
<meta name="generator" content="Hexo 5.4.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">LeetCode 刷題紀錄
  </h1>

          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">aesophor's Blog</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
          <img src="https://images.unsplash.com/photo-1533441325263-74682c42d779?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80">
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="page wrap">
    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="en">
  <link itemprop="mainEntityOfPage" href="https://aesophor.github.io/leetcode/index.html">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.png">
    <meta itemprop="name" content="aesophor">
    <meta itemprop="description" content="努力不會背叛人，它走不快，但早晚會跟上, eku">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="日新又新">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h1 id="LeetCode-刷題記錄"><a href="#LeetCode-刷題記錄" class="headerlink" title="LeetCode 刷題記錄"></a>LeetCode 刷題記錄</h1><p>因為工作突然要寫 <span class="exturl" data-url="aHR0cHM6Ly9nby5kZXYv">Go</span>，所以藉由刷題來熟悉這個陌生的語言。</p>
<p>本人很菜，如果您找到了任何錯誤之處，歡迎寄信或私訊我，謝謝。</p>
<h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="Add-Two-Numbers"><a href="#Add-Two-Numbers" class="headerlink" title="Add Two Numbers"></a>Add Two Numbers</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYWRkLXR3by1udW1iZXJzLw==">https://leetcode.com/problems/add-two-numbers/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> Go</p>
</blockquote>
<p>給你兩條 linked list，value 為 123 在 input 是 3 → 2 → 1 → nil，用一樣的 linked list 回傳兩數之和。</p>
<pre><code class="go">/**
 * Definition for singly-linked list.
 * type ListNode struct &#123;
 *     Val int
 *     Next *ListNode
 * &#125;
 */
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode &#123;
    var head *ListNode
    var curr *ListNode
    carry := false

    for l1 != nil || l2 != nil || carry &#123;
        val := 0
        if carry &#123;
            val += 1
        &#125;
        carry = false
    
        if l1 != nil &#123;
            val += l1.Val
            l1 = l1.Next
        &#125;
    
        if l2 != nil &#123;
            val += l2.Val
            l2 = l2.Next
        &#125;

        if val &gt; 9 &#123;
            carry = true
            val -= 10
        &#125;

        var newNode *ListNode = &amp;ListNode&#123;val, nil&#125;
        if curr == nil &#123;
            head = newNode
        &#125; else &#123;
            curr.Next = newNode
        &#125;
        curr = newNode
    &#125;

    if head == nil &#123;
        head = &amp;ListNode&#123;0, nil&#125;
    &#125;

    return head
&#125;
</code></pre>
<h3 id="K-Closest-Points-to-Origin"><a href="#K-Closest-Points-to-Origin" class="headerlink" title="K Closest Points to Origin"></a>K Closest Points to Origin</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvay1jbG9zZXN0LXBvaW50cy10by1vcmlnaW4v">https://leetcode.com/problems/k-closest-points-to-origin/</span><br><strong>難度：</strong> Medium<br><strong>技巧：</strong> <code>Sort</code><br><strong>語言：</strong> Go</p>
</blockquote>
<p>對 points 按照歐式距離做升冪排序後，前 k 個點就是答案。</p>
<pre><code class="go">func kClosest(points [][]int, k int) [][]int &#123;
    sort.SliceStable(points, func(i, j int) bool &#123;
        p1 := points[i]
        p2 := points[j]
        dist1 := math.Hypot(float64(p1[0]), float64(p1[1]))
        dist2 := math.Hypot(float64(p2[0]), float64(p2[1]))
        return dist1 &lt;= dist2
    &#125;)
    return points[:k]
&#125;
</code></pre>
<h3 id="Longest-Common-Prefix"><a href="#Longest-Common-Prefix" class="headerlink" title="Longest Common Prefix"></a>Longest Common Prefix</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbG9uZ2VzdC1jb21tb24tcHJlZml4Lw==">https://leetcode.com/problems/longest-common-prefix/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> Go</p>
</blockquote>
<pre><code class="go">func longestCommonPrefix(strs []string) string &#123;
    numStrs := len(strs)
    minLen := math.MaxInt32
    i := 0

    for _, str := range strs &#123;
        minLen = min(minLen, len(str))
    &#125;

    for ; i &lt; minLen; i++ &#123;
        for j := 1; j &lt; numStrs; j++ &#123;
            if strs[0][i] != strs[j][i] &#123;
                return strs[0][:i]
            &#125;
        &#125;
    &#125;

    return strs[0][:i]
&#125;
</code></pre>
<h3 id="Longest-Palindromic-Substring"><a href="#Longest-Palindromic-Substring" class="headerlink" title="Longest Palindromic Substring"></a>Longest Palindromic Substring</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbG9uZ2VzdC1wYWxpbmRyb21pYy1zdWJzdHJpbmcv">https://leetcode.com/problems/longest-palindromic-substring/</span><br><strong>難度：</strong> Medium<br><strong>技巧：</strong> <code>Two Pointers</code><br><strong>語言：</strong> Go</p>
</blockquote>
<p>給你一個字串 <code>str</code>，例如：”babad” 的答案是 “aba”，而 “cbbd” 的答案是 “bb”。</p>
<ul>
<li>Two Pointers<ul>
<li>迴文的長度可能是奇數或偶數，兩種情況都要檢查。</li>
<li>檢查方式：expand around center<ul>
<li>奇數長度迴文：選一個 center, <code>c1</code>, 往左右 expand</li>
<li>偶數長度迴文：選兩個 center, <code>c1</code>, <code>c2</code>, 往左右 expand</li>
</ul>
</li>
<li>特別注意<ul>
<li>奇數情況：例如 “abc” 以 b 為中心，會碰到 <code>c1 == c2</code><ul>
<li>迴文長度為 1 (“b”)</li>
<li><code>expand()</code> 回傳 (c1+1, c2-1)，計算長度：(c2-1) - (c1+1) + 1 = 1</li>
</ul>
</li>
<li>偶數情況：例如 “abcd 以 bc 為中心，會碰到 <code>c1 == c2 - 1</code><ul>
<li>迴文長度為 0 (“”)</li>
<li><code>expand()</code> 回傳 (c1+1, c2-1)，計算長度：(c2-1) - (c1+1) + 1 = (c2-1) - c2 + 1 = 0</li>
</ul>
</li>
<li>巧妙地算出了正確的迴文長度</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="go">func longestPalindrome(str string) string &#123;
    strLen := len(str)
    maxLen := 0
    ret := &quot;&quot;

    for i := 0; i &lt; strLen; i++ &#123;
        begin1, end1 := expand(str, strLen, i, i)
        localLen := end1 - begin1 + 1

        if localLen &gt; maxLen &#123;
            ret = str[begin1:end1 + 1]
            maxLen = localLen
        &#125;
    
        begin2, end2 := expand(str, strLen, i, i + 1)
        localLen = end2 - begin2 + 1
    
        if localLen &gt; maxLen &#123;
            ret = str[begin2:end2 + 1]
            maxLen = localLen
        &#125;
    &#125;

    return ret
&#125;

// If the length of palindrome is even,
// e.g. abba, then there will be two centers: bb
func expand(str string, strLen int, c1 int, c2 int) (int, int) &#123;
    for c1 &gt;= 0 &amp;&amp; c2 &lt; strLen &#123;
        if str[c1] != str[c2] &#123;
            break
        &#125;
        c1--
        c2++
    &#125;

    return c1 + 1, c2 - 1
&#125;
</code></pre>
<h3 id="Merge-Intervals"><a href="#Merge-Intervals" class="headerlink" title="Merge Intervals"></a>Merge Intervals</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWVyZ2UtaW50ZXJ2YWxzLw==">https://leetcode.com/problems/merge-intervals/</span><br><strong>難度：</strong> Medium<br><strong>技巧：</strong> <code>Sort</code><br><strong>語言：</strong> Go</p>
</blockquote>
<ul>
<li>對 <code>intervals</code> 根據左界進行 ascending 排序</li>
<li>掃一次 <code>intervals</code><ul>
<li>與 last merged interval 無 overlap：就直接 append</li>
<li>與 last merged interval 有 overlap：更新右界，看是原本的大，還是新的大</li>
</ul>
</li>
</ul>
<pre><code class="go">func merge(intervals [][]int) [][]int &#123;
    sort.SliceStable(intervals, func(i, j int) bool &#123;
        return intervals[i][0] &lt; intervals[j][0]
    &#125;)

    ret := make([][]int, 0)
    for _, interval := range intervals &#123;
        if len(ret) == 0 || last(ret)[1] &lt; interval[0] &#123;
            ret = append(ret, interval)
        &#125; else &#123;
            last(ret)[1] = max(last(ret)[1], interval[1])
        &#125;
    &#125;
    return ret
&#125;

func last(s [][]int) []int &#123;
    return s[len(s) - 1]
&#125;
</code></pre>
<h3 id="Insert-Interval"><a href="#Insert-Interval" class="headerlink" title="Insert Interval"></a>Insert Interval</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaW5zZXJ0LWludGVydmFsLw==">https://leetcode.com/problems/insert-interval/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> Go</p>
</blockquote>
<ol>
<li>暴力解：<ul>
<li>將 <code>newInterval</code> append 到 <code>intervals</code> 並根據左界進行 ascending sort</li>
<li>將此問題 reduce 成 Merge Intervals</li>
</ul>
</li>
<li>比較有效率的解法：<ul>
<li>從頭掃描 <code>intervals</code><ul>
<li>若與 <code>newInterval</code> 無 overlap，直接 append 到 <code>ret</code></li>
<li>若與 <code>newInterval</code> 有 overlap，確認目前掃描到的 interval 與 <code>newInterval</code> 融合後的左右界</li>
</ul>
</li>
<li>將 <code>newInterval</code> append 到 <code>ret</code></li>
<li>從剛剛掃描暫停的地方繼續，往後掃完 <code>intervals</code> 剩餘的部分<ul>
<li>因為不確定 <code>newInterval</code> 所橫跨的範圍多大，故此部分的邏輯同 Merge Intervals 的解法</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code class="go">func insert(intervals [][]int, newInterval []int) [][]int &#123;
    var i int
    var ret [][]int

    for i = 0; i &lt; len(intervals); i++ &#123;
        interval := intervals[i]
        if newInterval[0] &lt;= interval[1] &#123;
            newInterval = []int&#123;min(interval[0], newInterval[0]), newInterval[1]&#125;
            break
        &#125;
        ret = append(ret, interval)
    &#125;

    ret = append(ret, newInterval)

    for ; i &lt; len(intervals); i++ &#123;
        interval := intervals[i]
        if len(ret) == 0 || last(ret)[1] &lt; interval[0] &#123;
            ret = append(ret, interval)
        &#125; else &#123;
            last(ret)[1] = max(last(ret)[1], interval[1])
        &#125;
    &#125;
    
    return ret
&#125;

func last(s [][]int) []int &#123;
    return s[len(s) - 1]
&#125;
</code></pre>
<h3 id="Merge-Two-Sorted-Lists"><a href="#Merge-Two-Sorted-Lists" class="headerlink" title="Merge Two Sorted Lists"></a>Merge Two Sorted Lists</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWVyZ2UtdHdvLXNvcnRlZC1saXN0cy8=">https://leetcode.com/problems/merge-two-sorted-lists/</span><br><strong>難度：</strong> Easy<br><strong>技巧：</strong> <code>Linked Lists</code><br><strong>語言：</strong> Go</p>
</blockquote>
<pre><code class="go">/**
 * Definition for singly-linked list.
 * type ListNode struct &#123;
 *     Val int
 *     Next *ListNode
 * &#125;
 */
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode &#123;
    var head *ListNode
    var curr *ListNode
    
    for list1 != nil || list2 != nil &#123;
        newNode := &amp;ListNode&#123;&#125;
        
        if list1 != nil &amp;&amp; list2 == nil &#123;
            newNode.Val = list1.Val
            list1 = list1.Next
        &#125; else if list1 == nil &amp;&amp; list2 != nil &#123;
            newNode.Val = list2.Val
            list2 = list2.Next
        &#125; else &#123;
            if list1.Val &lt;= list2.Val &#123;
                newNode.Val = list1.Val
                list1 = list1.Next
            &#125; else &#123;
                newNode.Val = list2.Val
                list2 = list2.Next
            &#125;
        &#125;

        if head == nil &#123;
            head = newNode
        &#125; else &#123;
            curr.Next = newNode
        &#125;
        
        curr = newNode
    &#125;
    return head
&#125;
</code></pre>
<h3 id="Reverse-Integer"><a href="#Reverse-Integer" class="headerlink" title="Reverse Integer"></a>Reverse Integer</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcmV2ZXJzZS1pbnRlZ2VyLw==">https://leetcode.com/problems/reverse-integer/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> Go</p>
</blockquote>
<p>在 <code>ret *= 10</code> 前，記得檢查此操作是否會造成 <code>ret</code> signed integer overflow。</p>
<pre><code class="go">func reverse(x int) int &#123;
    ret := 0

    for x != 0 &#123;
        if ret &gt; 0 &amp;&amp; ret &gt; math.MaxInt32 / 10 &#123;
            return 0
        &#125;
        if ret &lt; 0 &amp;&amp; ret &lt; math.MinInt32 / 10 &#123;
            return 0
        &#125;

        ret *= 10   
        ret += x % 10
        x /= 10
    &#125;

    return ret
&#125;
</code></pre>
<h3 id="Rotate-Image"><a href="#Rotate-Image" class="headerlink" title="Rotate Image"></a>Rotate Image</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcm90YXRlLWltYWdlLw==">https://leetcode.com/problems/rotate-image/</span><br><strong>難度：</strong> Medium<br><strong>技巧：</strong> <code>Matrix</code><br><strong>語言：</strong> Go</p>
</blockquote>
<p>Matrix rotation = Transpose + 水平翻轉</p>
<pre><code class="go">func rotate(matrix [][]int)  &#123;
    transpose(matrix)
    flipHorizontally(matrix)
&#125;

// Def: transpose = swap the column and row of each element in matrix.
func transpose(matrix [][]int) &#123;
    for i := range matrix &#123;
        for j := 0; j &lt; i; j++ &#123;
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        &#125;
    &#125;
&#125;

func flipHorizontally(matrix [][]int) &#123;
    for _, row := range matrix &#123;
        reverse(row)
    &#125;
&#125;

func reverse(nums []int) &#123;
    for i, j := 0, len(nums)-1; i &lt; j; i, j = i+1, j-1 &#123;
        nums[i], nums[j] = nums[j], nums[i]
    &#125; 
&#125;
</code></pre>
<h3 id="Rotate-List"><a href="#Rotate-List" class="headerlink" title="Rotate List"></a>Rotate List</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcm90YXRlLWxpc3Qv">https://leetcode.com/problems/rotate-list/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> Go</p>
</blockquote>
<pre><code class="go">/**
 * Definition for singly-linked list.
 * type ListNode struct &#123;
 *     Val int
 *     Next *ListNode
 * &#125;
 */
func rotateRight(head *ListNode, k int) *ListNode &#123;
    if head == nil &#123;
        return nil
    &#125;
    if k == 0 &#123;
        return head
    &#125;

    oldHead := head
    size, oldTail := traverse(head)
    
    k %= size
    if k == 0 &#123;
        return head
    &#125;
    
    newHeadPos := size - k
    newTailPos := newHeadPos - 1

    newHead := oldHead
    for i := 0; i &lt; newHeadPos; i++ &#123;
        newHead = newHead.Next
    &#125;
    
    newTail := oldHead
    for i := 0; i &lt; newTailPos; i++ &#123;
        newTail = newTail.Next
    &#125;
    newTail.Next = nil
    oldTail.Next = oldHead
    
    return newHead
&#125;

func traverse(node *ListNode) (int, *ListNode) &#123;
    size := 0
    prev := node
    for node != nil &#123;
        prev = node
        node = node.Next
        size++
    &#125;
    return size, prev
&#125;
</code></pre>
<h3 id="Search-a-2D-Matrix"><a href="#Search-a-2D-Matrix" class="headerlink" title="Search a 2D Matrix"></a>Search a 2D Matrix</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvc2VhcmNoLWEtMmQtbWF0cml4Lw==">https://leetcode.com/problems/search-a-2d-matrix/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> Go</p>
</blockquote>
<pre><code class="go">func searchMatrix(matrix [][]int, target int) bool &#123;
    m := len(matrix)
    n := len(matrix[0])

    i := m - 1
    j := n - 1

    for i &gt;= 0 &amp;&amp; j &gt;= 0 &#123;
        if matrix[i][j] == target &#123;
            return true
        &#125; else if matrix[i][0] &gt; target &#123;
            i--
        &#125; else if matrix[i][j] &gt; target &#123;
            j--
        &#125; else &#123;
            break
        &#125;
    &#125;

    return false
&#125;
</code></pre>
<h3 id="Set-Matrix-Zeroes"><a href="#Set-Matrix-Zeroes" class="headerlink" title="Set Matrix Zeroes"></a>Set Matrix Zeroes</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvc2V0LW1hdHJpeC16ZXJvZXMv">https://leetcode.com/problems/set-matrix-zeroes/</span><br><strong>難度：</strong> Medium<br><strong>技巧：</strong> <code>Hash Set</code><br><strong>語言：</strong> Go</p>
</blockquote>
<pre><code class="go">func setZeroes(matrix [][]int) &#123;
    m := len(matrix)
    n := len(matrix[0])

    rowsToClear := make(map[int]struct&#123;&#125;)
    colsToClear := make(map[int]struct&#123;&#125;)

    for i := 0; i &lt; m; i++ &#123;
        for j := 0; j &lt; n; j++ &#123;
            if matrix[i][j] == 0 &#123;
                rowsToClear[i] = struct&#123;&#125;&#123;&#125;
                colsToClear[j] = struct&#123;&#125;&#123;&#125;
            &#125;
        &#125;
    &#125;

    for row := range rowsToClear &#123;
        matrix[row] = make([]int, n)
    &#125;
    for col := range colsToClear &#123;
        for i := 0; i &lt; m; i++ &#123;
            matrix[i][col] = 0
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="Simplify-Path"><a href="#Simplify-Path" class="headerlink" title="Simplify Path"></a>Simplify Path</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvc2ltcGxpZnktcGF0aC8=">https://leetcode.com/problems/simplify-path/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> Go</p>
</blockquote>
<pre><code class="go">func simplifyPath(path string) string &#123;
    var components []string
    for _, c := range strings.Split(path, &quot;/&quot;) &#123;
        switch c &#123;
        case &quot;.&quot;:
        case &quot;..&quot;:
            if len(components) &gt; 0 &#123;
                components = components[:len(components) - 1]
            &#125;
        default:
            if len(c) &gt; 0 &#123;
                components = append(components, c)
            &#125;
        &#125;
    &#125;

    return &quot;/&quot; + strings.Join(components, &quot;/&quot;)
&#125;
</code></pre>
<h3 id="Subsets"><a href="#Subsets" class="headerlink" title="Subsets"></a>Subsets</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvc3Vic2V0cy8=">https://leetcode.com/problems/subsets/</span><br><strong>難度：</strong> Medium<br><strong>技巧：</strong> <code>Recursion</code>, <code>Bit Representation</code><br><strong>語言：</strong> Go</p>
</blockquote>
<p>解法一：遞迴</p>
<ul>
<li>要產生 power set，就是對於 <code>nums</code> 裡面的數字【取】或【不取】</li>
<li>使用 golang 時必須特別注意：append 數字到 slice 時，記得要 deep copy slice！</li>
</ul>
<pre><code class="go">func subsets(nums []int) [][]int &#123;
    var ret [][]int
    subsetsImpl(nums, 0, []int&#123;&#125;, &amp;ret)
    return ret
&#125;

func subsetsImpl(nums []int, i int, current []int, ret *[][]int) &#123;
    if i == len(nums) &#123;
        *ret = append(*ret, current)
        return
    &#125;

    subsetsImpl(nums, i + 1, current, ret)

    newCurrent := make([]int, len(current))
    copy(newCurrent, current)
    newCurrent = append(newCurrent, nums[i])

    subsetsImpl(nums, i + 1, newCurrent, ret)
&#125;
</code></pre>
<p>解法二：用 bit representation 建 truth table</p>
<ul>
<li>將 <code>2^n</code> 到 <code>2^(n+1)</code> 這段範圍內的數字轉成 binary representation (string)<ul>
<li>e.g., n = 3, 得：1000, 1001, 1010, 1011, 1100, 1101, 1110, 1111</li>
<li>上述的 binary string 去掉第一個 rune 就是 000, 001, 010, 011, …</li>
</ul>
</li>
<li>最後用 truth table 即可輕鬆生成 power set</li>
</ul>
<pre><code class="go">func subsets(nums []int) [][]int &#123;
    var ret [][]int
    n := len(nums)

    for i := math.Pow(2, float64(n)); i &lt; math.Pow(2, float64(n + 1)); i++ &#123;
        bits := strconv.FormatInt(int64(i), 2)[1:]
        
        var subset []int
        for j, bit := range bits &#123;
            if bit == &#39;1&#39; &#123;
                subset = append(subset, nums[j])
            &#125;
        &#125;
        ret = append(ret, subset)
    &#125;

    return ret
&#125;
</code></pre>
<h3 id="Swap-Nodes-in-Pairs"><a href="#Swap-Nodes-in-Pairs" class="headerlink" title="Swap Nodes in Pairs"></a>Swap Nodes in Pairs</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvc3dhcC1ub2Rlcy1pbi1wYWlycy8=">https://leetcode.com/problems/swap-nodes-in-pairs/</span><br><strong>難度：</strong> Medium<br><strong>技巧：</strong> <code>Recursion</code><br><strong>語言：</strong> Go</p>
</blockquote>
<ul>
<li><code>swapPairsImpl(node1, node2)</code><ul>
<li>設定 <code>node1.Next</code><ul>
<li>若沒有下一組 (i.e. <code>node2.Next == nil</code>)，設 <code>node1.Next</code> 為 nil</li>
<li>若還有下一組 (i.e. <code>node2.Next != nil</code>)，用下一組 nodes 再呼叫一次此函數</li>
</ul>
</li>
<li>設定 <code>node2.Next</code><ul>
<li>必定要更新為 <code>node1</code></li>
</ul>
</li>
<li>回傳本組 nodes 在交換後的第一個 node<ul>
<li>若 <code>node2 == nil</code>，交換後的第一個 node 就是 node1</li>
<li>若 <code>node1 != nil</code>，交換後的第一個 node 就是 node2</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="go">/**
 * Definition for singly-linked list.
 * type ListNode struct &#123;
 *     Val int
 *     Next *ListNode
 * &#125;
 */
func swapPairs(head *ListNode) *ListNode &#123;
    if head == nil &#123;
        return nil
    &#125;
    return swapPairsImpl(head, head.Next)
&#125;

func swapPairsImpl(node1, node2 *ListNode) *ListNode &#123;
    if node2 == nil &#123;
        return node1
    &#125;

    if node2.Next == nil &#123;
        node1.Next = nil
    &#125; else &#123;
        node1.Next = swapPairsImpl(node2.Next, node2.Next.Next)
    &#125;
    node2.Next = node1

    return node2
&#125;
</code></pre>
<h3 id="Two-Sum"><a href="#Two-Sum" class="headerlink" title="Two Sum"></a>Two Sum</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdHdvLXN1bS8=">https://leetcode.com/problems/two-sum/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> Go</p>
</blockquote>
<ul>
<li>建一個 complement map<ul>
<li>key：num</li>
<li>value：index</li>
</ul>
</li>
<li>掃瞄 nums，對於每個 num ∈ nums<ul>
<li>對於每個 num，用 num 去查詢 complement map<ul>
<li>若存在，{value, 目前的 index} 就是答案了</li>
<li>不存在，將 {target - num, 目前的 index} 存進去</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="go">func twoSum(nums []int, target int) []int &#123;
    complementIdx := make(map[int]int)

    for i, num := range nums &#123;
        if val, exists := complementIdx[num]; exists &#123;
            return []int&#123;val, i&#125;
        &#125;
        complementIdx[target - num] = i
    &#125;

    return []int&#123;-1, -1&#125;
&#125;
</code></pre>
<h3 id="Valid-Parentheses"><a href="#Valid-Parentheses" class="headerlink" title="Valid Parentheses"></a>Valid Parentheses</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdmFsaWQtcGFyZW50aGVzZXMv">https://leetcode.com/problems/https://leetcode.com/problems/valid-parentheses/</span><br><strong>難度：</strong> Easy<br><strong>技巧：</strong> <code>Stack</code><br><strong>語言：</strong> Go</p>
</blockquote>
<p>使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2VtaXJwYXNpYy9nb2Rz">GoDS</span> (Go Data Structures) library 中的 arraystack</p>
<pre><code class="go">import (
    &quot;github.com/emirpasic/gods/stacks/arraystack&quot;
)

func isValid(s string) bool &#123;
    stack := arraystack.New()

    for _, c := range s &#123;
        switch c &#123;
        case &#39;(&#39;, &#39;[&#39;, &#39;&#123;&#39;:
            stack.Push(getClosingParen(c))
        case &#39;)&#39;, &#39;]&#39;, &#39;&#125;&#39;:
            if val, ok := stack.Pop(); !ok || val != c &#123;
                return false
            &#125;
        default:
            panic(fmt.Sprintf(&quot;unsupported rune: %c&quot;, c))
        &#125;
    &#125;
    
    return stack.Empty()
&#125;

func getClosingParen(r rune) rune &#123;
    switch r &#123;
    case &#39;(&#39;:
        return &#39;)&#39;
    case &#39;[&#39;:
        return &#39;]&#39;
    case &#39;&#123;&#39;:
        return &#39;&#125;&#39;
    default:
        panic(&quot;r must only be a rune in [&#39;(&#39;, &#39;[&#39;, &#39;&#123;&#39;]&quot;)
    &#125;
&#125;
</code></pre>
<h2 id="Two-Pointers"><a href="#Two-Pointers" class="headerlink" title="Two Pointers"></a>Two Pointers</h2><h3 id="Remove-Element"><a href="#Remove-Element" class="headerlink" title="Remove Element"></a>Remove Element</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcmVtb3ZlLWVsZW1lbnQv">https://leetcode.com/problems/remove-element/</span><br><strong>難度：</strong> Easy<br><strong>技巧：</strong> <code>Two Pointers</code><br><strong>語言：</strong> Go</p>
</blockquote>
<p>給你一個 int slice <code>nums</code> 與一個值 <code>val</code>，請將 <code>nums</code> 中所有 <code>val</code> in-place 移除。</p>
<ul>
<li>快慢指標<ul>
<li><code>fast</code>：每次都遞增</li>
<li><code>slow</code>：只在 <code>nums[fast] != val</code> 時才遞增</li>
</ul>
</li>
</ul>
<pre><code class="go">func removeElement(nums []int, val int) int &#123;
    slow, fast := 0, 0
  
    for fast &lt; len(nums) &#123;
        if (nums[fast] != val) &#123;
            nums[slow] = nums[fast]
            slow++
        &#125;
        fast++
    &#125;

    return slow
&#125;
</code></pre>
<h3 id="Remove-Duplicates-from-Sorted-Array"><a href="#Remove-Duplicates-from-Sorted-Array" class="headerlink" title="Remove Duplicates from Sorted Array"></a>Remove Duplicates from Sorted Array</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcmVtb3ZlLWR1cGxpY2F0ZXMtZnJvbS1zb3J0ZWQtYXJyYXkv">https://leetcode.com/problems/remove-duplicates-from-sorted-array/</span><br><strong>難度：</strong> Easy<br><strong>技巧：</strong> <code>Two Pointers</code><br><strong>語言：</strong> Go</p>
</blockquote>
<p>給你一個 int slice <code>nums</code>，請讓 <code>nums</code> 中的元素兩兩不重複。</p>
<pre><code class="go">func removeDuplicates(nums []int) int &#123;
    if len(nums) == 1 &#123;
        return 1
    &#125;

    slow, fast := 0, 1

    for fast &lt; len(nums) &#123;
        if nums[slow] != nums[fast] &#123;
            slow++
            nums[slow] = nums[fast]
        &#125;
        fast++
    &#125;

    return 1 + slow
&#125;
</code></pre>
<h3 id="Container-With-Most-Water"><a href="#Container-With-Most-Water" class="headerlink" title="Container With Most Water"></a>Container With Most Water</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY29udGFpbmVyLXdpdGgtbW9zdC13YXRlci8=">https://leetcode.com/problems/container-with-most-water/</span><br><strong>難度：</strong> Medium<br><strong>技巧：</strong> <code>Two Pointers</code>, <code>Greedy</code><br><strong>語言：</strong> Go</p>
</blockquote>
<p>給你一個 slice，例如：heights = [1,8,6,2,5,4,8,3,7]，每個數字代表該地點的高度，請求出哪兩點之間的積水最多。</p>
<ol>
<li>Bruteforce<ul>
<li>對於每個高度 h ∈ heights<ul>
<li>再掃自己除外的高度，計算積水面積</li>
</ul>
</li>
</ul>
</li>
<li>Two Pointers + Greedy<ul>
<li><code>l</code> 為 heights 的 index，即 0</li>
<li><code>r</code> 為 heights 的 last index，即 <code>len(heights) - 1</code></li>
<li>讓 <code>l</code> 與 <code>r</code> 走向 slice 的中央<ul>
<li>高度較低者，往中間走</li>
<li>高度較高者，不動</li>
<li>在此過程中不斷計算積水面積，並用 <code>max()</code> 更新結果</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code class="go">func maxArea(height []int) int &#123;
    ret := 0
    l := 0
    r := len(height) - 1

    for l &lt;= r &#123;
        ret = max(ret, min(height[l], height[r]) * (r - l))

        if height[l] &lt;= height[r] &#123;
            l++
        &#125; else &#123;
            r--
        &#125;
    &#125;

    return ret
&#125;
</code></pre>
<h2 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h2><h3 id="Binary-Search-1"><a href="#Binary-Search-1" class="headerlink" title="Binary Search"></a>Binary Search</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmluYXJ5LXNlYXJjaC8=">https://leetcode.com/problems/binary-search/</span><br><strong>難度：</strong> Easy<br><strong>技巧：</strong> <code>Binary Search</code><br><strong>語言：</strong> Go</p>
</blockquote>
<pre><code class="go">func search(nums []int, target int) int &#123;
    l := 0
    r := len(nums) - 1
    
    for l &lt;= r &#123;
        m := (l + r) / 2

        if nums[m] &lt; target &#123;
            l = m + 1
        &#125; else if nums[m] &gt; target &#123;
            r = m - 1
        &#125; else &#123;
            return m
        &#125;
    &#125;
    
    return -1
&#125;
</code></pre>
<h3 id="First-Bad-Version"><a href="#First-Bad-Version" class="headerlink" title="First Bad Version"></a>First Bad Version</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvZmlyc3QtYmFkLXZlcnNpb24v">https://leetcode.com/problems/first-bad-version/</span><br><strong>難度：</strong> Easy<br><strong>技巧：</strong> <code>Binary Search</code><br><strong>語言：</strong> Go</p>
</blockquote>
<pre><code class="go">/** 
 * Forward declaration of isBadVersion API.
 * @param   version   your guess about first bad version
 * @return                true if current version is bad 
 *                      false if current version is good
 * func isBadVersion(version int) bool;
 */

func firstBadVersion(n int) int &#123;
    l := 1
    r := n

    for l &lt;= r &#123;
        m := (l + r) / 2
        if isBadVersion(m) &#123;
            r = m - 1
        &#125; else &#123;
            l = m + 1
        &#125;
    &#125;

    return l
&#125;
</code></pre>
<h2 id="Sliding-Window"><a href="#Sliding-Window" class="headerlink" title="Sliding Window"></a>Sliding Window</h2><h3 id="Longest-Substring-Without-Repeating-Characters"><a href="#Longest-Substring-Without-Repeating-Characters" class="headerlink" title="Longest Substring Without Repeating Characters"></a>Longest Substring Without Repeating Characters</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbG9uZ2VzdC1zdWJzdHJpbmctd2l0aG91dC1yZXBlYXRpbmctY2hhcmFjdGVycy8=">https://leetcode.com/problems/longest-substring-without-repeating-characters/</span><br><strong>難度：</strong> Medium<br><strong>技巧：</strong> <code>Sliding Window</code><br><strong>語言：</strong> Go</p>
</blockquote>
<ol>
<li>Bruteforce<ul>
<li>選一個 begin<ul>
<li>選一個 end<ul>
<li>掃描 [begin, end] 內的字元是否有重複</li>
</ul>
</li>
</ul>
</li>
<li>O(N^3)</li>
</ul>
</li>
<li>Sliding Window<ul>
<li>準備一個 map<ul>
<li>key：s 中出現過的字元</li>
<li>value：該字元最後一次出現的 index</li>
</ul>
</li>
<li><code>l</code> 與 <code>r</code> 分別代表 window 左右界<ul>
<li>規則：window 中不可出現重複字元</li>
</ul>
</li>
<li>不斷擴張 window 右界，同時檢查此次擴張是否會使 window 變得不合法<ul>
<li>若合法，繼續擴張</li>
<li>不合法，必須讓它再次合法</li>
</ul>
</li>
<li>對於每個字元 c ∈ s，我們讓 <ul>
<li>若 c 已經在目前的 window 內（即：l ≤ i ≤ r）<ul>
<li>則目前 window 已無效，故更新 <code>l</code> 為最後出現的 idx + 1 使得 window 再次合法</li>
</ul>
</li>
<li>用 <code>max()</code> 更新 <code>maxLen</code>，最後回傳之</li>
<li>將 <code>c</code> 的最後出現 index（即：<code>r</code>）記下來</li>
</ul>
</li>
<li>O(N)</li>
</ul>
</li>
</ol>
<pre><code class="go">func lengthOfLongestSubstring(s string) int &#123;
    l := 0
    maxLen := 0
    lastAppearedAt := make(map[rune]int)

    for r, c := range s &#123;
        // If this character has already appeared before,
        // and if it&#39;s within the current window...
        if idx, exists := lastAppearedAt[c]; exists &amp;&amp; idx &gt;= l &#123;
            l = idx + 1
        &#125;

        maxLen = max(maxLen, r - l + 1)
        lastAppearedAt[c] = r
    &#125;

    return maxLen
&#125;
</code></pre>
<h2 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h2><h3 id="Binary-Tree-Level-Order-Traversal"><a href="#Binary-Tree-Level-Order-Traversal" class="headerlink" title="Binary Tree Level Order Traversal"></a>Binary Tree Level Order Traversal</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtbGV2ZWwtb3JkZXItdHJhdmVyc2FsLw==">https://leetcode.com/problems/binary-tree-level-order-traversal/</span><br><strong>難度：</strong> Medium<br><strong>技巧：</strong> <code>Binary Tree</code>, <code>BFS</code><br><strong>語言：</strong> Go</p>
</blockquote>
<p>使用 queue 做 binary tree BFS，2019 年在台科資工所的推甄入學口試，白板題就是這題。</p>
<pre><code class="go">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func levelOrder(root *TreeNode) [][]int &#123;
    ret := make([][]int, 0)
    q := make([]*TreeNode, 0)

    if root != nil &#123;
        q = append(q, root)
    &#125;

    for len(q) &gt; 0 &#123;
        ret = append(ret, []int&#123;&#125;)

        size := len(q)
        for i := 0; i &lt; size; i++ &#123;
            node := q[0]
            q = q[1:]

            ret[len(ret) - 1] = append(ret[len(ret) - 1], node.Val)

            if node.Left != nil &#123;
                q = append(q, node.Left)
            &#125;

            if node.Right != nil &#123;
                q = append(q, node.Right)
            &#125;
        &#125;
    &#125;

    return ret
&#125;
</code></pre>
<h3 id="Binary-Tree-Preorder-Traversal-Recursive"><a href="#Binary-Tree-Preorder-Traversal-Recursive" class="headerlink" title="Binary Tree Preorder Traversal (Recursive)"></a>Binary Tree Preorder Traversal (Recursive)</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtcHJlb3JkZXItdHJhdmVyc2FsLw==">https://leetcode.com/problems/binary-tree-preorder-traversal/</span><br><strong>難度：</strong> Easy<br><strong>技巧：</strong> <code>Tree</code>, <code>DFS</code><br><strong>語言：</strong> Go</p>
</blockquote>
<pre><code class="go">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func preorderTraversal(root *TreeNode) []int &#123;
    nodes := make([]int, 0)
    preorderTraversalImpl(&amp;nodes, root)
    return nodes
&#125;

func preorderTraversalImpl(nodes *[]int, node *TreeNode) &#123;
    if node == nil &#123;
        return
    &#125;

    *nodes = append(*nodes, node.Val)
    preorderTraversalImpl(nodes, node.Left)
    preorderTraversalImpl(nodes, node.Right)
&#125;
</code></pre>
<h3 id="Binary-Tree-Inorder-Traversal-Recursive"><a href="#Binary-Tree-Inorder-Traversal-Recursive" class="headerlink" title="Binary Tree Inorder Traversal (Recursive)"></a>Binary Tree Inorder Traversal (Recursive)</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtaW5vcmRlci10cmF2ZXJzYWwv">https://leetcode.com/problems/binary-tree-inorder-traversal/</span><br><strong>難度：</strong> Easy<br><strong>技巧：</strong> <code>Tree</code>, <code>DFS</code><br><strong>語言：</strong> Go</p>
</blockquote>
<pre><code class="go">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func inorderTraversal(root *TreeNode) []int &#123;
    nodes := make([]int, 0)
    inorderTraversalImpl(&amp;nodes, root)
    return nodes
&#125;

func inorderTraversalImpl(nodes *[]int, node *TreeNode) &#123;
    if node == nil &#123;
        return
    &#125;

    inorderTraversalImpl(nodes, node.Left)
    *nodes = append(*nodes, node.Val)
    inorderTraversalImpl(nodes, node.Right)
&#125;
</code></pre>
<h3 id="Binary-Tree-Postorder-Traversal-Recursive"><a href="#Binary-Tree-Postorder-Traversal-Recursive" class="headerlink" title="Binary Tree Postorder Traversal (Recursive)"></a>Binary Tree Postorder Traversal (Recursive)</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtcG9zdG9yZGVyLXRyYXZlcnNhbC8=">https://leetcode.com/problems/binary-tree-postorder-traversal/</span><br><strong>難度：</strong> Easy<br><strong>技巧：</strong> <code>Tree</code>, <code>DFS</code><br><strong>語言：</strong> Go</p>
</blockquote>
<pre><code class="go">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func postorderTraversal(root *TreeNode) []int &#123;
    nodes := make([]int, 0)
    postorderTraversalImpl(&amp;nodes, root)
    return nodes
&#125;

func postorderTraversalImpl(nodes *[]int, node *TreeNode) &#123;
    if node == nil &#123;
        return
    &#125;
    
    postorderTraversalImpl(nodes, node.Left)
    postorderTraversalImpl(nodes, node.Right)
    *nodes = append(*nodes, node.Val)
&#125;
</code></pre>
<h3 id="Maximum-Depth-of-Binary-Tree"><a href="#Maximum-Depth-of-Binary-Tree" class="headerlink" title="Maximum Depth of Binary Tree"></a>Maximum Depth of Binary Tree</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWF4aW11bS1kZXB0aC1vZi1iaW5hcnktdHJlZS8=">https://leetcode.com/problems/maximum-depth-of-binary-tree/</span><br><strong>難度：</strong> Easy<br><strong>技巧：</strong> <code>Tree</code>, <code>DFS</code><br><strong>語言：</strong> Go</p>
</blockquote>
<pre><code class="go">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func maxDepth(root *TreeNode) int &#123;
    return maxDepthImpl(root, 1)
&#125;

func maxDepthImpl(node *TreeNode, depth int) int &#123;
    if node == nil &#123;
        return depth - 1
    &#125;

    return max(
        maxDepthImpl(node.Left, depth + 1),
        maxDepthImpl(node.Right, depth + 1))
&#125;
</code></pre>
<h3 id="Minimum-Depth-of-Binary-Tree"><a href="#Minimum-Depth-of-Binary-Tree" class="headerlink" title="Minimum Depth of Binary Tree"></a>Minimum Depth of Binary Tree</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWluaW11bS1kZXB0aC1vZi1iaW5hcnktdHJlZS8=">https://leetcode.com/problems/minimum-depth-of-binary-tree/</span><br><strong>難度：</strong> Easy<br><strong>技巧：</strong> <code>Tree</code>, <code>DFS</code><br><strong>語言：</strong> Go</p>
</blockquote>
<pre><code class="go">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func minDepth(root *TreeNode) int &#123;
    if root == nil &#123;
        return 0
    &#125;

    return minDepthImpl(root, 1)
&#125;

func minDepthImpl(node *TreeNode, depth int) int &#123;
    if node == nil &#123;
        return math.MaxInt
    &#125;
    
    if node.Left == nil &amp;&amp; node.Right == nil &#123;
        return depth
    &#125;

    return min(
        minDepthImpl(node.Left, depth + 1),
        minDepthImpl(node.Right, depth + 1))
&#125;
</code></pre>
<h3 id="Path-Sum"><a href="#Path-Sum" class="headerlink" title="Path Sum"></a>Path Sum</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcGF0aC1zdW0v">https://leetcode.com/problems/path-sum/</span><br><strong>難度：</strong> Easy<br><strong>技巧：</strong> <code>Tree</code>, <code>DFS</code><br><strong>語言：</strong> Go</p>
</blockquote>
<pre><code class="go">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func hasPathSum(root *TreeNode, targetSum int) bool &#123;
    return hasPathSumImpl(root, 0, targetSum)
&#125;

func hasPathSumImpl(node *TreeNode, localSum, targetSum int) bool &#123;
    if node == nil &#123;
        return false
    &#125;
     
    localSum += node.Val   
    
    if node.Left == nil &amp;&amp; node.Right == nil &amp;&amp; localSum == targetSum &#123;
        return true
    &#125;
    
    return hasPathSumImpl(node.Left, localSum, targetSum) ||
           hasPathSumImpl(node.Right, localSum, targetSum)
&#125;
</code></pre>
<h3 id="Path-Sum-II"><a href="#Path-Sum-II" class="headerlink" title="Path Sum II"></a>Path Sum II</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcGF0aC1zdW0taWkv">https://leetcode.com/problems/path-sum-ii/</span><br><strong>難度：</strong> Medium<br><strong>技巧：</strong> <code>Tree</code>, <code>DFS</code>, <code>Backtracking</code><br><strong>語言：</strong> Go</p>
</blockquote>
<ul>
<li>DFS<ul>
<li>PreOrder binary tree traversal</li>
</ul>
</li>
<li>Backtracking<ul>
<li>當前的 path 只需要用同一個 slice 存就好</li>
<li>當一個 node 以及其 children 都已走訪完畢時，就自己從 <code>localPath</code> 的尾部移除（自己一定在尾部）</li>
<li>如果當前是 leaf node 且當前的 pathSum 等於 targetSum，就加入 <code>paths</code>（注意：要 deep copy slice）</li>
</ul>
</li>
</ul>
<pre><code class="go">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func pathSum(root *TreeNode, targetSum int) [][]int &#123;
    var localPath []int
    var paths [][]int
    pathSumImpl(root, 0, targetSum, &amp;localPath, &amp;paths)
    return paths
&#125;

func pathSumImpl(
    node *TreeNode,
    localSum int,
    targetSum int,
    localPath *[]int,
    paths *[][]int,
) &#123;
    if node == nil &#123;
        return
    &#125;

    localSum += node.Val
    *localPath = append(*localPath, node.Val)
    defer func() &#123;
        *localPath = (*localPath)[:len(*localPath) - 1]
    &#125;()

    if node.Left == nil &amp;&amp; node.Right == nil &amp;&amp; localSum == targetSum &#123;
        newPath := make([]int, len(*localPath))
        copy(newPath, *localPath)
        *paths = append(*paths, newPath)
        return
    &#125;

    pathSumImpl(node.Left, localSum, targetSum, localPath, paths)
    pathSumImpl(node.Right, localSum, targetSum, localPath, paths)
&#125;
</code></pre>
<h3 id="Path-Sum-III"><a href="#Path-Sum-III" class="headerlink" title="Path Sum III"></a>Path Sum III</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcGF0aC1zdW0taWkv">https://leetcode.com/problems/path-sum-ii/</span><br><strong>難度：</strong> Medium<br><strong>技巧：</strong> <code>Tree</code>, <code>DFS</code>, <code>Backtracking</code><br><strong>語言：</strong> Go</p>
</blockquote>
<ul>
<li>解法一<ul>
<li>維護 <code>sumMap</code><ul>
<li>key 為 source node</li>
<li>val 為 path sum</li>
</ul>
</li>
<li>DFS + Backtracking<ul>
<li>PreOrder Tree Traversal (中左右)：<code>sumMap</code> 內的 entries 必為同一條 path 上的 nodes</li>
<li>Backtracking：左右子樹走訪完畢後，代表此 node 也處理完了，故將此 node 從 <code>sumMap</code> 移除</li>
<li>走訪經過一個 node 時，先將同條 path 上的（也就是 <code>sumMap</code> 內的）path sum 加上 <code>node.Val</code></li>
</ul>
</li>
<li>此解法有點慢，更優雅的解法見解法二</li>
</ul>
</li>
</ul>
<pre><code class="go">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func pathSum(root *TreeNode, targetSum int) int &#123;
    var count int
    sumMap := make(map[*TreeNode]int)
    pathSumImpl(root, targetSum, sumMap, &amp;count)
    return count
&#125;

func pathSumImpl(node *TreeNode, targetSum int, sumMap map[*TreeNode]int, count *int) &#123;
    if node == nil &#123;
        return
    &#125;

    for srcNode, pathSum := range sumMap &#123;
        sumMap[srcNode] = pathSum + node.Val
        if pathSum + node.Val == targetSum &#123;
            *count++
        &#125;
    &#125;
    sumMap[node] = node.Val

    if node.Val == targetSum &#123;
        *count++
    &#125;
 
    pathSumImpl(node.Left, targetSum, sumMap, count)
    pathSumImpl(node.Right, targetSum, sumMap, count) 

    delete(sumMap, node)
    for srcNode := range sumMap &#123;
        sumMap[srcNode] -= node.Val
    &#125;
&#125;
</code></pre>
<ul>
<li>解法二：<ul>
<li>Two-level recursion<ul>
<li>將 tree 中的每一個 node 視為 source node，並進行 PreOrder Tree Traversal（對，就是那麼粗暴）</li>
<li>難度和 Path Sum 差不多…😅 ，但卻比解法一快，而且還更節省記憶體</li>
<li>注意：<code>localSum == targetSum</code> 不用提早 return，因為會有 subpaths 重疊，但 path sum 相同的情況</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="go">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func pathSum(root *TreeNode, targetSum int) int &#123;
    var count int
    pathSumImpl(root, targetSum, &amp;count)
    return count
&#125;

func pathSumImpl(src *TreeNode, targetSum int, count *int) &#123;
    if src == nil &#123;
        return
    &#125;

    dfs(src, 0, targetSum, count)

    pathSumImpl(src.Left, targetSum, count)
    pathSumImpl(src.Right, targetSum, count)
&#125;

func dfs(node *TreeNode, localSum, targetSum int, count *int) &#123;
    if node == nil &#123;
        return
    &#125;

    localSum += node.Val
    if localSum == targetSum &#123;
        *count++
    &#125;

    dfs(node.Left, localSum, targetSum, count)
    dfs(node.Right, localSum, targetSum, count)
&#125;
</code></pre>
<h3 id="Invert-Binary-Tree"><a href="#Invert-Binary-Tree" class="headerlink" title="Invert Binary Tree"></a>Invert Binary Tree</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaW52ZXJ0LWJpbmFyeS10cmVlLw==">https://leetcode.com/problems/invert-binary-tree/</span><br><strong>難度：</strong> Easy<br><strong>技巧：</strong> <code>Tree</code>, <code>DFS</code><br><strong>語言：</strong> Go</p>
</blockquote>
<ul>
<li>可以使用 Preorder DFS 或 Postorder DFS</li>
<li>不可使用 Inorder DFS</li>
</ul>
<pre><code class="go">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func invertTree(root *TreeNode) *TreeNode &#123;
    invertTreeImpl(root) 
    return root
&#125;

func invertTreeImpl(node *TreeNode) &#123;
    if node == nil &#123;
        return
    &#125; 

    node.Left, node.Right = node.Right, node.Left
    invertTreeImpl(node.Left)
    invertTreeImpl(node.Right)
&#125;
</code></pre>
<h3 id="Implement-Trie-Prefix-Tree"><a href="#Implement-Trie-Prefix-Tree" class="headerlink" title="Implement Trie (Prefix Tree)"></a>Implement Trie (Prefix Tree)</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaW1wbGVtZW50LXRyaWUtcHJlZml4LXRyZWUv">https://leetcode.com/problems/implement-trie-prefix-tree/</span><br><strong>難度：</strong> Medium<br><strong>技巧：</strong> <code>Trie</code>, <code>Tree</code><br><strong>語言：</strong> Go</p>
</blockquote>
<ul>
<li>測資是 n 個 strings，每個字串只會包含小寫英文字母</li>
<li>實作 Trie 這個資料結構，並提供下列 API<ul>
<li><code>Trie::Insert()</code>：插入一個 string</li>
<li><code>Trie::Search()</code>：搜尋 string (exact match)</li>
<li><code>Trie::StartsWith()</code>：搜尋 string (prefix match)</li>
</ul>
</li>
<li>每個 trie node 多一個 <code>isEnd</code> data member<ul>
<li>用途：記錄該 node 是否為一個曾插入過的 string 的最後字元</li>
</ul>
</li>
</ul>
<pre><code class="go">type Node struct &#123;
    val rune
    children []*Node
    isEnd bool
&#125;

type Trie struct &#123;
    root *Node
&#125;

func (this *Node) addChild(r rune) *Node &#123;
    newChild := Node&#123;val: r, children: make([]*Node, 0)&#125;
    this.children = append(this.children, &amp;newChild)
    return &amp;newChild
&#125;

func (this *Node) getChild(r rune) *Node &#123;
    for _, node := range this.children &#123;
        if node.val == r &#123;
            return node
        &#125;
    &#125;
    return nil
&#125;

func Constructor() Trie &#123;
    return Trie&#123;root: &amp;Node&#123;children: make([]*Node, 0)&#125;&#125;
&#125;

func (this *Trie) Insert(word string)  &#123;
    node := this.root
    
    for _, c := range word &#123;
        if child := node.getChild(c); child != nil &#123;
            node = child
        &#125; else &#123;
            node = node.addChild(c)
        &#125;
    &#125;
    
    node.isEnd = true
&#125;

func (this *Trie) walk(word string) *Node &#123;
    node := this.root
    for _, c := range word &#123;
        if child := node.getChild(c); child != nil &#123;
            node = child
        &#125; else &#123;
            return nil
        &#125;
    &#125;
    
    return node
&#125;

func (this *Trie) Search(word string) bool &#123;
    node := this.walk(word)
    return node != nil &amp;&amp; node.isEnd
&#125;

func (this *Trie) StartsWith(prefix string) bool &#123;
    node := this.walk(prefix)
    return node != nil
&#125;


/**
 * Your Trie object will be instantiated and called as such:
 * obj := Constructor();
 * obj.Insert(word);
 * param_2 := obj.Search(word);
 * param_3 := obj.StartsWith(prefix);
 */
</code></pre>
<h3 id="Maximum-Product-of-Splitted-Binary-Tree"><a href="#Maximum-Product-of-Splitted-Binary-Tree" class="headerlink" title="Maximum Product of Splitted Binary Tree"></a>Maximum Product of Splitted Binary Tree</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWF4aW11bS1wcm9kdWN0LW9mLXNwbGl0dGVkLWJpbmFyeS10cmVlLw==">https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/</span><br><strong>難度：</strong> Medium<br><strong>技巧：</strong> <code>Tree</code>, <code>DFS</code><br><strong>語言：</strong> Go</p>
</blockquote>
<p>從 tree 移除任一個 edge，使其分裂為兩棵 subtrees，請求出兩棵 subtrees 各自加總後，最大的乘積為何</p>
<ul>
<li>Binary Tree DFS<ul>
<li>將每個 tree node 當成 subtree 的 root node</li>
<li>用 PostOrder traversal 以 bottom up 的方式建 subtree sum map (<code>dp</code>)</li>
</ul>
</li>
<li>掃一次 subtree sum map<ul>
<li>每個 iteration 的 (key, value) 即 (node, node 作為 subtree1 root 的 sum)</li>
<li>subtree2 的 sum = 原 tree 的 sum - subtree1 的 sum</li>
</ul>
</li>
</ul>
<pre><code class="go">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func maxProduct(root *TreeNode) int &#123;
    dp := make(map[*TreeNode]uint64)
    maxProductImpl(dp, root) 

    ret := uint64(0)
    treeSum := dp[root]
    for _, subtreeSum := range dp &#123;
        sum1 := subtreeSum
        sum2 := treeSum - sum1
        ret = max(ret, sum1 * sum2)
    &#125;
    return int(ret % uint64(1000000007))
&#125;

func maxProductImpl(dp map[*TreeNode]uint64, node *TreeNode) &#123;
    if node == nil &#123;
        return
    &#125;

    maxProductImpl(dp, node.Left)
    maxProductImpl(dp, node.Right)
    dp[node] = dp[node.Left] + uint64(node.Val) + dp[node.Right]
&#125;
</code></pre>
<h2 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h2><h3 id="Is-Graph-Bipartite"><a href="#Is-Graph-Bipartite" class="headerlink" title="Is Graph Bipartite?"></a>Is Graph Bipartite?</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaXMtZ3JhcGgtYmlwYXJ0aXRlLw==">https://leetcode.com/problems/is-graph-bipartite/</span><br><strong>難度：</strong> Medium<br><strong>技巧：</strong> <code>Graph</code>, <code>BFS</code><br><strong>語言：</strong> Go</p>
</blockquote>
<p>給定一個 undirected graph（以 adjacency list 的形式），判斷它是否為<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmlwYXJ0aXRlX2dyYXBo">bipartite</span></p>
<ul>
<li>Graph BFS<ul>
<li>沒走訪過的 node 才需要進 queue</li>
<li>如果某個 neighbor 已經走訪過，它就會有個顏色（藍或紅），檢查一下是否和目前的 node 顏色相同<ul>
<li>相同：不是二分圖，立刻返回 false</li>
<li>不同：繼續 BFS</li>
</ul>
</li>
<li>注意：<ul>
<li>測資未必是 connected graph，只用 node 0 下去跑 BFS 會漏掉某部分 subgraph</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="go">var (
    visited []bool
    colors []bool
)

func isBipartite(graph [][]int) bool &#123;
    visited = make([]bool, len(graph))
    colors = make([]bool, len(graph)) 

    for nodeIdx := range graph &#123;
        if !visited[nodeIdx] &amp;&amp; !isBipartiteImpl(graph, nodeIdx) &#123;
            return false
        &#125;
    &#125;
    return true
&#125;

func isBipartiteImpl(graph [][]int, beginNodeIdx int) bool &#123;
    currentColor := true  // true: blue, false: red 
    q := []int&#123;beginNodeIdx&#125;

    for len(q) &gt; 0 &#123;
        size := len(q)   

        for i := 0; i &lt; size; i++ &#123;
            thisNodeIdx := q[0]
            q = q[1:]

            visited[thisNodeIdx] = true
            colors[thisNodeIdx] = currentColor

            for _, neighborIdx := range graph[thisNodeIdx] &#123;
                // Push all the neighbors of thisNode into the queue
                // for the next iteration of BFS.
                if !visited[neighborIdx] &#123;
                    q = append(q, neighborIdx)
                &#125; else if colors[neighborIdx] == currentColor &#123;
                    return false
                &#125;
            &#125;
        &#125;

        // Invert color
        currentColor = !currentColor
    &#125;

    return true
&#125;
</code></pre>
<h3 id="Network-Delay-Time"><a href="#Network-Delay-Time" class="headerlink" title="Network Delay Time"></a>Network Delay Time</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbmV0d29yay1kZWxheS10aW1lLw==">https://leetcode.com/problems/network-delay-time/</span><br><strong>難度：</strong> Medium<br><strong>技巧：</strong> <code>Graph</code>, <code>Dijkstra</code><br><strong>語言：</strong> Go</p>
</blockquote>
<p>給你一個 network graph，裡面有 n 個 nodes。請問從 node <code>k-1</code> 開始 broadcast signal 的話，最快要花多久時間所有 nodes 才能全都收到該 signal？</p>
<p>從圖論的角度來解釋，給你：</p>
<ul>
<li>一個 weighted digraph（以 weighted adjacency list）的形式</li>
<li>一個 source node <code>k</code></li>
</ul>
<p>請找出該 graph 中與 k 最遠的距離（i.e. 沿路權重的加總）</p>
<ol>
<li>Dijkstra (<span class="exturl" data-url="aHR0cHM6Ly95b3V0dS5iZS9wVmZqNm14aGRNdz90PTEzMg==">https://youtu.be/pVfj6mxhdMw?t=132</span>)<ul>
<li>輸入：weighted adjacency matrix, source node</li>
<li>輸出：從 source node 到其他所有 nodes 的 shortest distances</li>
<li>注意：題目給的權重可能會有 0，所以任兩節點間若沒有 edge，在 <code>graph</code> 中要以 -1 來表示</li>
<li>輸出的 slice 取 max element 就是答案</li>
</ul>
</li>
</ol>
<pre><code class="go">// Dijkstra: Single-Source All-Destinations Shortest Path
func dijkstra(graph [][]int, n int, k int) []int &#123;
    visited := make([]bool, n)
    previous := make([]int, n)
    distances := make([]int, n)

    // Set node k (index: k - 1) as the source node.
    for i := 0; i &lt; n; i++ &#123;
        distances[i] = math.MaxInt
    &#125;
    distances[k - 1] = 0

    for sliceContains(visited, false) &#123;
        // Find an unvisited node with the shortest distance from node k.
        i := 0
        minDist := math.MaxInt

        for j := 0; j &lt; n; j++ &#123;
            if !visited[j] &amp;&amp; distances[j] &lt;= minDist &#123;
                minDist = distances[j]
                i = j
            &#125;
        &#125;

        for j := 0; j &lt; n; j++ &#123;
            if !visited[j] &amp;&amp; graph[i][j] != -1 &#123;
                // If the distance between [i, j] is less than
                // the known distance, update the shortest distance.
                if d := distances[i] + graph[i][j]; d &lt; distances[j] &#123;
                    distances[j] = d
                    previous[i] = i
                &#125;
            &#125;
        &#125;

        visited[i] = true
    &#125;

    fmt.Println(distances)
    return distances
&#125;

func networkDelayTime(times [][]int, n int, k int) int &#123;
    // Build the weighted adjacency matrix of the graph.
    graph := make([][]int, n)

    for i := range graph &#123;
        graph[i] = make([]int, n)
        for j := range graph[i] &#123;
            graph[i][j] = -1
        &#125;
    &#125;

    for _, t := range times &#123;
        src := t[0] - 1
        dst := t[1] - 1
        weight := t[2]

        graph[src][dst] = weight
    &#125;

    if ret := max(dijkstra(graph, n, k)...); ret == math.MaxInt &#123;
        return -1
    &#125; else &#123;
        return ret
    &#125;
&#125;
</code></pre>
<h2 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h2><h3 id="Maximum-Subarray"><a href="#Maximum-Subarray" class="headerlink" title="Maximum Subarray"></a>Maximum Subarray</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWF4aW11bS1zdWJhcnJheS8=">https://leetcode.com/problems/maximum-subarray/</span><br><strong>難度：</strong> Medium<br><strong>技巧：</strong> <code>DP</code> <code>Kadane</code><br><strong>語言：</strong> Go</p>
</blockquote>
<ul>
<li>Kadane’s Algorithm [<span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0Byc2luZ2hhbDc1Ny9rYWRhbmVzLWFsZ29yaXRobS1keW5hbWljLXByb2dyYW1taW5nLWhvdy1hbmQtd2h5LWRvZXMtaXQtd29yay0zZmQ4ODQ5ZWQ3M2Q=">ref</span>]<ul>
<li>維護一個變數 <code>localMax</code>，並掃一次 <code>nums</code>，每輪掃到的數字叫 <code>num</code><ul>
<li><code>localMax</code> 代表截至為止（不含 <code>num</code>）的 maximum subarray 的和</li>
<li>看看 <code>localMax</code> 加上 <code>num</code> 是否會更大</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="go">func maxSubArray(nums []int) int &#123;
    globalMax := math.MinInt
    localMax := 0
    for _, num := range nums &#123;
        localMax = max(num, num + localMax)
        globalMax = max(globalMax, localMax)
    &#125;

    return globalMax
&#125;
</code></pre>
<h3 id="Maximum-Product-Subarray"><a href="#Maximum-Product-Subarray" class="headerlink" title="Maximum Product Subarray"></a>Maximum Product Subarray</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWF4aW11bS1wcm9kdWN0LXN1YmFycmF5Lw==">https://leetcode.com/problems/maximum-product-subarray/</span><br><strong>難度：</strong> Medium<br><strong>技巧：</strong> <code>DP</code> <code>Kadane</code><br><strong>語言：</strong> Go</p>
</blockquote>
<ul>
<li>基於 Kadane’s Algorithm<ul>
<li><code>localMax</code>：因為是乘法，所以一開始得初始化為 1 而不是 0，否則之後再怎麼乘都是 0</li>
<li><code>localMin</code>：因為乘法可能負負得正，進而產生一個更大的正數，所以還要額外維護此變數</li>
<li>掃一次 <code>nums</code>，每輪掃到的數字叫 <code>num</code><ul>
<li>若 <code>num</code> 為正數，則 <code>num</code> 乘以正的 <code>localMax</code> 有機會產生一個更大的正數</li>
<li>若 <code>num</code> 為負數，則 <code>num</code> 乘以負的 <code>localMin</code> 有機會產生一個更大的正數</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="go">func maxProduct(nums []int) int &#123;
    globalMax := math.MinInt
    localMax, localMin := 1, 1
    for _, num := range nums &#123;
        prod1 := num * localMax
        prod2 := num * localMin
        localMax = max(num, prod1, prod2)
        localMin = min(num, prod1, prod2)
        globalMax = max(globalMax, localMax)
    &#125;

    return globalMax
&#125;
</code></pre>
<h3 id="House-Robber"><a href="#House-Robber" class="headerlink" title="House Robber"></a>House Robber</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaG91c2Utcm9iYmVyLw==">https://leetcode.com/problems/house-robber/</span><br><strong>難度：</strong> Medium<br><strong>技巧：</strong> <code>DP</code><br><strong>語言：</strong> Go</p>
</blockquote>
<ul>
<li>DP<ul>
<li><code>dp</code> 是一個一維的 slice<ul>
<li><code>dp[i]</code> 代表從 <code>nums[0]</code> 搶到 <code>nums[i]</code> 為止，所能獲得的最大金額<ul>
<li><code>dp[0]</code> = 搶到 <code>nums[0]</code> 為止最多能搶多少，這邊只有 <code>nums[0]</code> 一間房屋能搶</li>
<li><code>dp[1]</code> = 搶到 <code>nums[1]</code> 為止最多能搶多少，這邊選 <code>nums[0]</code> 與 <code>nums[1]</code> 價值較高者</li>
</ul>
</li>
<li>要搶這一棟，就不能搶它前一棟<ul>
<li>max(前一棟可以搶到的最大金額, 前前一棟可以搶到的最大金額 + 現在這棟)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="go">func rob(nums []int) int &#123;
    if len(nums) == 1 &#123;
        return nums[0]
    &#125;
    if len(nums) == 2 &#123;
        return max(nums[0], nums[1])
    &#125;

    dp := make([]int, len(nums))
    dp[0] = nums[0]
    dp[1] = max(nums[0], nums[1])
    for i := 2; i &lt; len(nums); i++ &#123;
        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])
    &#125;

    return dp[len(nums) - 1]
&#125;
</code></pre>
<h3 id="Unique-Paths"><a href="#Unique-Paths" class="headerlink" title="Unique Paths"></a>Unique Paths</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdW5pcXVlLXBhdGhzLw==">https://leetcode.com/problems/unique-paths/</span><br><strong>難度：</strong> Medium<br><strong>技巧：</strong> <code>DP</code><br><strong>語言：</strong> Go</p>
</blockquote>
<ul>
<li>DP<ul>
<li><code>dp</code> 是一個二維 m x n slice (m rows, n cols)<ul>
<li>每一格代表：從左上角走到該點的總方法數</li>
<li>第一個 row 的所有格子填入 0</li>
<li>第一個 col 的所有格子填入 0</li>
</ul>
</li>
<li>每次移動只能往右、往下<ul>
<li>也就是說，抵達每個格子的方法數 = 左邊來的方法數 + 上面來的方法數</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="go">func uniquePaths(m int, n int) int &#123;
    dp := make([][]int, m)
    for i := range dp &#123;
        dp[i] = make([]int, n)
    &#125;
    
    for i := 0; i &lt; m; i++ &#123;
        dp[i][0] = 1
    &#125;
    for i := 0; i &lt; n; i++ &#123;
        dp[0][i] = 1
    &#125;
    
    for i := 1; i &lt; m; i++ &#123;
        for j := 1; j &lt; n; j++ &#123;
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        &#125;
    &#125;
    
    return dp[m - 1][n - 1]
&#125;
</code></pre>
<h3 id="Unique-Paths-II"><a href="#Unique-Paths-II" class="headerlink" title="Unique Paths II"></a>Unique Paths II</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdW5pcXVlLXBhdGhzLWlpLw==">https://leetcode.com/problems/unique-paths-ii/</span><br><strong>難度：</strong> Medium<br><strong>技巧：</strong> <code>DP</code><br><strong>語言：</strong> Go</p>
</blockquote>
<ul>
<li>DP<ul>
<li>解法和 Unique Path 87% 像，初始化第一個 row 與第一個 col 時記得考慮障礙物<ul>
<li>如果掃到一半遇到障礙物，後面的格子肯定都無法抵達</li>
</ul>
</li>
<li>如果某個格子有障礙物，那麼抵達該點的方法數必為 0</li>
</ul>
</li>
</ul>
<pre><code class="go">func uniquePathsWithObstacles(obstacleGrid [][]int) int &#123;
    m := len(obstacleGrid)
    n := len(obstacleGrid[0])
    
    dp := make([][]int, m)
    for i := range dp &#123;
        dp[i] = make([]int, n)
    &#125;
    
    for i := 0; i &lt; m; i++ &#123;
        if obstacleGrid[i][0] == 1 &#123;
            break
        &#125;
        dp[i][0] = 1
    &#125;
    
    for i := 0; i &lt; n; i++ &#123;
        if obstacleGrid[0][i] == 1 &#123;
            break
        &#125;
        dp[0][i] = 1
    &#125;
    
    for i := 1; i &lt; m; i++ &#123;
        for j := 1; j &lt; n; j++ &#123;
            if obstacleGrid[i][j] == 0 &#123;
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
            &#125;
        &#125;
    &#125;
    
    return dp[m - 1][n - 1]
&#125;
</code></pre>
<h3 id="Minimum-Path-Sum"><a href="#Minimum-Path-Sum" class="headerlink" title="Minimum Path Sum"></a>Minimum Path Sum</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWluaW11bS1wYXRoLXN1bS8=">https://leetcode.com/problems/minimum-path-sum/</span><br><strong>難度：</strong> Medium<br><strong>技巧：</strong> <code>DP</code><br><strong>語言：</strong> Go</p>
</blockquote>
<ul>
<li>DP<ul>
<li>解法和 Unique Path 87% 像，<code>dp</code> 內每格存的是到達該處的 minimum path sum</li>
</ul>
</li>
</ul>
<pre><code class="go">func minPathSum(grid [][]int) int &#123;
    m := len(grid)
    n := len(grid[0])

    dp := make([][]int, m)
    for i := 0; i &lt; m; i++ &#123;
        dp[i] = make([]int, n)
    &#125;

    dp[0][0] = grid[0][0]
    for i := 1; i &lt; m; i++ &#123;
        dp[i][0] = dp[i - 1][0] + grid[i][0]
    &#125;
    for i := 1; i &lt; n; i++ &#123;
        dp[0][i] = dp[0][i - 1] + grid[0][i]
    &#125;

    for i := 1; i &lt; m; i++ &#123;
        for j := 1; j &lt; n; j++ &#123;
            dp[i][j] = min(dp[i][j - 1] + grid[i][j], dp[i - 1][j] + grid[i][j])
        &#125;
    &#125;

    return dp[m - 1][n - 1]
&#125;
</code></pre>
<h3 id="Longest-Common-Subsequence"><a href="#Longest-Common-Subsequence" class="headerlink" title="Longest Common Subsequence"></a>Longest Common Subsequence</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbG9uZ2VzdC1jb21tb24tc3Vic2VxdWVuY2Uv">https://leetcode.com/problems/longest-common-subsequence/</span><br><strong>難度：</strong> Medium<br><strong>技巧：</strong> <code>DP</code><br><strong>語言：</strong> Go</p>
</blockquote>
<p>二維 DP：若 char 相同左上角 + 1, 否則左邊上面取 max, 最後答案在右下</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1ObkQ5NmFiaXp3dw==">https://www.youtube.com/watch?v=NnD96abizww</span></p>
<pre><code class="go">func longestCommonSubsequence(text1 string, text2 string) int &#123;
    m := 1 + len(text2)
    n := 1 + len(text1)
  
    dp := make([][]int, m)
    for i := range dp &#123;
        dp[i] = make([]int, n)
    &#125;

    for i := 1; i &lt; m; i++ &#123;
        for j := 1; j &lt; n; j++ &#123;
            if text2[i - 1] == text1[j - 1] &#123;
                dp[i][j] = dp[i - 1][j - 1] + 1
            &#125; else &#123;
                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])
            &#125;
        &#125;
    &#125;

    return dp[m - 1][n - 1]
&#125;
</code></pre>
<h3 id="Longest-Increasing-Subsequence"><a href="#Longest-Increasing-Subsequence" class="headerlink" title="Longest Increasing Subsequence"></a>Longest Increasing Subsequence</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbG9uZ2VzdC1pbmNyZWFzaW5nLXN1YnNlcXVlbmNlLw==">https://leetcode.com/problems/longest-increasing-subsequence/</span><br><strong>難度：</strong> Medium<br><strong>技巧：</strong> <code>DP</code><br><strong>語言：</strong> Go</p>
</blockquote>
<p>一維 DP：Bottom-up，<code>dp</code> slice 中第 i 個 element，代表 <code>nums</code> 中第 i 個 element 結尾的 LIS 長度。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj03REtGcFduYXhMSQ==">https://www.youtube.com/watch?v=7DKFpWnaxLI</span></p>
<pre><code class="go">func lengthOfLIS(nums []int) int &#123;
    n := len(nums)
    dp := make([]int, n)

    for i := range dp &#123;
        dp[i] = 1
    &#125;

    for i := 1; i &lt; n; i++ &#123;
        for j := 0; j &lt; i; j++ &#123;
            if nums[j] &lt; nums[i] &#123;
                dp[i] = max(dp[i], dp[j] + 1)
            &#125;
        &#125;
    &#125;

    return max(dp...)
&#125;
</code></pre>
<h3 id="Trapping-Rain-Water"><a href="#Trapping-Rain-Water" class="headerlink" title="Trapping Rain Water"></a>Trapping Rain Water</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdHJhcHBpbmctcmFpbi13YXRlci8=">https://leetcode.com/problems/trapping-rain-water/</span><br><strong>難度：</strong> Hard<br><strong>技巧：</strong> <code>DP</code><br><strong>語言：</strong> Go</p>
</blockquote>
<p>給你一個 slice，例如：heights = [0,1,0,2,1,0,1,3,2,1,2,1]，每個數字代表該地點的高度，要你算出會積多少格的水。</p>
<ol>
<li>Bruteforce<ul>
<li>對於每個 x，我們都找出該點以左的最高高度、該點以右的最高高度，看看該 x 能積多少水。</li>
<li>時間：O(N^2)</li>
</ul>
</li>
<li>一維 DP<ul>
<li>準備兩個 slice<ul>
<li><code>ls</code>：記錄每個點「該點以左的最高高度」</li>
<li><code>rs</code>：記錄每個點「該點以右的最高高度」</li>
</ul>
</li>
<li>掃一次 heights，對於每個 h ∈ heights<ul>
<li>積水的最高可能高度： <code>min(ls[i], rs[i])</code></li>
<li>該點高度：<code>h</code></li>
<li>將上述兩者相減，請特別注意這一步可能出現負數</li>
<li>若相減結果 &gt; 0 就累加到 <code>ret</code>，最後回傳之</li>
</ul>
</li>
<li>時間：O(N)</li>
</ul>
</li>
</ol>
<pre><code class="go">func trap(height []int) int &#123;
    size := len(height)
    l := 0
    r := 0
    ls := make([]int, size)
    rs := make([]int, size) 

    // [0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3]
    for i := 0; i &lt; size; i++ &#123;
        ls[i] = max(l, height[i])
        l = ls[i]
    &#125;

    // [3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 0]
    for i := size - 1; i &gt;= 0; i-- &#123;
        rs[i] = max(r, height[i])
        r = rs[i]
    &#125;

    var ret int
    for i, h := range height &#123;
        ret += max(0, min(ls[i], rs[i]) - h)
    &#125;
    return ret
&#125;
</code></pre>
<h3 id="Product-of-Array-Except-Self"><a href="#Product-of-Array-Except-Self" class="headerlink" title="Product of Array Except Self"></a>Product of Array Except Self</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcHJvZHVjdC1vZi1hcnJheS1leGNlcHQtc2VsZi8=">https://leetcode.com/problems/product-of-array-except-self/</span><br><strong>難度：</strong> Medium<br><strong>技巧：</strong> <code>DP</code><br><strong>語言：</strong> Go</p>
</blockquote>
<p>給你一個 slice，例如：nums = [1,2,3,4]，請回傳 [24,12,8,6]。</p>
<ol>
<li>Bruteforce<ul>
<li>選定第 i 個元素，計算其 product of array except self<ul>
<li>從頭到尾掃一次，遇到自己就跳過</li>
</ul>
</li>
<li>O(N^2)</li>
</ul>
</li>
<li>一維 DP<ul>
<li>準備兩個 slice<ul>
<li><code>l</code>：自己以左（不含自己）所有元素的積，如：[1, 1, 2, 6]，從左到右建</li>
<li><code>r</code>：自己以右（不含自己）所有元素的積，如：[24, 12, 4, 1]，從右到左建</li>
</ul>
</li>
<li>將 <code>l</code> 與 <code>r</code> 相同 index 的元素乘起來就是答案</li>
<li>O(N)</li>
</ul>
</li>
</ol>
<pre><code class="go">func productExceptSelf(nums []int) []int &#123;
    size := len(nums)

    l := make([]int, size)
    r := make([]int, size)

    l[0] = 1
    r[size - 1] = 1

    // [1, 1, 2, 6]
    for i := 1; i &lt; size; i++ &#123;
        l[i] = l[i - 1] * nums[i - 1]
    &#125;

    // [24, 12, 4, 1]
    for i := size - 2; i &gt;= 0; i-- &#123;
        r[i] = r[i + 1] * nums[i + 1]
    &#125;

    for i := range l &#123;
        l[i] *= r[i]
    &#125;

    return l
&#125;
</code></pre>
<h2 id="Simulation"><a href="#Simulation" class="headerlink" title="Simulation"></a>Simulation</h2><h3 id="Spiral-Matrix-II"><a href="#Spiral-Matrix-II" class="headerlink" title="Spiral Matrix II"></a>Spiral Matrix II</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvc3BpcmFsLW1hdHJpeC1paS8=">https://leetcode.com/problems/spiral-matrix-ii/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> Go</p>
</blockquote>
<ul>
<li>規律<ul>
<li>1x1：(右1)</li>
<li>2x2：(右1) (下1 左1)</li>
<li>3x3：(右2) (下2 左2) (上1 右1)</li>
<li>4x4：(右3) (下3 左3) (上2 右2) (下1 左1)</li>
<li>5x5：(右4) (下4 左4) (上3 右3) (下2 左2) (上1 右1)</li>
<li>6x6：…</li>
</ul>
</li>
</ul>
<pre><code class="go">func generateMatrix(n int) [][]int &#123;
    matrix := make([][]int, n)
    for i := range matrix &#123;
        matrix[i] = make([]int, n)
    &#125;

    row, col := 0, 0
    for i := 1; i &lt;= n; i++ &#123;
        matrix[row][col] = i
        col++
    &#125;
    col--

    i := n + 1
    n2 := int(math.Pow(float64(n), float64(2)))
    dist := n - 1
    for i &lt;= n2 &#123;
        // Down
        for j := 0; j &lt; dist &amp;&amp; i &lt;= n2; j, i = j+1, i+1 &#123;
            row++
            matrix[row][col] = i
        &#125;
        // Left
        for j := 0; j &lt; dist &amp;&amp; i &lt;= n2; j, i = j+1, i+1 &#123;
            col--
            matrix[row][col] = i
        &#125;

        dist--

        // Up
        for j := 0; j &lt; dist &amp;&amp; i &lt;= n2; j, i = j+1, i+1 &#123;
            row--
            matrix[row][col] = i
        &#125;
        // Right
        for j := 0; j &lt; dist &amp;&amp; i &lt;= n2; j, i = j+1, i+1 &#123;
            col++
            matrix[row][col] = i
        &#125;

        dist--
    &#125;

    return matrix
&#125;
</code></pre>

  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2022-12-19 22:57:44" itemprop="dateModified" datetime="2022-12-19T22:57:44+08:00">2022-12-19</time>
  </span>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>Post author:  </strong>aesophor <i class="ic i-at"><em>@</em></i>日新又新
  </li>
  <li class="link">
    <strong>Post link: </strong>
    <a href="https://aesophor.github.io/leetcode/index.html" title="LeetCode 刷題紀錄">https://aesophor.github.io/leetcode/index.html</a>
  </li>
  <li class="license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#LeetCode-%E5%88%B7%E9%A1%8C%E8%A8%98%E9%8C%84"><span class="toc-number">1.</span> <span class="toc-text">LeetCode 刷題記錄</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Misc"><span class="toc-number">1.1.</span> <span class="toc-text">Misc</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Add-Two-Numbers"><span class="toc-number">1.1.1.</span> <span class="toc-text">Add Two Numbers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#K-Closest-Points-to-Origin"><span class="toc-number">1.1.2.</span> <span class="toc-text">K Closest Points to Origin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Longest-Common-Prefix"><span class="toc-number">1.1.3.</span> <span class="toc-text">Longest Common Prefix</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Longest-Palindromic-Substring"><span class="toc-number">1.1.4.</span> <span class="toc-text">Longest Palindromic Substring</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Merge-Intervals"><span class="toc-number">1.1.5.</span> <span class="toc-text">Merge Intervals</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Insert-Interval"><span class="toc-number">1.1.6.</span> <span class="toc-text">Insert Interval</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Merge-Two-Sorted-Lists"><span class="toc-number">1.1.7.</span> <span class="toc-text">Merge Two Sorted Lists</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reverse-Integer"><span class="toc-number">1.1.8.</span> <span class="toc-text">Reverse Integer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rotate-Image"><span class="toc-number">1.1.9.</span> <span class="toc-text">Rotate Image</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rotate-List"><span class="toc-number">1.1.10.</span> <span class="toc-text">Rotate List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Search-a-2D-Matrix"><span class="toc-number">1.1.11.</span> <span class="toc-text">Search a 2D Matrix</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set-Matrix-Zeroes"><span class="toc-number">1.1.12.</span> <span class="toc-text">Set Matrix Zeroes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Simplify-Path"><span class="toc-number">1.1.13.</span> <span class="toc-text">Simplify Path</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Subsets"><span class="toc-number">1.1.14.</span> <span class="toc-text">Subsets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Swap-Nodes-in-Pairs"><span class="toc-number">1.1.15.</span> <span class="toc-text">Swap Nodes in Pairs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Two-Sum"><span class="toc-number">1.1.16.</span> <span class="toc-text">Two Sum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Valid-Parentheses"><span class="toc-number">1.1.17.</span> <span class="toc-text">Valid Parentheses</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Two-Pointers"><span class="toc-number">1.2.</span> <span class="toc-text">Two Pointers</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Remove-Element"><span class="toc-number">1.2.1.</span> <span class="toc-text">Remove Element</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Remove-Duplicates-from-Sorted-Array"><span class="toc-number">1.2.2.</span> <span class="toc-text">Remove Duplicates from Sorted Array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Container-With-Most-Water"><span class="toc-number">1.2.3.</span> <span class="toc-text">Container With Most Water</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binary-Search"><span class="toc-number">1.3.</span> <span class="toc-text">Binary Search</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Binary-Search-1"><span class="toc-number">1.3.1.</span> <span class="toc-text">Binary Search</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#First-Bad-Version"><span class="toc-number">1.3.2.</span> <span class="toc-text">First Bad Version</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sliding-Window"><span class="toc-number">1.4.</span> <span class="toc-text">Sliding Window</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Longest-Substring-Without-Repeating-Characters"><span class="toc-number">1.4.1.</span> <span class="toc-text">Longest Substring Without Repeating Characters</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tree"><span class="toc-number">1.5.</span> <span class="toc-text">Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Binary-Tree-Level-Order-Traversal"><span class="toc-number">1.5.1.</span> <span class="toc-text">Binary Tree Level Order Traversal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binary-Tree-Preorder-Traversal-Recursive"><span class="toc-number">1.5.2.</span> <span class="toc-text">Binary Tree Preorder Traversal (Recursive)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binary-Tree-Inorder-Traversal-Recursive"><span class="toc-number">1.5.3.</span> <span class="toc-text">Binary Tree Inorder Traversal (Recursive)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binary-Tree-Postorder-Traversal-Recursive"><span class="toc-number">1.5.4.</span> <span class="toc-text">Binary Tree Postorder Traversal (Recursive)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Maximum-Depth-of-Binary-Tree"><span class="toc-number">1.5.5.</span> <span class="toc-text">Maximum Depth of Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Minimum-Depth-of-Binary-Tree"><span class="toc-number">1.5.6.</span> <span class="toc-text">Minimum Depth of Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Path-Sum"><span class="toc-number">1.5.7.</span> <span class="toc-text">Path Sum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Path-Sum-II"><span class="toc-number">1.5.8.</span> <span class="toc-text">Path Sum II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Path-Sum-III"><span class="toc-number">1.5.9.</span> <span class="toc-text">Path Sum III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Invert-Binary-Tree"><span class="toc-number">1.5.10.</span> <span class="toc-text">Invert Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Implement-Trie-Prefix-Tree"><span class="toc-number">1.5.11.</span> <span class="toc-text">Implement Trie (Prefix Tree)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Maximum-Product-of-Splitted-Binary-Tree"><span class="toc-number">1.5.12.</span> <span class="toc-text">Maximum Product of Splitted Binary Tree</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Graph"><span class="toc-number">1.6.</span> <span class="toc-text">Graph</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Is-Graph-Bipartite"><span class="toc-number">1.6.1.</span> <span class="toc-text">Is Graph Bipartite?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Network-Delay-Time"><span class="toc-number">1.6.2.</span> <span class="toc-text">Network Delay Time</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dynamic-Programming"><span class="toc-number">1.7.</span> <span class="toc-text">Dynamic Programming</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Maximum-Subarray"><span class="toc-number">1.7.1.</span> <span class="toc-text">Maximum Subarray</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Maximum-Product-Subarray"><span class="toc-number">1.7.2.</span> <span class="toc-text">Maximum Product Subarray</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#House-Robber"><span class="toc-number">1.7.3.</span> <span class="toc-text">House Robber</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unique-Paths"><span class="toc-number">1.7.4.</span> <span class="toc-text">Unique Paths</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unique-Paths-II"><span class="toc-number">1.7.5.</span> <span class="toc-text">Unique Paths II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Minimum-Path-Sum"><span class="toc-number">1.7.6.</span> <span class="toc-text">Minimum Path Sum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Longest-Common-Subsequence"><span class="toc-number">1.7.7.</span> <span class="toc-text">Longest Common Subsequence</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Longest-Increasing-Subsequence"><span class="toc-number">1.7.8.</span> <span class="toc-text">Longest Increasing Subsequence</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Trapping-Rain-Water"><span class="toc-number">1.7.9.</span> <span class="toc-text">Trapping Rain Water</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Product-of-Array-Except-Self"><span class="toc-number">1.7.10.</span> <span class="toc-text">Product of Array Except Self</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Simulation"><span class="toc-number">1.8.</span> <span class="toc-text">Simulation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spiral-Matrix-II"><span class="toc-number">1.8.1.</span> <span class="toc-text">Spiral Matrix II</span></a></li></ol></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="Related">
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="aesophor"
      data-src="/images/avatar.png">
  <p class="name" itemprop="name">aesophor</p>
  <div class="description" itemprop="description">eku</div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">2</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">2</span>
        <span class="name">categories</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">3</span>
        <span class="name">tags</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Flc29waG9y" title="https:&#x2F;&#x2F;github.com&#x2F;aesophor"><i class="ic i-github"></i></span>
      <span class="exturl item instagram" data-url="aHR0cHM6Ly93d3cuaW5zdGFncmFtLmNvbS9hZXNvcGhvci8=" title="https:&#x2F;&#x2F;www.instagram.com&#x2F;aesophor&#x2F;"><i class="ic i-instagram"></i></span>
      <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9hZXNvcGhvcg==" title="https:&#x2F;&#x2F;twitter.com&#x2F;aesophor"><i class="ic i-twitter"></i></span>
      <span class="exturl item linkedin" data-url="aHR0cHM6Ly93d3cubGlua2VkaW4uY29tL2luL2Flc29waG9yLw==" title="https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;aesophor&#x2F;"><i class="ic i-address-card"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>Home</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-user"></i>About</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/about/en-us" rel="section"><i class="ic i-address-card"></i>English</a>
  </li>

        
  <li class="item">
    <a href="/about/zh-tw" rel="section"><i class="ic i-address-card"></i>中文</a>
  </li>

  </ul>
        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/leetcode" rel="section"><i class="ic i-magic"></i>LeetCode</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>Random Posts</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Linux/" title="In Linux">Linux</a>
</div>

    <span><a href="/2020/07/20/Arch-Linux-on-MacBook-Pro-11-2-with-Custom-NVMe-M-2-SSD/" title="Arch Linux on MacBook Pro 11,2 with Custom NVMe M.2 SSD">Arch Linux on MacBook Pro 11,2 with Custom NVMe M.2 SSD</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/CTF/" title="In CTF">CTF</a>
</div>

    <span><a href="/2022/08/27/pwnable-tw-secret-garden/" title="[pwnable.tw] Secret Garden (350 pts)">[pwnable.tw] Secret Garden (350 pts)</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>Recent Comments</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2020 – 
    <span itemprop="copyrightYear">2022</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">aesophor @ aesophor's Blog</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: 'leetcode/',
    favicon: {
      show: "（●´3｀●）Goooood",
      hide: "(´Д｀)Booooom"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,fancybox: true,
    copyright: 'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
