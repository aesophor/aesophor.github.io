



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="日新又新" href="https://aesophor.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="日新又新" href="https://aesophor.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="日新又新" href="https://aesophor.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  

<link rel="canonical" href="https://aesophor.github.io/leetcode/">



  <title>LeetCode 刷題紀錄 |
aesophor's Blog</title>
<meta name="generator" content="Hexo 5.4.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">LeetCode 刷題紀錄
  </h1>

          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">aesophor's Blog</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
          <img src="https://images.unsplash.com/photo-1533441325263-74682c42d779?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80">
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="page wrap">
    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="en">
  <link itemprop="mainEntityOfPage" href="https://aesophor.github.io/leetcode/index.html">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.png">
    <meta itemprop="name" content="aesophor">
    <meta itemprop="description" content="努力不會背叛人，它走不快，但早晚會跟上, eku">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="日新又新">
  </span>

  <div class="body md" itemprop="articleBody">
    

    
# LeetCode 刷題記錄

## Misc

### Add Two Numbers

> **題目：** https://leetcode.com/problems/add-two-numbers/
> **難度：** Medium
> **語言：** Go

給你兩條 linked list，value 為 123 在 input 是 3 → 2 → 1 → nil，用一樣的 linked list 回傳兩數之和。

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    var head *ListNode
    var curr *ListNode
    carry := false

    for l1 != nil || l2 != nil || carry {
        val := 0
        if carry {
            val += 1
        }
        carry = false
    
        if l1 != nil {
            val += l1.Val
            l1 = l1.Next
        }
    
        if l2 != nil {
            val += l2.Val
            l2 = l2.Next
        }

        if val > 9 {
            carry = true
            val -= 10
        }

        var newNode *ListNode = &ListNode{val, nil}
        if curr == nil {
            head = newNode
        } else {
            curr.Next = newNode
        }
        curr = newNode
    }

    if head == nil {
        head = &ListNode{0, nil}
    }

    return head
}
```

### K Closest Points to Origin

> **題目：** https://leetcode.com/problems/k-closest-points-to-origin/
> **難度：** Medium
> **技巧：** `Sort`
> **語言：** Go

對 points 按照歐式距離做升冪排序後，前 k 個點就是答案。

```go
func kClosest(points [][]int, k int) [][]int {
    sort.SliceStable(points, func(i, j int) bool {
        p1 := points[i]
        p2 := points[j]
        dist1 := math.Hypot(float64(p1[0]), float64(p1[1]))
        dist2 := math.Hypot(float64(p2[0]), float64(p2[1]))
        return dist1 <= dist2
    })
    return points[:k]
}
```

### Longest Common Prefix

> **題目：** https://leetcode.com/problems/longest-common-prefix/
> **難度：** Easy
> **語言：** Go

```go
func longestCommonPrefix(strs []string) string {
    numStrs := len(strs)
    minLen := math.MaxInt32
    i := 0

    for _, str := range strs {
        minLen = min(minLen, len(str))
    }

    for ; i < minLen; i++ {
        for j := 1; j < numStrs; j++ {
            if strs[0][i] != strs[j][i] {
                return strs[0][:i]
            }
        }
    }

    return strs[0][:i]
}
```

### Longest Palindromic Substring

> **題目：** https://leetcode.com/problems/longest-palindromic-substring/
> **難度：** Medium
> **技巧：** `Two Pointers`
> **語言：** Go

給你一個字串 `str`，例如："babad" 的答案是 "aba"，而 "cbbd" 的答案是 "bb"。

* Two Pointers
  - 迴文的長度可能是奇數或偶數，兩種情況都要檢查。
  - 檢查方式：expand around center
    - 奇數長度迴文：選一個 center, `c1`, 往左右 expand
    - 偶數長度迴文：選兩個 center, `c1`, `c2`, 往左右 expand
  - 特別注意
    - 奇數情況：例如 "abc" 以 b 為中心，會碰到 `c1 == c2`
      - 迴文長度為 1 ("b")
      - `expand()` 回傳 (c1+1, c2-1)，計算長度：(c2-1) - (c1+1) + 1 = 1
    - 偶數情況：例如 "abcd 以 bc 為中心，會碰到 `c1 == c2 - 1`
      - 迴文長度為 0 ("")
      - `expand()` 回傳 (c1+1, c2-1)，計算長度：(c2-1) - (c1+1) + 1 = (c2-1) - c2 + 1 = 0
    - 巧妙地算出了正確的迴文長度

```go
func longestPalindrome(str string) string {
    strLen := len(str)
    maxLen := 0
    ret := ""

    for i := 0; i < strLen; i++ {
        begin1, end1 := expand(str, strLen, i, i)
        localLen := end1 - begin1 + 1

        if localLen > maxLen {
            ret = str[begin1:end1 + 1]
            maxLen = localLen
        }
    
        begin2, end2 := expand(str, strLen, i, i + 1)
        localLen = end2 - begin2 + 1
    
        if localLen > maxLen {
            ret = str[begin2:end2 + 1]
            maxLen = localLen
        }
    }

    return ret
}

// If the length of palindrome is even,
// e.g. abba, then there will be two centers: bb
func expand(str string, strLen int, c1 int, c2 int) (int, int) {
    for c1 >= 0 && c2 < strLen {
        if str[c1] != str[c2] {
            break
        }
        c1--
        c2++
    }

    return c1 + 1, c2 - 1
}
```

### Merge Intervals

> **題目：** https://leetcode.com/problems/merge-intervals/
> **難度：** Medium
> **技巧：** `Sort`
> **語言：** Go

* 對 `intervals` 根據左界進行 ascending 排序
* 掃一次 `intervals`
  - 與 last merged interval 無 overlap：就直接 append
  - 與 last merged interval 有 overlap：更新右界，看是原本的大，還是新的大

```go
func merge(intervals [][]int) [][]int {
    sort.SliceStable(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })

    ret := make([][]int, 0)
    for _, interval := range intervals {
        if len(ret) == 0 || last(ret)[1] < interval[0] {
            ret = append(ret, interval)
        } else {
            last(ret)[1] = max(last(ret)[1], interval[1])
        }
    }
    return ret
}

func last(s [][]int) []int {
    return s[len(s) - 1]
}
```

### Insert Interval

> **題目：** https://leetcode.com/problems/insert-interval/
> **難度：** Medium
> **語言：** Go

1. 暴力解：
   - 將 `newInterval` append 到 `intervals` 並根據左界進行 ascending sort
   - 將此問題 reduce 成 Merge Intervals
2. 比較有效率的解法：
   - 從頭掃描 `intervals`
     - 若與 `newInterval` 無 overlap，直接 append 到 `ret`
     - 若與 `newInterval` 有 overlap，確認目前掃描到的 interval 與 `newInterval` 融合後的左右界
   - 將 `newInterval` append 到 `ret`
   - 從剛剛掃描暫停的地方繼續，往後掃完 `intervals` 剩餘的部分
     - 因為不確定 `newInterval` 所橫跨的範圍多大，故此部分的邏輯同 Merge Intervals 的解法

```go
func insert(intervals [][]int, newInterval []int) [][]int {
    var i int
    var ret [][]int

    for i = 0; i < len(intervals); i++ {
        interval := intervals[i]
        if newInterval[0] <= interval[1] {
            newInterval = []int{min(interval[0], newInterval[0]), newInterval[1]}
            break
        }
        ret = append(ret, interval)
    }

    ret = append(ret, newInterval)

    for ; i < len(intervals); i++ {
        interval := intervals[i]
        if len(ret) == 0 || last(ret)[1] < interval[0] {
            ret = append(ret, interval)
        } else {
            last(ret)[1] = max(last(ret)[1], interval[1])
        }
    }
    
    return ret
}

func last(s [][]int) []int {
    return s[len(s) - 1]
}
```

### Merge Two Sorted Lists

> **題目：** https://leetcode.com/problems/merge-two-sorted-lists/
> **難度：** Easy
> **技巧：** `Linked Lists`
> **語言：** Go

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
    var head *ListNode
    var curr *ListNode
    
    for list1 != nil || list2 != nil {
        newNode := &ListNode{}
        
        if list1 != nil && list2 == nil {
            newNode.Val = list1.Val
            list1 = list1.Next
        } else if list1 == nil && list2 != nil {
            newNode.Val = list2.Val
            list2 = list2.Next
        } else {
            if list1.Val <= list2.Val {
                newNode.Val = list1.Val
                list1 = list1.Next
            } else {
                newNode.Val = list2.Val
                list2 = list2.Next
            }
        }

        if head == nil {
            head = newNode
        } else {
            curr.Next = newNode
        }
        
        curr = newNode
    }
    return head
}
```

### Reverse Integer

> **題目：** https://leetcode.com/problems/reverse-integer/
> **難度：** Medium
> **語言：** Go

在 `ret *= 10` 前，記得檢查此操作是否會造成 `ret` signed integer overflow。

```go
func reverse(x int) int {
    ret := 0

    for x != 0 {
        if ret > 0 && ret > math.MaxInt32 / 10 {
            return 0
        }
        if ret < 0 && ret < math.MinInt32 / 10 {
            return 0
        }

        ret *= 10   
        ret += x % 10
        x /= 10
    }

    return ret
}
```

### Rotate Image

> **題目：** https://leetcode.com/problems/rotate-image/
> **難度：** Medium
> **技巧：** `Matrix`
> **語言：** Go

Matrix rotation = Transpose + 水平翻轉

```go
func rotate(matrix [][]int)  {
    transpose(matrix)
    flipHorizontally(matrix)
}

// Def: transpose = swap the column and row of each element in matrix.
func transpose(matrix [][]int) {
    for i := range matrix {
        for j := 0; j < i; j++ {
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        }
    }
}

func flipHorizontally(matrix [][]int) {
    for _, row := range matrix {
        reverse(row)
    }
}

func reverse(nums []int) {
    for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {
        nums[i], nums[j] = nums[j], nums[i]
    } 
}
```

### Rotate List

> **題目：** https://leetcode.com/problems/rotate-list/
> **難度：** Medium
> **語言：** Go

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func rotateRight(head *ListNode, k int) *ListNode {
    if head == nil {
        return nil
    }
    if k == 0 {
        return head
    }

    oldHead := head
    size, oldTail := traverse(head)
    
    k %= size
    if k == 0 {
        return head
    }
    
    newHeadPos := size - k
    newTailPos := newHeadPos - 1

    newHead := oldHead
    for i := 0; i < newHeadPos; i++ {
        newHead = newHead.Next
    }
    
    newTail := oldHead
    for i := 0; i < newTailPos; i++ {
        newTail = newTail.Next
    }
    newTail.Next = nil
    oldTail.Next = oldHead
    
    return newHead
}

func traverse(node *ListNode) (int, *ListNode) {
    size := 0
    prev := node
    for node != nil {
        prev = node
        node = node.Next
        size++
    }
    return size, prev
}
```

### Search a 2D Matrix

> **題目：** https://leetcode.com/problems/search-a-2d-matrix/
> **難度：** Medium
> **語言：** Go

```go
func searchMatrix(matrix [][]int, target int) bool {
    m := len(matrix)
    n := len(matrix[0])

    i := m - 1
    j := n - 1

    for i >= 0 && j >= 0 {
        if matrix[i][j] == target {
            return true
        } else if matrix[i][0] > target {
            i--
        } else if matrix[i][j] > target {
            j--
        } else {
            break
        }
    }

    return false
}
```

### Set Matrix Zeroes

> **題目：** https://leetcode.com/problems/set-matrix-zeroes/
> **難度：** Medium
> **技巧：** `Hash Set`
> **語言：** Go

```go
func setZeroes(matrix [][]int) {
    m := len(matrix)
    n := len(matrix[0])

    rowsToClear := make(map[int]struct{})
    colsToClear := make(map[int]struct{})

    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if matrix[i][j] == 0 {
                rowsToClear[i] = struct{}{}
                colsToClear[j] = struct{}{}
            }
        }
    }

    for row := range rowsToClear {
        matrix[row] = make([]int, n)
    }
    for col := range colsToClear {
        for i := 0; i < m; i++ {
            matrix[i][col] = 0
        }
    }
}
```

### Simplify Path

> **題目：** https://leetcode.com/problems/simplify-path/
> **難度：** Medium
> **語言：** Go

```go
func simplifyPath(path string) string {
    var components []string
    for _, c := range strings.Split(path, "/") {
        switch c {
        case ".":
        case "..":
            if len(components) > 0 {
                components = components[:len(components) - 1]
            }
        default:
            if len(c) > 0 {
                components = append(components, c)
            }
        }
    }

    return "/" + strings.Join(components, "/")
}
```

### Subsets

> **題目：** https://leetcode.com/problems/subsets/
> **難度：** Medium
> **技巧：** `Recursion`, `Bit Representation`
> **語言：** Go

解法一：遞迴
* 要產生 power set，就是對於 `nums` 裡面的數字【取】或【不取】
* 使用 golang 時必須特別注意：append 數字到 slice 時，記得要 deep copy slice！

```go
func subsets(nums []int) [][]int {
    var ret [][]int
    subsetsImpl(nums, 0, []int{}, &ret)
    return ret
}

func subsetsImpl(nums []int, i int, current []int, ret *[][]int) {
    if i == len(nums) {
        *ret = append(*ret, current)
        return
    }

    subsetsImpl(nums, i + 1, current, ret)

    newCurrent := make([]int, len(current))
    copy(newCurrent, current)
    newCurrent = append(newCurrent, nums[i])

    subsetsImpl(nums, i + 1, newCurrent, ret)
}
```

解法二：用 bit representation 建 truth table
* 將 `2^n` 到 `2^(n+1)` 這段範圍內的數字轉成 binary representation (string)
  - e.g., n = 3, 得：1000, 1001, 1010, 1011, 1100, 1101, 1110, 1111
  - 上述的 binary string 去掉第一個 rune 就是 000, 001, 010, 011, ...
* 最後用 truth table 即可輕鬆生成 power set

```go
func subsets(nums []int) [][]int {
    var ret [][]int
    n := len(nums)

    for i := math.Pow(2, float64(n)); i < math.Pow(2, float64(n + 1)); i++ {
        bits := strconv.FormatInt(int64(i), 2)[1:]
        
        var subset []int
        for j, bit := range bits {
            if bit == '1' {
                subset = append(subset, nums[j])
            }
        }
        ret = append(ret, subset)
    }

    return ret
}
```

### Swap Nodes in Pairs

> **題目：** https://leetcode.com/problems/swap-nodes-in-pairs/
> **難度：** Medium
> **技巧：** `Recursion`
> **語言：** Go

* `swapPairsImpl(node1, node2)`
  - 設定 `node1.Next`
    - 若沒有下一組 (i.e. `node2.Next == nil`)，設 `node1.Next` 為 nil
    - 若還有下一組 (i.e. `node2.Next != nil`)，用下一組 nodes 再呼叫一次此函數
  - 設定 `node2.Next`
    - 必定要更新為 `node1`
  - 回傳本組 nodes 在交換後的第一個 node
    - 若 `node2 == nil`，交換後的第一個 node 就是 node1
    - 若 `node1 != nil`，交換後的第一個 node 就是 node2

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func swapPairs(head *ListNode) *ListNode {
    if head == nil {
        return nil
    }
    return swapPairsImpl(head, head.Next)
}

func swapPairsImpl(node1, node2 *ListNode) *ListNode {
    if node2 == nil {
        return node1
    }

    if node2.Next == nil {
        node1.Next = nil
    } else {
        node1.Next = swapPairsImpl(node2.Next, node2.Next.Next)
    }
    node2.Next = node1

    return node2
}
```

### Two Sum

> **題目：** https://leetcode.com/problems/two-sum/
> **難度：** Easy
> **語言：** Go

* 建一個 complement map
  - key：num
  - value：index
* 掃瞄 nums，對於每個 num ∈ nums
  - 對於每個 num，用 num 去查詢 complement map
    - 若存在，{value, 目前的 index} 就是答案了
    - 不存在，將 {target - num, 目前的 index} 存進去

```go
func twoSum(nums []int, target int) []int {
    complementIdx := make(map[int]int)

    for i, num := range nums {
        if val, exists := complementIdx[num]; exists {
            return []int{val, i}
        }
        complementIdx[target - num] = i
    }

    return []int{-1, -1}
}
```

### Valid Parentheses

> **題目：** https://leetcode.com/problems/https://leetcode.com/problems/valid-parentheses/
> **難度：** Easy
> **技巧：** `Stack`
> **語言：** Go

使用 [GoDS](https://github.com/emirpasic/gods) (Go Data Structures) library 中的 arraystack

```go
import (
    "github.com/emirpasic/gods/stacks/arraystack"
)

func isValid(s string) bool {
    stack := arraystack.New()

    for _, c := range s {
        switch c {
        case '(', '[', '{':
            stack.Push(getClosingParen(c))
        case ')', ']', '}':
            if val, ok := stack.Pop(); !ok || val != c {
                return false
            }
        default:
            panic(fmt.Sprintf("unsupported rune: %c", c))
        }
    }
    
    return stack.Empty()
}

func getClosingParen(r rune) rune {
    switch r {
    case '(':
        return ')'
    case '[':
        return ']'
    case '{':
        return '}'
    default:
        panic("r must only be a rune in ['(', '[', '{']")
    }
}
```

## Two Pointers

### Remove Element

> **題目：** https://leetcode.com/problems/remove-element/
> **難度：** Easy
> **技巧：** `Two Pointers`
> **語言：** Go

給你一個 int slice `nums` 與一個值 `val`，請將 `nums` 中所有 `val` in-place 移除。

* 快慢指標
  - `fast`：每次都遞增
  - `slow`：只在 `nums[fast] != val` 時才遞增

```go
func removeElement(nums []int, val int) int {
    slow, fast := 0, 0
  
    for fast < len(nums) {
        if (nums[fast] != val) {
            nums[slow] = nums[fast]
            slow++
        }
        fast++
    }

    return slow
}
```

### Remove Duplicates from Sorted Array

> **題目：** https://leetcode.com/problems/remove-duplicates-from-sorted-array/
> **難度：** Easy
> **技巧：** `Two Pointers`
> **語言：** Go

給你一個 int slice `nums`，請讓 `nums` 中的元素兩兩不重複。

```go
func removeDuplicates(nums []int) int {
    if len(nums) == 1 {
        return 1
    }

    slow, fast := 0, 1

    for fast < len(nums) {
        if nums[slow] != nums[fast] {
            slow++
            nums[slow] = nums[fast]
        }
        fast++
    }

    return 1 + slow
}
```

### Container With Most Water

> **題目：** https://leetcode.com/problems/container-with-most-water/
> **難度：** Medium
> **技巧：** `Two Pointers`, `Greedy`
> **語言：** Go

給你一個 slice，例如：heights = [1,8,6,2,5,4,8,3,7]，每個數字代表該地點的高度，請求出哪兩點之間的積水最多。

1. Bruteforce
   - 對於每個高度 h ∈ heights
     - 再掃自己除外的高度，計算積水面積
2. Two Pointers + Greedy
   - `l` 為 heights 的 index，即 0
   - `r` 為 heights 的 last index，即 `len(heights) - 1`
   - 讓 `l` 與 `r` 走向 slice 的中央
     - 高度較低者，往中間走
     - 高度較高者，不動
     - 在此過程中不斷計算積水面積，並用 `max()` 更新結果

```go
func maxArea(height []int) int {
    ret := 0
    l := 0
    r := len(height) - 1

    for l <= r {
        ret = max(ret, min(height[l], height[r]) * (r - l))

        if height[l] <= height[r] {
            l++
        } else {
            r--
        }
    }

    return ret
}
```

## Binary Search

### Binary Search

> **題目：** https://leetcode.com/problems/binary-search/
> **難度：** Easy
> **技巧：** `Binary Search`
> **語言：** Go

```go
func search(nums []int, target int) int {
    l := 0
    r := len(nums) - 1
    
    for l <= r {
        m := (l + r) / 2

        if nums[m] < target {
            l = m + 1
        } else if nums[m] > target {
            r = m - 1
        } else {
            return m
        }
    }
    
    return -1
}
```

### First Bad Version

> **題目：** https://leetcode.com/problems/first-bad-version/
> **難度：** Easy
> **技巧：** `Binary Search`
> **語言：** Go

```go
/** 
 * Forward declaration of isBadVersion API.
 * @param   version   your guess about first bad version
 * @return 	 	      true if current version is bad 
 *			          false if current version is good
 * func isBadVersion(version int) bool;
 */

func firstBadVersion(n int) int {
    l := 1
    r := n

    for l <= r {
        m := (l + r) / 2
        if isBadVersion(m) {
            r = m - 1
        } else {
            l = m + 1
        }
    }

    return l
}
```

## Sliding Window

### Longest Substring Without Repeating Characters

> **題目：** https://leetcode.com/problems/longest-substring-without-repeating-characters/
> **難度：** Medium
> **技巧：** `Sliding Window`
> **語言：** Go

1. Bruteforce
   - 選一個 begin
     - 選一個 end
       - 掃描 [begin, end] 內的字元是否有重複
   - O(N^3)
2. Sliding Window
   - 準備一個 map
     - key：s 中出現過的字元
     - value：該字元最後一次出現的 index
   - `l` 與 `r` 分別代表 window 左右界
     - 規則：window 中不可出現重複字元
   - 不斷擴張 window 右界，同時檢查此次擴張是否會使 window 變得不合法
     - 若合法，繼續擴張
     - 不合法，必須讓它再次合法
   - 對於每個字元 c ∈ s，我們讓 
     - 若 c 已經在目前的 window 內（即：l ≤ i ≤ r）
       - 則目前 window 已無效，故更新 `l` 為最後出現的 idx + 1 使得 window 再次合法
     - 用 `max()` 更新 `maxLen`，最後回傳之
     - 將 `c` 的最後出現 index（即：`r`）記下來
   - O(N)

```go
func lengthOfLongestSubstring(s string) int {
    l := 0
    maxLen := 0
    lastAppearedAt := make(map[rune]int)

    for r, c := range s {
        // If this character has already appeared before,
        // and if it's within the current window...
        if idx, exists := lastAppearedAt[c]; exists && idx >= l {
            l = idx + 1
        }

        maxLen = max(maxLen, r - l + 1)
        lastAppearedAt[c] = r
    }

    return maxLen
}
```

### Maximum Average Subarray I

> **題目：** https://leetcode.com/problems/maximum-average-subarray-i/
> **難度：** Easy
> **技巧：** `Sliding Window`
> **語言：** C++17

給你一串 int `nums`，並且告訴你 subarray len 為 `k`

用 sliding window 算出所有長度為 k 的 subarrays 的 maximum avg

```cpp
class Solution {
 public:
  double findMaxAverage(vector<int>& nums, int k) {
    const int n = nums.size();
    int l = 0;
    int r = k - 1;
    double sum = std::accumulate(nums.begin(), nums.begin() + k, 0);
    double maxAvg = std::numeric_limits<float>::lowest();

    while (r < n) {
      maxAvg = std::max(maxAvg, sum / k);

      sum -= nums[l];
      l++;

      r++;
      if (r < n) {
        sum += nums[r];
      }
    }

    return maxAvg;
  }
};
```

### Minimum Size Subarray Sum

> **題目：** https://leetcode.com/problems/minimum-size-subarray-sum/
> **難度：** Medium
> **技巧：** `Sliding Window`
> **語言：** C++17

給你一串數字 `nums` 以及一個 `target`（皆為正整數），求最短的 subarray `s` 的長度 where `len(s) >= target`

* Sliding Window
  - 往右擴張右界
  - 擴張後，在 subarray sum 還大於等於 `target` 的情況下，將左界持續往右推移
  - 紀錄下最小的 subarray length

```cpp
class Solution {
 public:
  int minSubArrayLen(int target, vector<int>& nums) {
    const int n = nums.size();
    int l = 0;
    int r = 0;
    int sum = 0;
    int len = std::numeric_limits<int>::max();

    for (; r < n; r++) {
      sum += nums[r];

      while (l < r && sum - nums[l] >= target) {
        sum -= nums[l];
        l++;
      }

      if (sum >= target) {
        len = std::min(len, r - l + 1);
      }
    }

    return len == std::numeric_limits<int>::max() ? 0 : len;
  }
};
```

## Tree

### Binary Tree Level Order Traversal

> **題目：** https://leetcode.com/problems/binary-tree-level-order-traversal/
> **難度：** Medium
> **技巧：** `Binary Tree`, `BFS`
> **語言：** Go

使用 queue 做 binary tree BFS，2019 年在台科資工所的推甄入學口試，白板題就是這題。

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func levelOrder(root *TreeNode) [][]int {
    ret := make([][]int, 0)
    q := make([]*TreeNode, 0)

    if root != nil {
        q = append(q, root)
    }

    for len(q) > 0 {
        ret = append(ret, []int{})

        size := len(q)
        for i := 0; i < size; i++ {
            node := q[0]
            q = q[1:]

            ret[len(ret) - 1] = append(ret[len(ret) - 1], node.Val)

            if node.Left != nil {
                q = append(q, node.Left)
            }

            if node.Right != nil {
                q = append(q, node.Right)
            }
        }
    }

    return ret
}
```

### Binary Tree Preorder Traversal (Recursive)

> **題目：** https://leetcode.com/problems/binary-tree-preorder-traversal/
> **難度：** Easy
> **技巧：** `Tree`, `DFS`
> **語言：** Go

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func preorderTraversal(root *TreeNode) []int {
    nodes := make([]int, 0)
    preorderTraversalImpl(&nodes, root)
    return nodes
}

func preorderTraversalImpl(nodes *[]int, node *TreeNode) {
    if node == nil {
        return
    }

    *nodes = append(*nodes, node.Val)
    preorderTraversalImpl(nodes, node.Left)
    preorderTraversalImpl(nodes, node.Right)
}
```

### Binary Tree Inorder Traversal (Recursive)

> **題目：** https://leetcode.com/problems/binary-tree-inorder-traversal/
> **難度：** Easy
> **技巧：** `Tree`, `DFS`
> **語言：** Go

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func inorderTraversal(root *TreeNode) []int {
    nodes := make([]int, 0)
    inorderTraversalImpl(&nodes, root)
    return nodes
}

func inorderTraversalImpl(nodes *[]int, node *TreeNode) {
    if node == nil {
        return
    }

    inorderTraversalImpl(nodes, node.Left)
    *nodes = append(*nodes, node.Val)
    inorderTraversalImpl(nodes, node.Right)
}
```

### Binary Tree Postorder Traversal (Recursive)

> **題目：** https://leetcode.com/problems/binary-tree-postorder-traversal/
> **難度：** Easy
> **技巧：** `Tree`, `DFS`
> **語言：** Go

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func postorderTraversal(root *TreeNode) []int {
    nodes := make([]int, 0)
    postorderTraversalImpl(&nodes, root)
    return nodes
}

func postorderTraversalImpl(nodes *[]int, node *TreeNode) {
    if node == nil {
        return
    }
    
    postorderTraversalImpl(nodes, node.Left)
    postorderTraversalImpl(nodes, node.Right)
    *nodes = append(*nodes, node.Val)
}
```

### Maximum Depth of Binary Tree

> **題目：** https://leetcode.com/problems/maximum-depth-of-binary-tree/
> **難度：** Easy
> **技巧：** `Tree`, `DFS`
> **語言：** Go

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func maxDepth(root *TreeNode) int {
    return maxDepthImpl(root, 1)
}

func maxDepthImpl(node *TreeNode, depth int) int {
    if node == nil {
        return depth - 1
    }

    return max(
        maxDepthImpl(node.Left, depth + 1),
        maxDepthImpl(node.Right, depth + 1))
}
```

### Minimum Depth of Binary Tree

> **題目：** https://leetcode.com/problems/minimum-depth-of-binary-tree/
> **難度：** Easy
> **技巧：** `Tree`, `DFS`
> **語言：** Go

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func minDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }

    return minDepthImpl(root, 1)
}

func minDepthImpl(node *TreeNode, depth int) int {
    if node == nil {
        return math.MaxInt
    }
    
    if node.Left == nil && node.Right == nil {
        return depth
    }

    return min(
        minDepthImpl(node.Left, depth + 1),
        minDepthImpl(node.Right, depth + 1))
}
```

### Path Sum

> **題目：** https://leetcode.com/problems/path-sum/
> **難度：** Easy
> **技巧：** `Tree`, `DFS`
> **語言：** Go

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func hasPathSum(root *TreeNode, targetSum int) bool {
    return hasPathSumImpl(root, 0, targetSum)
}

func hasPathSumImpl(node *TreeNode, localSum, targetSum int) bool {
    if node == nil {
        return false
    }
     
    localSum += node.Val   
    
    if node.Left == nil && node.Right == nil && localSum == targetSum {
        return true
    }
    
    return hasPathSumImpl(node.Left, localSum, targetSum) ||
           hasPathSumImpl(node.Right, localSum, targetSum)
}
```

### Path Sum II

> **題目：** https://leetcode.com/problems/path-sum-ii/
> **難度：** Medium
> **技巧：** `Tree`, `DFS`, `Backtracking`
> **語言：** Go

* DFS
  - PreOrder binary tree traversal
* Backtracking
  - 當前的 path 只需要用同一個 slice 存就好
  - 當一個 node 以及其 children 都已走訪完畢時，就自己從 `localPath` 的尾部移除（自己一定在尾部）
  - 如果當前是 leaf node 且當前的 pathSum 等於 targetSum，就加入 `paths`（注意：要 deep copy slice）

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func pathSum(root *TreeNode, targetSum int) [][]int {
    var localPath []int
    var paths [][]int
    pathSumImpl(root, 0, targetSum, &localPath, &paths)
    return paths
}

func pathSumImpl(
    node *TreeNode,
    localSum int,
    targetSum int,
    localPath *[]int,
    paths *[][]int,
) {
    if node == nil {
        return
    }

    localSum += node.Val
    *localPath = append(*localPath, node.Val)
    defer func() {
        *localPath = (*localPath)[:len(*localPath) - 1]
    }()

    if node.Left == nil && node.Right == nil && localSum == targetSum {
        newPath := make([]int, len(*localPath))
        copy(newPath, *localPath)
        *paths = append(*paths, newPath)
        return
    }

    pathSumImpl(node.Left, localSum, targetSum, localPath, paths)
    pathSumImpl(node.Right, localSum, targetSum, localPath, paths)
}
```

### Path Sum III

> **題目：** https://leetcode.com/problems/path-sum-ii/
> **難度：** Medium
> **技巧：** `Tree`, `DFS`, `Backtracking`
> **語言：** Go

* 解法一
  - 維護 `sumMap`
    - key 為 source node
    - val 為 path sum
  - DFS + Backtracking
    - PreOrder Tree Traversal (中左右)：`sumMap` 內的 entries 必為同一條 path 上的 nodes
    - Backtracking：左右子樹走訪完畢後，代表此 node 也處理完了，故將此 node 從 `sumMap` 移除
    - 走訪經過一個 node 時，先將同條 path 上的（也就是 `sumMap` 內的）path sum 加上 `node.Val`
  - 此解法有點慢，更優雅的解法見解法二

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func pathSum(root *TreeNode, targetSum int) int {
    var count int
    sumMap := make(map[*TreeNode]int)
    pathSumImpl(root, targetSum, sumMap, &count)
    return count
}

func pathSumImpl(node *TreeNode, targetSum int, sumMap map[*TreeNode]int, count *int) {
    if node == nil {
        return
    }

    for srcNode, pathSum := range sumMap {
        sumMap[srcNode] = pathSum + node.Val
        if pathSum + node.Val == targetSum {
            *count++
        }
    }
    sumMap[node] = node.Val

    if node.Val == targetSum {
        *count++
    }
 
    pathSumImpl(node.Left, targetSum, sumMap, count)
    pathSumImpl(node.Right, targetSum, sumMap, count) 

    delete(sumMap, node)
    for srcNode := range sumMap {
        sumMap[srcNode] -= node.Val
    }
}
```

* 解法二：
  - Two-level recursion
    - 將 tree 中的每一個 node 視為 source node，並進行 PreOrder Tree Traversal（對，就是那麼粗暴）
    - 難度和 Path Sum 差不多...😅 ，但卻比解法一快，而且還更節省記憶體
    - 注意：`localSum == targetSum` 不用提早 return，因為會有 subpaths 重疊，但 path sum 相同的情況

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func pathSum(root *TreeNode, targetSum int) int {
    var count int
    pathSumImpl(root, targetSum, &count)
    return count
}

func pathSumImpl(src *TreeNode, targetSum int, count *int) {
    if src == nil {
        return
    }

    dfs(src, 0, targetSum, count)

    pathSumImpl(src.Left, targetSum, count)
    pathSumImpl(src.Right, targetSum, count)
}

func dfs(node *TreeNode, localSum, targetSum int, count *int) {
    if node == nil {
        return
    }

    localSum += node.Val
    if localSum == targetSum {
        *count++
    }

    dfs(node.Left, localSum, targetSum, count)
    dfs(node.Right, localSum, targetSum, count)
}
```

### Invert Binary Tree

> **題目：** https://leetcode.com/problems/invert-binary-tree/
> **難度：** Easy
> **技巧：** `Tree`, `DFS`
> **語言：** Go

* 可以使用 Preorder DFS 或 Postorder DFS
* 不可使用 Inorder DFS

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func invertTree(root *TreeNode) *TreeNode {
    invertTreeImpl(root) 
    return root
}

func invertTreeImpl(node *TreeNode) {
    if node == nil {
        return
    } 

    node.Left, node.Right = node.Right, node.Left
    invertTreeImpl(node.Left)
    invertTreeImpl(node.Right)
}
```

### Implement Trie (Prefix Tree)

> **題目：** https://leetcode.com/problems/implement-trie-prefix-tree/
> **難度：** Medium
> **技巧：** `Trie`, `Tree`
> **語言：** Go

* 測資是 n 個 strings，每個字串只會包含小寫英文字母
* 實作 Trie 這個資料結構，並提供下列 API
  - `Trie::Insert()`：插入一個 string
  - `Trie::Search()`：搜尋 string (exact match)
  - `Trie::StartsWith()`：搜尋 string (prefix match)
* 每個 trie node 多一個 `isEnd` data member
  - 用途：記錄該 node 是否為一個曾插入過的 string 的最後字元

```go
type Node struct {
    val rune
    children []*Node
    isEnd bool
}

type Trie struct {
    root *Node
}

func (this *Node) addChild(r rune) *Node {
    newChild := Node{val: r, children: make([]*Node, 0)}
    this.children = append(this.children, &newChild)
    return &newChild
}

func (this *Node) getChild(r rune) *Node {
    for _, node := range this.children {
        if node.val == r {
            return node
        }
    }
    return nil
}

func Constructor() Trie {
    return Trie{root: &Node{children: make([]*Node, 0)}}
}

func (this *Trie) Insert(word string)  {
    node := this.root
    
    for _, c := range word {
        if child := node.getChild(c); child != nil {
            node = child
        } else {
            node = node.addChild(c)
        }
    }
    
    node.isEnd = true
}

func (this *Trie) walk(word string) *Node {
    node := this.root
    for _, c := range word {
        if child := node.getChild(c); child != nil {
            node = child
        } else {
            return nil
        }
    }
    
    return node
}

func (this *Trie) Search(word string) bool {
    node := this.walk(word)
    return node != nil && node.isEnd
}

func (this *Trie) StartsWith(prefix string) bool {
    node := this.walk(prefix)
    return node != nil
}


/**
 * Your Trie object will be instantiated and called as such:
 * obj := Constructor();
 * obj.Insert(word);
 * param_2 := obj.Search(word);
 * param_3 := obj.StartsWith(prefix);
 */
```

### Maximum Product of Splitted Binary Tree

> **題目：** https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/
> **難度：** Medium
> **技巧：** `Tree`, `DFS`
> **語言：** Go

從 tree 移除任一個 edge，使其分裂為兩棵 subtrees，請求出兩棵 subtrees 各自加總後，最大的乘積為何

* Binary Tree DFS
  - 將每個 tree node 當成 subtree 的 root node
  - 用 PostOrder traversal 以 bottom up 的方式建 subtree sum map (`dp`)
* 掃一次 subtree sum map
  - 每個 iteration 的 (key, value) 即 (node, node 作為 subtree1 root 的 sum)
  - subtree2 的 sum = 原 tree 的 sum - subtree1 的 sum

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func maxProduct(root *TreeNode) int {
    dp := make(map[*TreeNode]uint64)
    maxProductImpl(dp, root) 

    ret := uint64(0)
    treeSum := dp[root]
    for _, subtreeSum := range dp {
        sum1 := subtreeSum
        sum2 := treeSum - sum1
        ret = max(ret, sum1 * sum2)
    }
    return int(ret % uint64(1000000007))
}

func maxProductImpl(dp map[*TreeNode]uint64, node *TreeNode) {
    if node == nil {
        return
    }

    maxProductImpl(dp, node.Left)
    maxProductImpl(dp, node.Right)
    dp[node] = dp[node.Left] + uint64(node.Val) + dp[node.Right]
}
```

## Graph

### Find if Path Exists in Graph

> **題目：** https://leetcode.com/problems/find-if-path-exists-in-graph/
> **難度：** Easy
> **技巧：** `Graph`, `BFS`, `Union Find`
> **語言：** Go

* 解法一：
  - 建 adjacency map（adjacency matrix 會因為巨大測資而撞到 Out of Memory）
    - key：source node (`int`)
    - val：set of neighbors (`map[int]struct{}`)
  - BFS, 記得不要重複走訪已走訪過的 nodes

```go
func validPath(n int, edges [][]int, source int, destination int) bool {
    adjacencyMap := make(map[int]map[int]struct{})
    for _, edge := range edges {
        src, dst := edge[0], edge[1]

        if _, exist := adjacencyMap[src]; !exist {
            adjacencyMap[src] = make(map[int]struct{})
        }
        adjacencyMap[src][dst] = struct{}{}

        if _, exist := adjacencyMap[dst]; !exist {
            adjacencyMap[dst] = make(map[int]struct{})
        }
        adjacencyMap[dst][src] = struct{}{}
    }

    isVisited := make([]bool, n)
    queue := []int{source}
    for len(queue) != 0 {
        node := queue[0]
        queue = queue[1:]

        isVisited[node] = true
        if node == destination {
            return true
        }

        for neighbor := range adjacencyMap[node] {
            if !isVisited[neighbor] {
                queue = append(queue, neighbor)
            }
        }
    }

    return false
}
```

### Keys and Rooms

> **題目：** https://leetcode.com/problems/keys-and-rooms/
> **難度：** Medium
> **技巧：** `Graph`, `BFS`
> **語言：** Go

給你一個 digraph 的所有 edges（以 adjacency list 的形式），請問它是否不存在 isolated node。

根據題目描述，從 node 0 開始做 BFS，做完後如果 all nodes visited 就 return true。

```go
func canVisitAllRooms(rooms [][]int) bool {
    adjacencyMap := make(map[int]map[int]struct{})
    for room, keys := range rooms {
        if len(keys) == 0 {
            continue
        }
        if _, exist := adjacencyMap[room]; !exist {
            adjacencyMap[room] = make(map[int]struct{})
        }
        for _, key := range keys {
            adjacencyMap[room][key] = struct{}{}
        }
    }

    n := len(rooms)
    isVisited := make([]bool, n)
    queue := []int{0}
    for len(queue) != 0 {
        node := queue[0]
        queue = queue[1:]

        isVisited[node] = true

        for neighbor := range adjacencyMap[node] {
            if !isVisited[neighbor] {
                queue = append(queue, neighbor)
            }
        }
    }

    hasVisitedAllNodes := true
    for _, visited := range isVisited {
        if !visited {
            hasVisitedAllNodes = false
            break
        }
    }
    if hasVisitedAllNodes {
        return true
    }

    return false
}
```

### Is Graph Bipartite?

> **題目：** https://leetcode.com/problems/is-graph-bipartite/
> **難度：** Medium
> **技巧：** `Graph`, `BFS`
> **語言：** Go

給定一個 undirected graph（以 adjacency list 的形式），判斷它是否為[bipartite](https://en.wikipedia.org/wiki/Bipartite_graph)

* Graph BFS
  - 沒走訪過的 node 才需要進 queue
  - 如果某個 neighbor 已經走訪過，它就會有個顏色（藍或紅），檢查一下是否和目前的 node 顏色相同
    - 相同：不是二分圖，立刻返回 false
    - 不同：繼續 BFS
  - 注意：
    - 測資未必是 connected graph，只用 node 0 下去跑 BFS 會漏掉某部分 subgraph

```go
var (
    visited []bool
    colors []bool
)

func isBipartite(graph [][]int) bool {
    visited = make([]bool, len(graph))
    colors = make([]bool, len(graph)) 

    for nodeIdx := range graph {
        if !visited[nodeIdx] && !isBipartiteImpl(graph, nodeIdx) {
            return false
        }
    }
    return true
}

func isBipartiteImpl(graph [][]int, beginNodeIdx int) bool {
    currentColor := true  // true: blue, false: red 
    q := []int{beginNodeIdx}

    for len(q) > 0 {
        size := len(q)   

        for i := 0; i < size; i++ {
            thisNodeIdx := q[0]
            q = q[1:]

            visited[thisNodeIdx] = true
            colors[thisNodeIdx] = currentColor

            for _, neighborIdx := range graph[thisNodeIdx] {
                // Push all the neighbors of thisNode into the queue
                // for the next iteration of BFS.
                if !visited[neighborIdx] {
                    q = append(q, neighborIdx)
                } else if colors[neighborIdx] == currentColor {
                    return false
                }
            }
        }

        // Invert color
        currentColor = !currentColor
    }

    return true
}
```

### Network Delay Time

> **題目：** https://leetcode.com/problems/network-delay-time/
> **難度：** Medium
> **技巧：** `Graph`, `Dijkstra`
> **語言：** Go

給你一個 network graph，裡面有 n 個 nodes。請問從 node `k-1` 開始 broadcast signal 的話，最快要花多久時間所有 nodes 才能全都收到該 signal？

從圖論的角度來解釋，給你：

* 一個 weighted digraph（以 weighted adjacency list）的形式
* 一個 source node `k`

請找出該 graph 中與 k 最遠的距離（i.e. 沿路權重的加總）

1. Dijkstra (https://youtu.be/pVfj6mxhdMw?t=132)
   - 輸入：weighted adjacency matrix, source node
   - 輸出：從 source node 到其他所有 nodes 的 shortest distances
   - 注意：題目給的權重可能會有 0，所以任兩節點間若沒有 edge，在 `graph` 中要以 -1 來表示
   - 輸出的 slice 取 max element 就是答案

```go
// Dijkstra: Single-Source All-Destinations Shortest Path
func dijkstra(graph [][]int, n int, k int) []int {
    visited := make([]bool, n)
    previous := make([]int, n)
    distances := make([]int, n)

    // Set node k (index: k - 1) as the source node.
    for i := 0; i < n; i++ {
        distances[i] = math.MaxInt
    }
    distances[k - 1] = 0

    for sliceContains(visited, false) {
        // Find an unvisited node with the shortest distance from node k.
        i := 0
        minDist := math.MaxInt

        for j := 0; j < n; j++ {
            if !visited[j] && distances[j] <= minDist {
                minDist = distances[j]
                i = j
            }
        }

        for j := 0; j < n; j++ {
            if !visited[j] && graph[i][j] != -1 {
                // If the distance between [i, j] is less than
                // the known distance, update the shortest distance.
                if d := distances[i] + graph[i][j]; d < distances[j] {
                    distances[j] = d
                    previous[i] = i
                }
            }
        }

        visited[i] = true
    }

    fmt.Println(distances)
    return distances
}

func networkDelayTime(times [][]int, n int, k int) int {
    // Build the weighted adjacency matrix of the graph.
    graph := make([][]int, n)

    for i := range graph {
        graph[i] = make([]int, n)
        for j := range graph[i] {
            graph[i][j] = -1
        }
    }

    for _, t := range times {
        src := t[0] - 1
        dst := t[1] - 1
        weight := t[2]

        graph[src][dst] = weight
    }

    if ret := max(dijkstra(graph, n, k)...); ret == math.MaxInt {
        return -1
    } else {
        return ret
    }
}
```

## Dynamic Programming

### Best Time to Buy and Sell Stock

> **題目：** https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/
> **難度：** Easy
> **技巧：** `DP`
> **語言：** C++17

給你一個 vector of ints `prices` 代表某張股票的價錢，第 i 個元素代表它在第 i 天的價錢。

你可以在第 x 天以低價買入股票，在第 y 天將它賣出，其中 `x < y`，求最大的獲利？

* DP
  - 獲利 = 賣出價格 - 買入價格
  - 只要能最大化賣出價格，且最小化買入價格，就能創造出最大獲利
  - `rmax[i]` 代表：若在第 i 天買入，最高的賣出價格可以是多少
  - `lmin[i]` 代表：若在第 i 天賣出，最低的買入價格可以是多少

```cpp
class Solution {
 public:
  int maxProfit(vector<int>& prices) {
    const int n = prices.size();

    // [7, 6, 6, 6, 6, 4]
    vector<int> rmax(n);
    rmax[n - 1] = prices[n - 1];
    for (int i = n - 2; i >= 0; i--) {
      rmax[i] = std::max(rmax[i + 1], prices[i]);
    }

    // [7, 1, 1, 1, 1, 1]
    vector<int> lmin(n);
    lmin[0] = prices[0];
    for (int i = 1; i < n; i++) {
      lmin[i] = std::min(lmin[i - 1], prices[i]);
    }

    vector<int> diff(n);
    for (int i = 0; i < n; i++) {
      diff[i] = rmax[i] - lmin[i];
    }

    return *std::max_element(diff.begin(), diff.end());
  }
};
```

### Best Time to Buy and Sell Stock II

> **題目：** https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/
> **難度：** Medium
> **技巧：** `DP`
> **語言：** C++17

延續第一題：
* 第一題只要求 single transaction 的最大獲利
* 第二題需要求 multiple transactions 的最大獲利
  - 可以當日買、賣
  - 但一次只能持有一張股票

* DP
  - 如果將 `prices` 畫成折線圖，我們會觀察到，將所有斜率 > 0 的線段的 delta y 累加就是答案

```cpp
class Solution {
 public:
  int maxProfit(vector<int>& prices) {
    const int n = prices.size();
    int src = 0;
    int ret = 0;

    for (int i = 1; i < n; i++) {
      if (prices[i] < prices[i - 1]) {
        ret += prices[i - 1] - prices[src];
        src = i;
      }
    }
    return ret + (prices[n - 1] - prices[src]);
  }
};
```

### Maximum Subarray

> **題目：** https://leetcode.com/problems/maximum-subarray/
> **難度：** Medium
> **技巧：** `DP` `Kadane`
> **語言：** Go

* Kadane's Algorithm [[ref](https://medium.com/@rsinghal757/kadanes-algorithm-dynamic-programming-how-and-why-does-it-work-3fd8849ed73d)]
  - 維護一個變數 `localMax`，並掃一次 `nums`，每輪掃到的數字叫 `num`
    - `localMax` 代表截至為止（不含 `num`）的 maximum subarray 的和
    - 看看 `localMax` 加上 `num` 是否會更大

```go
func maxSubArray(nums []int) int {
    globalMax := math.MinInt
    localMax := 0
    for _, num := range nums {
        localMax = max(num, num + localMax)
        globalMax = max(globalMax, localMax)
    }

    return globalMax
}
```

### Maximum Product Subarray

> **題目：** https://leetcode.com/problems/maximum-product-subarray/
> **難度：** Medium
> **技巧：** `DP` `Kadane`
> **語言：** Go

* 基於 Kadane's Algorithm
  - `localMax`：因為是乘法，所以一開始得初始化為 1 而不是 0，否則之後再怎麼乘都是 0
  - `localMin`：因為乘法可能負負得正，進而產生一個更大的正數，所以還要額外維護此變數
  - 掃一次 `nums`，每輪掃到的數字叫 `num`
    - 若 `num` 為正數，則 `num` 乘以正的 `localMax` 有機會產生一個更大的正數
    - 若 `num` 為負數，則 `num` 乘以負的 `localMin` 有機會產生一個更大的正數

```go
func maxProduct(nums []int) int {
    globalMax := math.MinInt
    localMax, localMin := 1, 1
    for _, num := range nums {
        prod1 := num * localMax
        prod2 := num * localMin
        localMax = max(num, prod1, prod2)
        localMin = min(num, prod1, prod2)
        globalMax = max(globalMax, localMax)
    }

    return globalMax
}
```

### House Robber

> **題目：** https://leetcode.com/problems/house-robber/
> **難度：** Medium
> **技巧：** `DP`
> **語言：** Go

* DP
  - `dp` 是一個一維的 slice
    - `dp[i]` 代表從 `nums[0]` 搶到 `nums[i]` 為止，所能獲得的最大金額
      - `dp[0]` = 搶到 `nums[0]` 為止最多能搶多少，這邊只有 `nums[0]` 一間房屋能搶
      - `dp[1]` = 搶到 `nums[1]` 為止最多能搶多少，這邊選 `nums[0]` 與 `nums[1]` 價值較高者
    - 要搶這一棟，就不能搶它前一棟
      - max(前一棟可以搶到的最大金額, 前前一棟可以搶到的最大金額 + 現在這棟)

```go
func rob(nums []int) int {
    if len(nums) == 1 {
        return nums[0]
    }
    if len(nums) == 2 {
        return max(nums[0], nums[1])
    }

    dp := make([]int, len(nums))
    dp[0] = nums[0]
    dp[1] = max(nums[0], nums[1])
    for i := 2; i < len(nums); i++ {
        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])
    }

    return dp[len(nums) - 1]
}
```

### Unique Paths

> **題目：** https://leetcode.com/problems/unique-paths/
> **難度：** Medium
> **技巧：** `DP`
> **語言：** Go

* DP
  - `dp` 是一個二維 m x n slice (m rows, n cols)
    - 每一格代表：從左上角走到該點的總方法數
    - 第一個 row 的所有格子填入 0
    - 第一個 col 的所有格子填入 0
  - 每次移動只能往右、往下
    - 也就是說，抵達每個格子的方法數 = 左邊來的方法數 + 上面來的方法數

```go
func uniquePaths(m int, n int) int {
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }
    
    for i := 0; i < m; i++ {
        dp[i][0] = 1
    }
    for i := 0; i < n; i++ {
        dp[0][i] = 1
    }
    
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        }
    }
    
    return dp[m - 1][n - 1]
}
```

### Unique Paths II

> **題目：** https://leetcode.com/problems/unique-paths-ii/
> **難度：** Medium
> **技巧：** `DP`
> **語言：** Go

* DP
  - 解法和 Unique Path 87% 像，初始化第一個 row 與第一個 col 時記得考慮障礙物
    - 如果掃到一半遇到障礙物，後面的格子肯定都無法抵達
  - 如果某個格子有障礙物，那麼抵達該點的方法數必為 0

```go
func uniquePathsWithObstacles(obstacleGrid [][]int) int {
    m := len(obstacleGrid)
    n := len(obstacleGrid[0])
    
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }
    
    for i := 0; i < m; i++ {
        if obstacleGrid[i][0] == 1 {
            break
        }
        dp[i][0] = 1
    }
    
    for i := 0; i < n; i++ {
        if obstacleGrid[0][i] == 1 {
            break
        }
        dp[0][i] = 1
    }
    
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            if obstacleGrid[i][j] == 0 {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
            }
        }
    }
    
    return dp[m - 1][n - 1]
}
```

### Minimum Path Sum

> **題目：** https://leetcode.com/problems/minimum-path-sum/
> **難度：** Medium
> **技巧：** `DP`
> **語言：** Go

* DP
  - 解法和 Unique Path 87% 像，`dp` 內每格存的是到達該處的 minimum path sum

```go
func minPathSum(grid [][]int) int {
    m := len(grid)
    n := len(grid[0])

    dp := make([][]int, m)
    for i := 0; i < m; i++ {
        dp[i] = make([]int, n)
    }

    dp[0][0] = grid[0][0]
    for i := 1; i < m; i++ {
        dp[i][0] = dp[i - 1][0] + grid[i][0]
    }
    for i := 1; i < n; i++ {
        dp[0][i] = dp[0][i - 1] + grid[0][i]
    }

    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = min(dp[i][j - 1] + grid[i][j], dp[i - 1][j] + grid[i][j])
        }
    }

    return dp[m - 1][n - 1]
}
```

### Longest Common Subsequence

> **題目：** https://leetcode.com/problems/longest-common-subsequence/
> **難度：** Medium
> **技巧：** `DP`
> **語言：** Go

二維 DP：若 char 相同左上角 + 1, 否則左邊上面取 max, 最後答案在右下

https://www.youtube.com/watch?v=NnD96abizww

```go
func longestCommonSubsequence(text1 string, text2 string) int {
    m := 1 + len(text2)
    n := 1 + len(text1)
  
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }

    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            if text2[i - 1] == text1[j - 1] {
                dp[i][j] = dp[i - 1][j - 1] + 1
            } else {
                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])
            }
        }
    }

    return dp[m - 1][n - 1]
}
```

### Longest Increasing Subsequence

> **題目：** https://leetcode.com/problems/longest-increasing-subsequence/
> **難度：** Medium
> **技巧：** `DP`
> **語言：** Go

一維 DP：Bottom-up，`dp` slice 中第 i 個 element，代表 `nums` 中第 i 個 element 結尾的 LIS 長度。

https://www.youtube.com/watch?v=7DKFpWnaxLI

```go
func lengthOfLIS(nums []int) int {
    n := len(nums)
    dp := make([]int, n)

    for i := range dp {
        dp[i] = 1
    }

    for i := 1; i < n; i++ {
        for j := 0; j < i; j++ {
            if nums[j] < nums[i] {
                dp[i] = max(dp[i], dp[j] + 1)
            }
        }
    }

    return max(dp...)
}
```
### Product of Array Except Self

> **題目：** https://leetcode.com/problems/product-of-array-except-self/
> **難度：** Medium
> **技巧：** `DP`
> **語言：** Go

給你一個 slice，例如：nums = [1,2,3,4]，請回傳 [24,12,8,6]。

1. Bruteforce
   - 選定第 i 個元素，計算其 product of array except self
     - 從頭到尾掃一次，遇到自己就跳過
   - O(N^2)
2. 一維 DP
   - 準備兩個 slice
     - `l`：自己以左（不含自己）所有元素的積，如：[1, 1, 2, 6]，從左到右建
     - `r`：自己以右（不含自己）所有元素的積，如：[24, 12, 4, 1]，從右到左建
   - 將 `l` 與 `r` 相同 index 的元素乘起來就是答案
   - O(N)

```go
func productExceptSelf(nums []int) []int {
    size := len(nums)

    l := make([]int, size)
    r := make([]int, size)

    l[0] = 1
    r[size - 1] = 1

    // [1, 1, 2, 6]
    for i := 1; i < size; i++ {
        l[i] = l[i - 1] * nums[i - 1]
    }

    // [24, 12, 4, 1]
    for i := size - 2; i >= 0; i-- {
        r[i] = r[i + 1] * nums[i + 1]
    }

    for i := range l {
        l[i] *= r[i]
    }

    return l
}
```

## Simulation

### Spiral Matrix II

> **題目：** https://leetcode.com/problems/spiral-matrix-ii/
> **難度：** Medium
> **語言：** Go

* 規律
  - 1x1：(右1)
  - 2x2：(右1) (下1 左1)
  - 3x3：(右2) (下2 左2) (上1 右1)
  - 4x4：(右3) (下3 左3) (上2 右2) (下1 左1)
  - 5x5：(右4) (下4 左4) (上3 右3) (下2 左2) (上1 右1)
  - 6x6：...

```go
func generateMatrix(n int) [][]int {
    matrix := make([][]int, n)
    for i := range matrix {
        matrix[i] = make([]int, n)
    }

    row, col := 0, 0
    for i := 1; i <= n; i++ {
        matrix[row][col] = i
        col++
    }
    col--

    i := n + 1
    n2 := int(math.Pow(float64(n), float64(2)))
    dist := n - 1
    for i <= n2 {
        // Down
        for j := 0; j < dist && i <= n2; j, i = j+1, i+1 {
            row++
            matrix[row][col] = i
        }
        // Left
        for j := 0; j < dist && i <= n2; j, i = j+1, i+1 {
            col--
            matrix[row][col] = i
        }

        dist--

        // Up
        for j := 0; j < dist && i <= n2; j, i = j+1, i+1 {
            row--
            matrix[row][col] = i
        }
        // Right
        for j := 0; j < dist && i <= n2; j, i = j+1, i+1 {
            col++
            matrix[row][col] = i
        }

        dist--
    }

    return matrix
}
```

  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2023-04-01 10:37:30" itemprop="dateModified" datetime="2023-04-01T10:37:30+08:00">2023-04-01</time>
  </span>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>Post author:  </strong>aesophor <i class="ic i-at"><em>@</em></i>日新又新
  </li>
  <li class="link">
    <strong>Post link: </strong>
    <a href="https://aesophor.github.io/leetcode/index.html" title="LeetCode 刷題紀錄">https://aesophor.github.io/leetcode/index.html</a>
  </li>
  <li class="license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
      </div>
      <div class="related panel pjax" data-title="Related">
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="aesophor"
      data-src="/images/avatar.png">
  <p class="name" itemprop="name">aesophor</p>
  <div class="description" itemprop="description">eku</div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">2</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">2</span>
        <span class="name">categories</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">3</span>
        <span class="name">tags</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Flc29waG9y" title="https:&#x2F;&#x2F;github.com&#x2F;aesophor"><i class="ic i-github"></i></span>
      <span class="exturl item instagram" data-url="aHR0cHM6Ly93d3cuaW5zdGFncmFtLmNvbS9hZXNvcGhvci8=" title="https:&#x2F;&#x2F;www.instagram.com&#x2F;aesophor&#x2F;"><i class="ic i-instagram"></i></span>
      <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9hZXNvcGhvcg==" title="https:&#x2F;&#x2F;twitter.com&#x2F;aesophor"><i class="ic i-twitter"></i></span>
      <span class="exturl item linkedin" data-url="aHR0cHM6Ly93d3cubGlua2VkaW4uY29tL2luL2Flc29waG9yLw==" title="https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;aesophor&#x2F;"><i class="ic i-address-card"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>Home</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-user"></i>About</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/about/en-us" rel="section"><i class="ic i-address-card"></i>English</a>
  </li>

        
  <li class="item">
    <a href="/about/zh-tw" rel="section"><i class="ic i-address-card"></i>中文</a>
  </li>

  </ul>
        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/leetcode" rel="section"><i class="ic i-magic"></i>LeetCode</a>
  </li>

    
  <li class="item">
    <a href="/leetcode/grind75" rel="section"><i class="ic i-magic"></i>Grind75</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>Random Posts</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Linux/" title="In Linux">Linux</a>
</div>

    <span><a href="/2020/07/20/Arch-Linux-on-MacBook-Pro-11-2-with-Custom-NVMe-M-2-SSD/" title="Arch Linux on MacBook Pro 11,2 with Custom NVMe M.2 SSD">Arch Linux on MacBook Pro 11,2 with Custom NVMe M.2 SSD</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/CTF/" title="In CTF">CTF</a>
</div>

    <span><a href="/2022/08/27/pwnable-tw-secret-garden/" title="[pwnable.tw] Secret Garden (350 pts)">[pwnable.tw] Secret Garden (350 pts)</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>Recent Comments</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2020 – 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">aesophor @ aesophor's Blog</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: 'leetcode/',
    favicon: {
      show: "（●´3｀●）Goooood",
      hide: "(´Д｀)Booooom"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,fancybox: true,
    copyright: 'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
