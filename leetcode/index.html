



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="æ—¥æ–°åˆæ–°" href="https://aesophor.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="æ—¥æ–°åˆæ–°" href="https://aesophor.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="æ—¥æ–°åˆæ–°" href="https://aesophor.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  

<link rel="canonical" href="https://aesophor.github.io/leetcode/">



  <title>LeetCode åˆ·é¡Œç´€éŒ„ |
aesophor's Blog</title>
<meta name="generator" content="Hexo 5.4.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">LeetCode åˆ·é¡Œç´€éŒ„
  </h1>

          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">aesophor's Blog</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
          <img src="https://images.unsplash.com/photo-1533441325263-74682c42d779?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80">
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="page wrap">
    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="en">
  <link itemprop="mainEntityOfPage" href="https://aesophor.github.io/leetcode/index.html">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.png">
    <meta itemprop="name" content="aesophor">
    <meta itemprop="description" content="åŠªåŠ›ä¸æœƒèƒŒå›äººï¼Œå®ƒèµ°ä¸å¿«ï¼Œä½†æ—©æ™šæœƒè·Ÿä¸Š, eku">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="æ—¥æ–°åˆæ–°">
  </span>

  <div class="body md" itemprop="articleBody">
    

    
# LeetCode åˆ·é¡Œè¨˜éŒ„

## Misc

### Add Two Numbers

> **é¡Œç›®ï¼š** https://leetcode.com/problems/add-two-numbers/
> **é›£åº¦ï¼š** Medium
> **èªè¨€ï¼š** Go

çµ¦ä½ å…©æ¢ linked listï¼Œvalue ç‚º 123 åœ¨ input æ˜¯ 3 â†’ 2 â†’ 1 â†’ nilï¼Œç”¨ä¸€æ¨£çš„ linked list å›å‚³å…©æ•¸ä¹‹å’Œã€‚

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    var head *ListNode
    var curr *ListNode
    carry := false

    for l1 != nil || l2 != nil || carry {
        val := 0
        if carry {
            val += 1
        }
        carry = false
    
        if l1 != nil {
            val += l1.Val
            l1 = l1.Next
        }
    
        if l2 != nil {
            val += l2.Val
            l2 = l2.Next
        }

        if val > 9 {
            carry = true
            val -= 10
        }

        var newNode *ListNode = &ListNode{val, nil}
        if curr == nil {
            head = newNode
        } else {
            curr.Next = newNode
        }
        curr = newNode
    }

    if head == nil {
        head = &ListNode{0, nil}
    }

    return head
}
```

### K Closest Points to Origin

> **é¡Œç›®ï¼š** https://leetcode.com/problems/k-closest-points-to-origin/
> **é›£åº¦ï¼š** Medium
> **æŠ€å·§ï¼š** `Sort`
> **èªè¨€ï¼š** Go

å° points æŒ‰ç…§æ­å¼è·é›¢åšå‡å†ªæ’åºå¾Œï¼Œå‰ k å€‹é»å°±æ˜¯ç­”æ¡ˆã€‚

```go
func kClosest(points [][]int, k int) [][]int {
    sort.SliceStable(points, func(i, j int) bool {
        p1 := points[i]
        p2 := points[j]
        dist1 := math.Hypot(float64(p1[0]), float64(p1[1]))
        dist2 := math.Hypot(float64(p2[0]), float64(p2[1]))
        return dist1 <= dist2
    })
    return points[:k]
}
```

### Longest Common Prefix

> **é¡Œç›®ï¼š** https://leetcode.com/problems/longest-common-prefix/
> **é›£åº¦ï¼š** Easy
> **èªè¨€ï¼š** Go

```go
func longestCommonPrefix(strs []string) string {
    numStrs := len(strs)
    minLen := math.MaxInt32
    i := 0

    for _, str := range strs {
        minLen = min(minLen, len(str))
    }

    for ; i < minLen; i++ {
        for j := 1; j < numStrs; j++ {
            if strs[0][i] != strs[j][i] {
                return strs[0][:i]
            }
        }
    }

    return strs[0][:i]
}
```

### Longest Palindromic Substring

> **é¡Œç›®ï¼š** https://leetcode.com/problems/longest-palindromic-substring/
> **é›£åº¦ï¼š** Medium
> **æŠ€å·§ï¼š** `Two Pointers`
> **èªè¨€ï¼š** Go

çµ¦ä½ ä¸€å€‹å­—ä¸² `str`ï¼Œä¾‹å¦‚ï¼š"babad" çš„ç­”æ¡ˆæ˜¯ "aba"ï¼Œè€Œ "cbbd" çš„ç­”æ¡ˆæ˜¯ "bb"ã€‚

* Two Pointers
  - è¿´æ–‡çš„é•·åº¦å¯èƒ½æ˜¯å¥‡æ•¸æˆ–å¶æ•¸ï¼Œå…©ç¨®æƒ…æ³éƒ½è¦æª¢æŸ¥ã€‚
  - æª¢æŸ¥æ–¹å¼ï¼šexpand around center
    - å¥‡æ•¸é•·åº¦è¿´æ–‡ï¼šé¸ä¸€å€‹ center, `c1`, å¾€å·¦å³ expand
    - å¶æ•¸é•·åº¦è¿´æ–‡ï¼šé¸å…©å€‹ center, `c1`, `c2`, å¾€å·¦å³ expand
  - ç‰¹åˆ¥æ³¨æ„
    - å¥‡æ•¸æƒ…æ³ï¼šä¾‹å¦‚ "abc" ä»¥ b ç‚ºä¸­å¿ƒï¼Œæœƒç¢°åˆ° `c1 == c2`
      - è¿´æ–‡é•·åº¦ç‚º 1 ("b")
      - `expand()` å›å‚³ (c1+1, c2-1)ï¼Œè¨ˆç®—é•·åº¦ï¼š(c2-1) - (c1+1) + 1 = 1
    - å¶æ•¸æƒ…æ³ï¼šä¾‹å¦‚ "abcd ä»¥ bc ç‚ºä¸­å¿ƒï¼Œæœƒç¢°åˆ° `c1 == c2 - 1`
      - è¿´æ–‡é•·åº¦ç‚º 0 ("")
      - `expand()` å›å‚³ (c1+1, c2-1)ï¼Œè¨ˆç®—é•·åº¦ï¼š(c2-1) - (c1+1) + 1 = (c2-1) - c2 + 1 = 0
    - å·§å¦™åœ°ç®—å‡ºäº†æ­£ç¢ºçš„è¿´æ–‡é•·åº¦

```go
func longestPalindrome(str string) string {
    strLen := len(str)
    maxLen := 0
    ret := ""

    for i := 0; i < strLen; i++ {
        begin1, end1 := expand(str, strLen, i, i)
        localLen := end1 - begin1 + 1

        if localLen > maxLen {
            ret = str[begin1:end1 + 1]
            maxLen = localLen
        }
    
        begin2, end2 := expand(str, strLen, i, i + 1)
        localLen = end2 - begin2 + 1
    
        if localLen > maxLen {
            ret = str[begin2:end2 + 1]
            maxLen = localLen
        }
    }

    return ret
}

// If the length of palindrome is even,
// e.g. abba, then there will be two centers: bb
func expand(str string, strLen int, c1 int, c2 int) (int, int) {
    for c1 >= 0 && c2 < strLen {
        if str[c1] != str[c2] {
            break
        }
        c1--
        c2++
    }

    return c1 + 1, c2 - 1
}
```

### Merge Intervals

> **é¡Œç›®ï¼š** https://leetcode.com/problems/merge-intervals/
> **é›£åº¦ï¼š** Medium
> **æŠ€å·§ï¼š** `Sort`
> **èªè¨€ï¼š** Go

* å° `intervals` æ ¹æ“šå·¦ç•Œé€²è¡Œ ascending æ’åº
* æƒä¸€æ¬¡ `intervals`
  - èˆ‡ last merged interval ç„¡ overlapï¼šå°±ç›´æ¥ append
  - èˆ‡ last merged interval æœ‰ overlapï¼šæ›´æ–°å³ç•Œï¼Œçœ‹æ˜¯åŸæœ¬çš„å¤§ï¼Œé‚„æ˜¯æ–°çš„å¤§

```go
func merge(intervals [][]int) [][]int {
    sort.SliceStable(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })

    ret := make([][]int, 0)
    for _, interval := range intervals {
        if len(ret) == 0 || last(ret)[1] < interval[0] {
            ret = append(ret, interval)
        } else {
            last(ret)[1] = max(last(ret)[1], interval[1])
        }
    }
    return ret
}

func last(s [][]int) []int {
    return s[len(s) - 1]
}
```

### Insert Interval

> **é¡Œç›®ï¼š** https://leetcode.com/problems/insert-interval/
> **é›£åº¦ï¼š** Medium
> **èªè¨€ï¼š** Go

1. æš´åŠ›è§£ï¼š
   - å°‡ `newInterval` append åˆ° `intervals` ä¸¦æ ¹æ“šå·¦ç•Œé€²è¡Œ ascending sort
   - å°‡æ­¤å•é¡Œ reduce æˆ Merge Intervals
2. æ¯”è¼ƒæœ‰æ•ˆç‡çš„è§£æ³•ï¼š
   - å¾é ­æƒæ `intervals`
     - è‹¥èˆ‡ `newInterval` ç„¡ overlapï¼Œç›´æ¥ append åˆ° `ret`
     - è‹¥èˆ‡ `newInterval` æœ‰ overlapï¼Œç¢ºèªç›®å‰æƒæåˆ°çš„ interval èˆ‡ `newInterval` èåˆå¾Œçš„å·¦å³ç•Œ
   - å°‡ `newInterval` append åˆ° `ret`
   - å¾å‰›å‰›æƒææš«åœçš„åœ°æ–¹ç¹¼çºŒï¼Œå¾€å¾Œæƒå®Œ `intervals` å‰©é¤˜çš„éƒ¨åˆ†
     - å› ç‚ºä¸ç¢ºå®š `newInterval` æ‰€æ©«è·¨çš„ç¯„åœå¤šå¤§ï¼Œæ•…æ­¤éƒ¨åˆ†çš„é‚è¼¯åŒ Merge Intervals çš„è§£æ³•

```go
func insert(intervals [][]int, newInterval []int) [][]int {
    var i int
    var ret [][]int

    for i = 0; i < len(intervals); i++ {
        interval := intervals[i]
        if newInterval[0] <= interval[1] {
            newInterval = []int{min(interval[0], newInterval[0]), newInterval[1]}
            break
        }
        ret = append(ret, interval)
    }

    ret = append(ret, newInterval)

    for ; i < len(intervals); i++ {
        interval := intervals[i]
        if len(ret) == 0 || last(ret)[1] < interval[0] {
            ret = append(ret, interval)
        } else {
            last(ret)[1] = max(last(ret)[1], interval[1])
        }
    }
    
    return ret
}

func last(s [][]int) []int {
    return s[len(s) - 1]
}
```

### Merge Two Sorted Lists

> **é¡Œç›®ï¼š** https://leetcode.com/problems/merge-two-sorted-lists/
> **é›£åº¦ï¼š** Easy
> **æŠ€å·§ï¼š** `Linked Lists`
> **èªè¨€ï¼š** Go

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
    var head *ListNode
    var curr *ListNode
    
    for list1 != nil || list2 != nil {
        newNode := &ListNode{}
        
        if list1 != nil && list2 == nil {
            newNode.Val = list1.Val
            list1 = list1.Next
        } else if list1 == nil && list2 != nil {
            newNode.Val = list2.Val
            list2 = list2.Next
        } else {
            if list1.Val <= list2.Val {
                newNode.Val = list1.Val
                list1 = list1.Next
            } else {
                newNode.Val = list2.Val
                list2 = list2.Next
            }
        }

        if head == nil {
            head = newNode
        } else {
            curr.Next = newNode
        }
        
        curr = newNode
    }
    return head
}
```

### Reverse Integer

> **é¡Œç›®ï¼š** https://leetcode.com/problems/reverse-integer/
> **é›£åº¦ï¼š** Medium
> **èªè¨€ï¼š** Go

åœ¨ `ret *= 10` å‰ï¼Œè¨˜å¾—æª¢æŸ¥æ­¤æ“ä½œæ˜¯å¦æœƒé€ æˆ `ret` signed integer overflowã€‚

```go
func reverse(x int) int {
    ret := 0

    for x != 0 {
        if ret > 0 && ret > math.MaxInt32 / 10 {
            return 0
        }
        if ret < 0 && ret < math.MinInt32 / 10 {
            return 0
        }

        ret *= 10   
        ret += x % 10
        x /= 10
    }

    return ret
}
```

### Rotate Image

> **é¡Œç›®ï¼š** https://leetcode.com/problems/rotate-image/
> **é›£åº¦ï¼š** Medium
> **æŠ€å·§ï¼š** `Matrix`
> **èªè¨€ï¼š** Go

Matrix rotation = Transpose + æ°´å¹³ç¿»è½‰

```go
func rotate(matrix [][]int)  {
    transpose(matrix)
    flipHorizontally(matrix)
}

// Def: transpose = swap the column and row of each element in matrix.
func transpose(matrix [][]int) {
    for i := range matrix {
        for j := 0; j < i; j++ {
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        }
    }
}

func flipHorizontally(matrix [][]int) {
    for _, row := range matrix {
        reverse(row)
    }
}

func reverse(nums []int) {
    for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {
        nums[i], nums[j] = nums[j], nums[i]
    } 
}
```

### Rotate List

> **é¡Œç›®ï¼š** https://leetcode.com/problems/rotate-list/
> **é›£åº¦ï¼š** Medium
> **èªè¨€ï¼š** Go

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func rotateRight(head *ListNode, k int) *ListNode {
    if head == nil {
        return nil
    }
    if k == 0 {
        return head
    }

    oldHead := head
    size, oldTail := traverse(head)
    
    k %= size
    if k == 0 {
        return head
    }
    
    newHeadPos := size - k
    newTailPos := newHeadPos - 1

    newHead := oldHead
    for i := 0; i < newHeadPos; i++ {
        newHead = newHead.Next
    }
    
    newTail := oldHead
    for i := 0; i < newTailPos; i++ {
        newTail = newTail.Next
    }
    newTail.Next = nil
    oldTail.Next = oldHead
    
    return newHead
}

func traverse(node *ListNode) (int, *ListNode) {
    size := 0
    prev := node
    for node != nil {
        prev = node
        node = node.Next
        size++
    }
    return size, prev
}
```

### Search a 2D Matrix

> **é¡Œç›®ï¼š** https://leetcode.com/problems/search-a-2d-matrix/
> **é›£åº¦ï¼š** Medium
> **èªè¨€ï¼š** Go

```go
func searchMatrix(matrix [][]int, target int) bool {
    m := len(matrix)
    n := len(matrix[0])

    i := m - 1
    j := n - 1

    for i >= 0 && j >= 0 {
        if matrix[i][j] == target {
            return true
        } else if matrix[i][0] > target {
            i--
        } else if matrix[i][j] > target {
            j--
        } else {
            break
        }
    }

    return false
}
```

### Set Matrix Zeroes

> **é¡Œç›®ï¼š** https://leetcode.com/problems/set-matrix-zeroes/
> **é›£åº¦ï¼š** Medium
> **æŠ€å·§ï¼š** `Hash Set`
> **èªè¨€ï¼š** Go

```go
func setZeroes(matrix [][]int) {
    m := len(matrix)
    n := len(matrix[0])

    rowsToClear := make(map[int]struct{})
    colsToClear := make(map[int]struct{})

    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if matrix[i][j] == 0 {
                rowsToClear[i] = struct{}{}
                colsToClear[j] = struct{}{}
            }
        }
    }

    for row := range rowsToClear {
        matrix[row] = make([]int, n)
    }
    for col := range colsToClear {
        for i := 0; i < m; i++ {
            matrix[i][col] = 0
        }
    }
}
```

### Simplify Path

> **é¡Œç›®ï¼š** https://leetcode.com/problems/simplify-path/
> **é›£åº¦ï¼š** Medium
> **èªè¨€ï¼š** Go

```go
func simplifyPath(path string) string {
    var components []string
    for _, c := range strings.Split(path, "/") {
        switch c {
        case ".":
        case "..":
            if len(components) > 0 {
                components = components[:len(components) - 1]
            }
        default:
            if len(c) > 0 {
                components = append(components, c)
            }
        }
    }

    return "/" + strings.Join(components, "/")
}
```

### Subsets

> **é¡Œç›®ï¼š** https://leetcode.com/problems/subsets/
> **é›£åº¦ï¼š** Medium
> **æŠ€å·§ï¼š** `Recursion`, `Bit Representation`
> **èªè¨€ï¼š** Go

è§£æ³•ä¸€ï¼šéè¿´
* è¦ç”¢ç”Ÿ power setï¼Œå°±æ˜¯å°æ–¼ `nums` è£¡é¢çš„æ•¸å­—ã€å–ã€‘æˆ–ã€ä¸å–ã€‘
* ä½¿ç”¨ golang æ™‚å¿…é ˆç‰¹åˆ¥æ³¨æ„ï¼šappend æ•¸å­—åˆ° slice æ™‚ï¼Œè¨˜å¾—è¦ deep copy sliceï¼

```go
func subsets(nums []int) [][]int {
    var ret [][]int
    subsetsImpl(nums, 0, []int{}, &ret)
    return ret
}

func subsetsImpl(nums []int, i int, current []int, ret *[][]int) {
    if i == len(nums) {
        *ret = append(*ret, current)
        return
    }

    subsetsImpl(nums, i + 1, current, ret)

    newCurrent := make([]int, len(current))
    copy(newCurrent, current)
    newCurrent = append(newCurrent, nums[i])

    subsetsImpl(nums, i + 1, newCurrent, ret)
}
```

è§£æ³•äºŒï¼šç”¨ bit representation å»º truth table
* å°‡ `2^n` åˆ° `2^(n+1)` é€™æ®µç¯„åœå…§çš„æ•¸å­—è½‰æˆ binary representation (string)
  - e.g., n = 3, å¾—ï¼š1000, 1001, 1010, 1011, 1100, 1101, 1110, 1111
  - ä¸Šè¿°çš„ binary string å»æ‰ç¬¬ä¸€å€‹ rune å°±æ˜¯ 000, 001, 010, 011, ...
* æœ€å¾Œç”¨ truth table å³å¯è¼•é¬†ç”Ÿæˆ power set

```go
func subsets(nums []int) [][]int {
    var ret [][]int
    n := len(nums)

    for i := math.Pow(2, float64(n)); i < math.Pow(2, float64(n + 1)); i++ {
        bits := strconv.FormatInt(int64(i), 2)[1:]
        
        var subset []int
        for j, bit := range bits {
            if bit == '1' {
                subset = append(subset, nums[j])
            }
        }
        ret = append(ret, subset)
    }

    return ret
}
```

### Swap Nodes in Pairs

> **é¡Œç›®ï¼š** https://leetcode.com/problems/swap-nodes-in-pairs/
> **é›£åº¦ï¼š** Medium
> **æŠ€å·§ï¼š** `Recursion`
> **èªè¨€ï¼š** Go

* `swapPairsImpl(node1, node2)`
  - è¨­å®š `node1.Next`
    - è‹¥æ²’æœ‰ä¸‹ä¸€çµ„ (i.e. `node2.Next == nil`)ï¼Œè¨­ `node1.Next` ç‚º nil
    - è‹¥é‚„æœ‰ä¸‹ä¸€çµ„ (i.e. `node2.Next != nil`)ï¼Œç”¨ä¸‹ä¸€çµ„ nodes å†å‘¼å«ä¸€æ¬¡æ­¤å‡½æ•¸
  - è¨­å®š `node2.Next`
    - å¿…å®šè¦æ›´æ–°ç‚º `node1`
  - å›å‚³æœ¬çµ„ nodes åœ¨äº¤æ›å¾Œçš„ç¬¬ä¸€å€‹ node
    - è‹¥ `node2 == nil`ï¼Œäº¤æ›å¾Œçš„ç¬¬ä¸€å€‹ node å°±æ˜¯ node1
    - è‹¥ `node1 != nil`ï¼Œäº¤æ›å¾Œçš„ç¬¬ä¸€å€‹ node å°±æ˜¯ node2

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func swapPairs(head *ListNode) *ListNode {
    if head == nil {
        return nil
    }
    return swapPairsImpl(head, head.Next)
}

func swapPairsImpl(node1, node2 *ListNode) *ListNode {
    if node2 == nil {
        return node1
    }

    if node2.Next == nil {
        node1.Next = nil
    } else {
        node1.Next = swapPairsImpl(node2.Next, node2.Next.Next)
    }
    node2.Next = node1

    return node2
}
```

### Two Sum

> **é¡Œç›®ï¼š** https://leetcode.com/problems/two-sum/
> **é›£åº¦ï¼š** Easy
> **èªè¨€ï¼š** Go

* å»ºä¸€å€‹ complement map
  - keyï¼šnum
  - valueï¼šindex
* æƒç„ numsï¼Œå°æ–¼æ¯å€‹ num âˆˆ nums
  - å°æ–¼æ¯å€‹ numï¼Œç”¨ num å»æŸ¥è©¢ complement map
    - è‹¥å­˜åœ¨ï¼Œ{value, ç›®å‰çš„ index} å°±æ˜¯ç­”æ¡ˆäº†
    - ä¸å­˜åœ¨ï¼Œå°‡ {target - num, ç›®å‰çš„ index} å­˜é€²å»

```go
func twoSum(nums []int, target int) []int {
    complementIdx := make(map[int]int)

    for i, num := range nums {
        if val, exists := complementIdx[num]; exists {
            return []int{val, i}
        }
        complementIdx[target - num] = i
    }

    return []int{-1, -1}
}
```

### Valid Parentheses

> **é¡Œç›®ï¼š** https://leetcode.com/problems/https://leetcode.com/problems/valid-parentheses/
> **é›£åº¦ï¼š** Easy
> **æŠ€å·§ï¼š** `Stack`
> **èªè¨€ï¼š** Go

ä½¿ç”¨ [GoDS](https://github.com/emirpasic/gods) (Go Data Structures) library ä¸­çš„ arraystack

```go
import (
    "github.com/emirpasic/gods/stacks/arraystack"
)

func isValid(s string) bool {
    stack := arraystack.New()

    for _, c := range s {
        switch c {
        case '(', '[', '{':
            stack.Push(getClosingParen(c))
        case ')', ']', '}':
            if val, ok := stack.Pop(); !ok || val != c {
                return false
            }
        default:
            panic(fmt.Sprintf("unsupported rune: %c", c))
        }
    }
    
    return stack.Empty()
}

func getClosingParen(r rune) rune {
    switch r {
    case '(':
        return ')'
    case '[':
        return ']'
    case '{':
        return '}'
    default:
        panic("r must only be a rune in ['(', '[', '{']")
    }
}
```

## Two Pointers

### Remove Element

> **é¡Œç›®ï¼š** https://leetcode.com/problems/remove-element/
> **é›£åº¦ï¼š** Easy
> **æŠ€å·§ï¼š** `Two Pointers`
> **èªè¨€ï¼š** Go

çµ¦ä½ ä¸€å€‹ int slice `nums` èˆ‡ä¸€å€‹å€¼ `val`ï¼Œè«‹å°‡ `nums` ä¸­æ‰€æœ‰ `val` in-place ç§»é™¤ã€‚

* å¿«æ…¢æŒ‡æ¨™
  - `fast`ï¼šæ¯æ¬¡éƒ½éå¢
  - `slow`ï¼šåªåœ¨ `nums[fast] != val` æ™‚æ‰éå¢

```go
func removeElement(nums []int, val int) int {
    slow, fast := 0, 0
  
    for fast < len(nums) {
        if (nums[fast] != val) {
            nums[slow] = nums[fast]
            slow++
        }
        fast++
    }

    return slow
}
```

### Remove Duplicates from Sorted Array

> **é¡Œç›®ï¼š** https://leetcode.com/problems/remove-duplicates-from-sorted-array/
> **é›£åº¦ï¼š** Easy
> **æŠ€å·§ï¼š** `Two Pointers`
> **èªè¨€ï¼š** Go

çµ¦ä½ ä¸€å€‹ int slice `nums`ï¼Œè«‹è®“ `nums` ä¸­çš„å…ƒç´ å…©å…©ä¸é‡è¤‡ã€‚

```go
func removeDuplicates(nums []int) int {
    if len(nums) == 1 {
        return 1
    }

    slow, fast := 0, 1

    for fast < len(nums) {
        if nums[slow] != nums[fast] {
            slow++
            nums[slow] = nums[fast]
        }
        fast++
    }

    return 1 + slow
}
```

### Container With Most Water

> **é¡Œç›®ï¼š** https://leetcode.com/problems/container-with-most-water/
> **é›£åº¦ï¼š** Medium
> **æŠ€å·§ï¼š** `Two Pointers`, `Greedy`
> **èªè¨€ï¼š** Go

çµ¦ä½ ä¸€å€‹ sliceï¼Œä¾‹å¦‚ï¼šheights = [1,8,6,2,5,4,8,3,7]ï¼Œæ¯å€‹æ•¸å­—ä»£è¡¨è©²åœ°é»çš„é«˜åº¦ï¼Œè«‹æ±‚å‡ºå“ªå…©é»ä¹‹é–“çš„ç©æ°´æœ€å¤šã€‚

1. Bruteforce
   - å°æ–¼æ¯å€‹é«˜åº¦ h âˆˆ heights
     - å†æƒè‡ªå·±é™¤å¤–çš„é«˜åº¦ï¼Œè¨ˆç®—ç©æ°´é¢ç©
2. Two Pointers + Greedy
   - `l` ç‚º heights çš„ indexï¼Œå³ 0
   - `r` ç‚º heights çš„ last indexï¼Œå³ `len(heights) - 1`
   - è®“ `l` èˆ‡ `r` èµ°å‘ slice çš„ä¸­å¤®
     - é«˜åº¦è¼ƒä½è€…ï¼Œå¾€ä¸­é–“èµ°
     - é«˜åº¦è¼ƒé«˜è€…ï¼Œä¸å‹•
     - åœ¨æ­¤éç¨‹ä¸­ä¸æ–·è¨ˆç®—ç©æ°´é¢ç©ï¼Œä¸¦ç”¨ `max()` æ›´æ–°çµæœ

```go
func maxArea(height []int) int {
    ret := 0
    l := 0
    r := len(height) - 1

    for l <= r {
        ret = max(ret, min(height[l], height[r]) * (r - l))

        if height[l] <= height[r] {
            l++
        } else {
            r--
        }
    }

    return ret
}
```

## Binary Search

### Binary Search

> **é¡Œç›®ï¼š** https://leetcode.com/problems/binary-search/
> **é›£åº¦ï¼š** Easy
> **æŠ€å·§ï¼š** `Binary Search`
> **èªè¨€ï¼š** Go

```go
func search(nums []int, target int) int {
    l := 0
    r := len(nums) - 1
    
    for l <= r {
        m := (l + r) / 2

        if nums[m] < target {
            l = m + 1
        } else if nums[m] > target {
            r = m - 1
        } else {
            return m
        }
    }
    
    return -1
}
```

### First Bad Version

> **é¡Œç›®ï¼š** https://leetcode.com/problems/first-bad-version/
> **é›£åº¦ï¼š** Easy
> **æŠ€å·§ï¼š** `Binary Search`
> **èªè¨€ï¼š** Go

```go
/** 
 * Forward declaration of isBadVersion API.
 * @param   version   your guess about first bad version
 * @return 	 	      true if current version is bad 
 *			          false if current version is good
 * func isBadVersion(version int) bool;
 */

func firstBadVersion(n int) int {
    l := 1
    r := n

    for l <= r {
        m := (l + r) / 2
        if isBadVersion(m) {
            r = m - 1
        } else {
            l = m + 1
        }
    }

    return l
}
```

## Sliding Window

### Longest Substring Without Repeating Characters

> **é¡Œç›®ï¼š** https://leetcode.com/problems/longest-substring-without-repeating-characters/
> **é›£åº¦ï¼š** Medium
> **æŠ€å·§ï¼š** `Sliding Window`
> **èªè¨€ï¼š** Go

1. Bruteforce
   - é¸ä¸€å€‹ begin
     - é¸ä¸€å€‹ end
       - æƒæ [begin, end] å…§çš„å­—å…ƒæ˜¯å¦æœ‰é‡è¤‡
   - O(N^3)
2. Sliding Window
   - æº–å‚™ä¸€å€‹ map
     - keyï¼šs ä¸­å‡ºç¾éçš„å­—å…ƒ
     - valueï¼šè©²å­—å…ƒæœ€å¾Œä¸€æ¬¡å‡ºç¾çš„ index
   - `l` èˆ‡ `r` åˆ†åˆ¥ä»£è¡¨ window å·¦å³ç•Œ
     - è¦å‰‡ï¼šwindow ä¸­ä¸å¯å‡ºç¾é‡è¤‡å­—å…ƒ
   - ä¸æ–·æ“´å¼µ window å³ç•Œï¼ŒåŒæ™‚æª¢æŸ¥æ­¤æ¬¡æ“´å¼µæ˜¯å¦æœƒä½¿ window è®Šå¾—ä¸åˆæ³•
     - è‹¥åˆæ³•ï¼Œç¹¼çºŒæ“´å¼µ
     - ä¸åˆæ³•ï¼Œå¿…é ˆè®“å®ƒå†æ¬¡åˆæ³•
   - å°æ–¼æ¯å€‹å­—å…ƒ c âˆˆ sï¼Œæˆ‘å€‘è®“ 
     - è‹¥ c å·²ç¶“åœ¨ç›®å‰çš„ window å…§ï¼ˆå³ï¼šl â‰¤ i â‰¤ rï¼‰
       - å‰‡ç›®å‰ window å·²ç„¡æ•ˆï¼Œæ•…æ›´æ–° `l` ç‚ºæœ€å¾Œå‡ºç¾çš„ idx + 1 ä½¿å¾— window å†æ¬¡åˆæ³•
     - ç”¨ `max()` æ›´æ–° `maxLen`ï¼Œæœ€å¾Œå›å‚³ä¹‹
     - å°‡ `c` çš„æœ€å¾Œå‡ºç¾ indexï¼ˆå³ï¼š`r`ï¼‰è¨˜ä¸‹ä¾†
   - O(N)

```go
func lengthOfLongestSubstring(s string) int {
    l := 0
    maxLen := 0
    lastAppearedAt := make(map[rune]int)

    for r, c := range s {
        // If this character has already appeared before,
        // and if it's within the current window...
        if idx, exists := lastAppearedAt[c]; exists && idx >= l {
            l = idx + 1
        }

        maxLen = max(maxLen, r - l + 1)
        lastAppearedAt[c] = r
    }

    return maxLen
}
```

### Maximum Average Subarray I

> **é¡Œç›®ï¼š** https://leetcode.com/problems/maximum-average-subarray-i/
> **é›£åº¦ï¼š** Easy
> **æŠ€å·§ï¼š** `Sliding Window`
> **èªè¨€ï¼š** C++17

çµ¦ä½ ä¸€ä¸² int `nums`ï¼Œä¸¦ä¸”å‘Šè¨´ä½  subarray len ç‚º `k`

ç”¨ sliding window ç®—å‡ºæ‰€æœ‰é•·åº¦ç‚º k çš„ subarrays çš„ maximum avg

```cpp
class Solution {
 public:
  double findMaxAverage(vector<int>& nums, int k) {
    const int n = nums.size();
    int l = 0;
    int r = k - 1;
    double sum = std::accumulate(nums.begin(), nums.begin() + k, 0);
    double maxAvg = std::numeric_limits<float>::lowest();

    while (r < n) {
      maxAvg = std::max(maxAvg, sum / k);

      sum -= nums[l];
      l++;

      r++;
      if (r < n) {
        sum += nums[r];
      }
    }

    return maxAvg;
  }
};
```

### Minimum Size Subarray Sum

> **é¡Œç›®ï¼š** https://leetcode.com/problems/minimum-size-subarray-sum/
> **é›£åº¦ï¼š** Medium
> **æŠ€å·§ï¼š** `Sliding Window`
> **èªè¨€ï¼š** C++17

çµ¦ä½ ä¸€ä¸²æ•¸å­— `nums` ä»¥åŠä¸€å€‹ `target`ï¼ˆçš†ç‚ºæ­£æ•´æ•¸ï¼‰ï¼Œæ±‚æœ€çŸ­çš„ subarray `s` çš„é•·åº¦ where `len(s) >= target`

* Sliding Window
  - å¾€å³æ“´å¼µå³ç•Œ
  - æ“´å¼µå¾Œï¼Œåœ¨ subarray sum é‚„å¤§æ–¼ç­‰æ–¼ `target` çš„æƒ…æ³ä¸‹ï¼Œå°‡å·¦ç•ŒæŒçºŒå¾€å³æ¨ç§»
  - ç´€éŒ„ä¸‹æœ€å°çš„ subarray length

```cpp
class Solution {
 public:
  int minSubArrayLen(int target, vector<int>& nums) {
    const int n = nums.size();
    int l = 0;
    int r = 0;
    int sum = 0;
    int len = std::numeric_limits<int>::max();

    for (; r < n; r++) {
      sum += nums[r];

      while (l < r && sum - nums[l] >= target) {
        sum -= nums[l];
        l++;
      }

      if (sum >= target) {
        len = std::min(len, r - l + 1);
      }
    }

    return len == std::numeric_limits<int>::max() ? 0 : len;
  }
};
```

## Tree

### Binary Tree Level Order Traversal

> **é¡Œç›®ï¼š** https://leetcode.com/problems/binary-tree-level-order-traversal/
> **é›£åº¦ï¼š** Medium
> **æŠ€å·§ï¼š** `Binary Tree`, `BFS`
> **èªè¨€ï¼š** Go

ä½¿ç”¨ queue åš binary tree BFSï¼Œ2019 å¹´åœ¨å°ç§‘è³‡å·¥æ‰€çš„æ¨ç”„å…¥å­¸å£è©¦ï¼Œç™½æ¿é¡Œå°±æ˜¯é€™é¡Œã€‚

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func levelOrder(root *TreeNode) [][]int {
    ret := make([][]int, 0)
    q := make([]*TreeNode, 0)

    if root != nil {
        q = append(q, root)
    }

    for len(q) > 0 {
        ret = append(ret, []int{})

        size := len(q)
        for i := 0; i < size; i++ {
            node := q[0]
            q = q[1:]

            ret[len(ret) - 1] = append(ret[len(ret) - 1], node.Val)

            if node.Left != nil {
                q = append(q, node.Left)
            }

            if node.Right != nil {
                q = append(q, node.Right)
            }
        }
    }

    return ret
}
```

### Binary Tree Preorder Traversal (Recursive)

> **é¡Œç›®ï¼š** https://leetcode.com/problems/binary-tree-preorder-traversal/
> **é›£åº¦ï¼š** Easy
> **æŠ€å·§ï¼š** `Tree`, `DFS`
> **èªè¨€ï¼š** Go

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func preorderTraversal(root *TreeNode) []int {
    nodes := make([]int, 0)
    preorderTraversalImpl(&nodes, root)
    return nodes
}

func preorderTraversalImpl(nodes *[]int, node *TreeNode) {
    if node == nil {
        return
    }

    *nodes = append(*nodes, node.Val)
    preorderTraversalImpl(nodes, node.Left)
    preorderTraversalImpl(nodes, node.Right)
}
```

### Binary Tree Inorder Traversal (Recursive)

> **é¡Œç›®ï¼š** https://leetcode.com/problems/binary-tree-inorder-traversal/
> **é›£åº¦ï¼š** Easy
> **æŠ€å·§ï¼š** `Tree`, `DFS`
> **èªè¨€ï¼š** Go

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func inorderTraversal(root *TreeNode) []int {
    nodes := make([]int, 0)
    inorderTraversalImpl(&nodes, root)
    return nodes
}

func inorderTraversalImpl(nodes *[]int, node *TreeNode) {
    if node == nil {
        return
    }

    inorderTraversalImpl(nodes, node.Left)
    *nodes = append(*nodes, node.Val)
    inorderTraversalImpl(nodes, node.Right)
}
```

### Binary Tree Postorder Traversal (Recursive)

> **é¡Œç›®ï¼š** https://leetcode.com/problems/binary-tree-postorder-traversal/
> **é›£åº¦ï¼š** Easy
> **æŠ€å·§ï¼š** `Tree`, `DFS`
> **èªè¨€ï¼š** Go

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func postorderTraversal(root *TreeNode) []int {
    nodes := make([]int, 0)
    postorderTraversalImpl(&nodes, root)
    return nodes
}

func postorderTraversalImpl(nodes *[]int, node *TreeNode) {
    if node == nil {
        return
    }
    
    postorderTraversalImpl(nodes, node.Left)
    postorderTraversalImpl(nodes, node.Right)
    *nodes = append(*nodes, node.Val)
}
```

### Maximum Depth of Binary Tree

> **é¡Œç›®ï¼š** https://leetcode.com/problems/maximum-depth-of-binary-tree/
> **é›£åº¦ï¼š** Easy
> **æŠ€å·§ï¼š** `Tree`, `DFS`
> **èªè¨€ï¼š** Go

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func maxDepth(root *TreeNode) int {
    return maxDepthImpl(root, 1)
}

func maxDepthImpl(node *TreeNode, depth int) int {
    if node == nil {
        return depth - 1
    }

    return max(
        maxDepthImpl(node.Left, depth + 1),
        maxDepthImpl(node.Right, depth + 1))
}
```

### Minimum Depth of Binary Tree

> **é¡Œç›®ï¼š** https://leetcode.com/problems/minimum-depth-of-binary-tree/
> **é›£åº¦ï¼š** Easy
> **æŠ€å·§ï¼š** `Tree`, `DFS`
> **èªè¨€ï¼š** Go

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func minDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }

    return minDepthImpl(root, 1)
}

func minDepthImpl(node *TreeNode, depth int) int {
    if node == nil {
        return math.MaxInt
    }
    
    if node.Left == nil && node.Right == nil {
        return depth
    }

    return min(
        minDepthImpl(node.Left, depth + 1),
        minDepthImpl(node.Right, depth + 1))
}
```

### Path Sum

> **é¡Œç›®ï¼š** https://leetcode.com/problems/path-sum/
> **é›£åº¦ï¼š** Easy
> **æŠ€å·§ï¼š** `Tree`, `DFS`
> **èªè¨€ï¼š** Go

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func hasPathSum(root *TreeNode, targetSum int) bool {
    return hasPathSumImpl(root, 0, targetSum)
}

func hasPathSumImpl(node *TreeNode, localSum, targetSum int) bool {
    if node == nil {
        return false
    }
     
    localSum += node.Val   
    
    if node.Left == nil && node.Right == nil && localSum == targetSum {
        return true
    }
    
    return hasPathSumImpl(node.Left, localSum, targetSum) ||
           hasPathSumImpl(node.Right, localSum, targetSum)
}
```

### Path Sum II

> **é¡Œç›®ï¼š** https://leetcode.com/problems/path-sum-ii/
> **é›£åº¦ï¼š** Medium
> **æŠ€å·§ï¼š** `Tree`, `DFS`, `Backtracking`
> **èªè¨€ï¼š** Go

* DFS
  - PreOrder binary tree traversal
* Backtracking
  - ç•¶å‰çš„ path åªéœ€è¦ç”¨åŒä¸€å€‹ slice å­˜å°±å¥½
  - ç•¶ä¸€å€‹ node ä»¥åŠå…¶ children éƒ½å·²èµ°è¨ªå®Œç•¢æ™‚ï¼Œå°±è‡ªå·±å¾ `localPath` çš„å°¾éƒ¨ç§»é™¤ï¼ˆè‡ªå·±ä¸€å®šåœ¨å°¾éƒ¨ï¼‰
  - å¦‚æœç•¶å‰æ˜¯ leaf node ä¸”ç•¶å‰çš„ pathSum ç­‰æ–¼ targetSumï¼Œå°±åŠ å…¥ `paths`ï¼ˆæ³¨æ„ï¼šè¦ deep copy sliceï¼‰

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func pathSum(root *TreeNode, targetSum int) [][]int {
    var localPath []int
    var paths [][]int
    pathSumImpl(root, 0, targetSum, &localPath, &paths)
    return paths
}

func pathSumImpl(
    node *TreeNode,
    localSum int,
    targetSum int,
    localPath *[]int,
    paths *[][]int,
) {
    if node == nil {
        return
    }

    localSum += node.Val
    *localPath = append(*localPath, node.Val)
    defer func() {
        *localPath = (*localPath)[:len(*localPath) - 1]
    }()

    if node.Left == nil && node.Right == nil && localSum == targetSum {
        newPath := make([]int, len(*localPath))
        copy(newPath, *localPath)
        *paths = append(*paths, newPath)
        return
    }

    pathSumImpl(node.Left, localSum, targetSum, localPath, paths)
    pathSumImpl(node.Right, localSum, targetSum, localPath, paths)
}
```

### Path Sum III

> **é¡Œç›®ï¼š** https://leetcode.com/problems/path-sum-ii/
> **é›£åº¦ï¼š** Medium
> **æŠ€å·§ï¼š** `Tree`, `DFS`, `Backtracking`
> **èªè¨€ï¼š** Go

* è§£æ³•ä¸€
  - ç¶­è­· `sumMap`
    - key ç‚º source node
    - val ç‚º path sum
  - DFS + Backtracking
    - PreOrder Tree Traversal (ä¸­å·¦å³)ï¼š`sumMap` å…§çš„ entries å¿…ç‚ºåŒä¸€æ¢ path ä¸Šçš„ nodes
    - Backtrackingï¼šå·¦å³å­æ¨¹èµ°è¨ªå®Œç•¢å¾Œï¼Œä»£è¡¨æ­¤ node ä¹Ÿè™•ç†å®Œäº†ï¼Œæ•…å°‡æ­¤ node å¾ `sumMap` ç§»é™¤
    - èµ°è¨ªç¶“éä¸€å€‹ node æ™‚ï¼Œå…ˆå°‡åŒæ¢ path ä¸Šçš„ï¼ˆä¹Ÿå°±æ˜¯ `sumMap` å…§çš„ï¼‰path sum åŠ ä¸Š `node.Val`
  - æ­¤è§£æ³•æœ‰é»æ…¢ï¼Œæ›´å„ªé›…çš„è§£æ³•è¦‹è§£æ³•äºŒ

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func pathSum(root *TreeNode, targetSum int) int {
    var count int
    sumMap := make(map[*TreeNode]int)
    pathSumImpl(root, targetSum, sumMap, &count)
    return count
}

func pathSumImpl(node *TreeNode, targetSum int, sumMap map[*TreeNode]int, count *int) {
    if node == nil {
        return
    }

    for srcNode, pathSum := range sumMap {
        sumMap[srcNode] = pathSum + node.Val
        if pathSum + node.Val == targetSum {
            *count++
        }
    }
    sumMap[node] = node.Val

    if node.Val == targetSum {
        *count++
    }
 
    pathSumImpl(node.Left, targetSum, sumMap, count)
    pathSumImpl(node.Right, targetSum, sumMap, count) 

    delete(sumMap, node)
    for srcNode := range sumMap {
        sumMap[srcNode] -= node.Val
    }
}
```

* è§£æ³•äºŒï¼š
  - Two-level recursion
    - å°‡ tree ä¸­çš„æ¯ä¸€å€‹ node è¦–ç‚º source nodeï¼Œä¸¦é€²è¡Œ PreOrder Tree Traversalï¼ˆå°ï¼Œå°±æ˜¯é‚£éº¼ç²—æš´ï¼‰
    - é›£åº¦å’Œ Path Sum å·®ä¸å¤š...ğŸ˜… ï¼Œä½†å»æ¯”è§£æ³•ä¸€å¿«ï¼Œè€Œä¸”é‚„æ›´ç¯€çœè¨˜æ†¶é«”
    - æ³¨æ„ï¼š`localSum == targetSum` ä¸ç”¨ææ—© returnï¼Œå› ç‚ºæœƒæœ‰ subpaths é‡ç–Šï¼Œä½† path sum ç›¸åŒçš„æƒ…æ³

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func pathSum(root *TreeNode, targetSum int) int {
    var count int
    pathSumImpl(root, targetSum, &count)
    return count
}

func pathSumImpl(src *TreeNode, targetSum int, count *int) {
    if src == nil {
        return
    }

    dfs(src, 0, targetSum, count)

    pathSumImpl(src.Left, targetSum, count)
    pathSumImpl(src.Right, targetSum, count)
}

func dfs(node *TreeNode, localSum, targetSum int, count *int) {
    if node == nil {
        return
    }

    localSum += node.Val
    if localSum == targetSum {
        *count++
    }

    dfs(node.Left, localSum, targetSum, count)
    dfs(node.Right, localSum, targetSum, count)
}
```

### Invert Binary Tree

> **é¡Œç›®ï¼š** https://leetcode.com/problems/invert-binary-tree/
> **é›£åº¦ï¼š** Easy
> **æŠ€å·§ï¼š** `Tree`, `DFS`
> **èªè¨€ï¼š** Go

* å¯ä»¥ä½¿ç”¨ Preorder DFS æˆ– Postorder DFS
* ä¸å¯ä½¿ç”¨ Inorder DFS

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func invertTree(root *TreeNode) *TreeNode {
    invertTreeImpl(root) 
    return root
}

func invertTreeImpl(node *TreeNode) {
    if node == nil {
        return
    } 

    node.Left, node.Right = node.Right, node.Left
    invertTreeImpl(node.Left)
    invertTreeImpl(node.Right)
}
```

### Implement Trie (Prefix Tree)

> **é¡Œç›®ï¼š** https://leetcode.com/problems/implement-trie-prefix-tree/
> **é›£åº¦ï¼š** Medium
> **æŠ€å·§ï¼š** `Trie`, `Tree`
> **èªè¨€ï¼š** Go

* æ¸¬è³‡æ˜¯ n å€‹ stringsï¼Œæ¯å€‹å­—ä¸²åªæœƒåŒ…å«å°å¯«è‹±æ–‡å­—æ¯
* å¯¦ä½œ Trie é€™å€‹è³‡æ–™çµæ§‹ï¼Œä¸¦æä¾›ä¸‹åˆ— API
  - `Trie::Insert()`ï¼šæ’å…¥ä¸€å€‹ string
  - `Trie::Search()`ï¼šæœå°‹ string (exact match)
  - `Trie::StartsWith()`ï¼šæœå°‹ string (prefix match)
* æ¯å€‹ trie node å¤šä¸€å€‹ `isEnd` data member
  - ç”¨é€”ï¼šè¨˜éŒ„è©² node æ˜¯å¦ç‚ºä¸€å€‹æ›¾æ’å…¥éçš„ string çš„æœ€å¾Œå­—å…ƒ

```go
type Node struct {
    val rune
    children []*Node
    isEnd bool
}

type Trie struct {
    root *Node
}

func (this *Node) addChild(r rune) *Node {
    newChild := Node{val: r, children: make([]*Node, 0)}
    this.children = append(this.children, &newChild)
    return &newChild
}

func (this *Node) getChild(r rune) *Node {
    for _, node := range this.children {
        if node.val == r {
            return node
        }
    }
    return nil
}

func Constructor() Trie {
    return Trie{root: &Node{children: make([]*Node, 0)}}
}

func (this *Trie) Insert(word string)  {
    node := this.root
    
    for _, c := range word {
        if child := node.getChild(c); child != nil {
            node = child
        } else {
            node = node.addChild(c)
        }
    }
    
    node.isEnd = true
}

func (this *Trie) walk(word string) *Node {
    node := this.root
    for _, c := range word {
        if child := node.getChild(c); child != nil {
            node = child
        } else {
            return nil
        }
    }
    
    return node
}

func (this *Trie) Search(word string) bool {
    node := this.walk(word)
    return node != nil && node.isEnd
}

func (this *Trie) StartsWith(prefix string) bool {
    node := this.walk(prefix)
    return node != nil
}


/**
 * Your Trie object will be instantiated and called as such:
 * obj := Constructor();
 * obj.Insert(word);
 * param_2 := obj.Search(word);
 * param_3 := obj.StartsWith(prefix);
 */
```

### Maximum Product of Splitted Binary Tree

> **é¡Œç›®ï¼š** https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/
> **é›£åº¦ï¼š** Medium
> **æŠ€å·§ï¼š** `Tree`, `DFS`
> **èªè¨€ï¼š** Go

å¾ tree ç§»é™¤ä»»ä¸€å€‹ edgeï¼Œä½¿å…¶åˆ†è£‚ç‚ºå…©æ£µ subtreesï¼Œè«‹æ±‚å‡ºå…©æ£µ subtrees å„è‡ªåŠ ç¸½å¾Œï¼Œæœ€å¤§çš„ä¹˜ç©ç‚ºä½•

* Binary Tree DFS
  - å°‡æ¯å€‹ tree node ç•¶æˆ subtree çš„ root node
  - ç”¨ PostOrder traversal ä»¥ bottom up çš„æ–¹å¼å»º subtree sum map (`dp`)
* æƒä¸€æ¬¡ subtree sum map
  - æ¯å€‹ iteration çš„ (key, value) å³ (node, node ä½œç‚º subtree1 root çš„ sum)
  - subtree2 çš„ sum = åŸ tree çš„ sum - subtree1 çš„ sum

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func maxProduct(root *TreeNode) int {
    dp := make(map[*TreeNode]uint64)
    maxProductImpl(dp, root) 

    ret := uint64(0)
    treeSum := dp[root]
    for _, subtreeSum := range dp {
        sum1 := subtreeSum
        sum2 := treeSum - sum1
        ret = max(ret, sum1 * sum2)
    }
    return int(ret % uint64(1000000007))
}

func maxProductImpl(dp map[*TreeNode]uint64, node *TreeNode) {
    if node == nil {
        return
    }

    maxProductImpl(dp, node.Left)
    maxProductImpl(dp, node.Right)
    dp[node] = dp[node.Left] + uint64(node.Val) + dp[node.Right]
}
```

## Graph

### Find if Path Exists in Graph

> **é¡Œç›®ï¼š** https://leetcode.com/problems/find-if-path-exists-in-graph/
> **é›£åº¦ï¼š** Easy
> **æŠ€å·§ï¼š** `Graph`, `BFS`, `Union Find`
> **èªè¨€ï¼š** Go

* è§£æ³•ä¸€ï¼š
  - å»º adjacency mapï¼ˆadjacency matrix æœƒå› ç‚ºå·¨å¤§æ¸¬è³‡è€Œæ’åˆ° Out of Memoryï¼‰
    - keyï¼šsource node (`int`)
    - valï¼šset of neighbors (`map[int]struct{}`)
  - BFS, è¨˜å¾—ä¸è¦é‡è¤‡èµ°è¨ªå·²èµ°è¨ªéçš„ nodes

```go
func validPath(n int, edges [][]int, source int, destination int) bool {
    adjacencyMap := make(map[int]map[int]struct{})
    for _, edge := range edges {
        src, dst := edge[0], edge[1]

        if _, exist := adjacencyMap[src]; !exist {
            adjacencyMap[src] = make(map[int]struct{})
        }
        adjacencyMap[src][dst] = struct{}{}

        if _, exist := adjacencyMap[dst]; !exist {
            adjacencyMap[dst] = make(map[int]struct{})
        }
        adjacencyMap[dst][src] = struct{}{}
    }

    isVisited := make([]bool, n)
    queue := []int{source}
    for len(queue) != 0 {
        node := queue[0]
        queue = queue[1:]

        isVisited[node] = true
        if node == destination {
            return true
        }

        for neighbor := range adjacencyMap[node] {
            if !isVisited[neighbor] {
                queue = append(queue, neighbor)
            }
        }
    }

    return false
}
```

### Keys and Rooms

> **é¡Œç›®ï¼š** https://leetcode.com/problems/keys-and-rooms/
> **é›£åº¦ï¼š** Medium
> **æŠ€å·§ï¼š** `Graph`, `BFS`
> **èªè¨€ï¼š** Go

çµ¦ä½ ä¸€å€‹ digraph çš„æ‰€æœ‰ edgesï¼ˆä»¥ adjacency list çš„å½¢å¼ï¼‰ï¼Œè«‹å•å®ƒæ˜¯å¦ä¸å­˜åœ¨ isolated nodeã€‚

æ ¹æ“šé¡Œç›®æè¿°ï¼Œå¾ node 0 é–‹å§‹åš BFSï¼Œåšå®Œå¾Œå¦‚æœ all nodes visited å°± return trueã€‚

```go
func canVisitAllRooms(rooms [][]int) bool {
    adjacencyMap := make(map[int]map[int]struct{})
    for room, keys := range rooms {
        if len(keys) == 0 {
            continue
        }
        if _, exist := adjacencyMap[room]; !exist {
            adjacencyMap[room] = make(map[int]struct{})
        }
        for _, key := range keys {
            adjacencyMap[room][key] = struct{}{}
        }
    }

    n := len(rooms)
    isVisited := make([]bool, n)
    queue := []int{0}
    for len(queue) != 0 {
        node := queue[0]
        queue = queue[1:]

        isVisited[node] = true

        for neighbor := range adjacencyMap[node] {
            if !isVisited[neighbor] {
                queue = append(queue, neighbor)
            }
        }
    }

    hasVisitedAllNodes := true
    for _, visited := range isVisited {
        if !visited {
            hasVisitedAllNodes = false
            break
        }
    }
    if hasVisitedAllNodes {
        return true
    }

    return false
}
```

### Is Graph Bipartite?

> **é¡Œç›®ï¼š** https://leetcode.com/problems/is-graph-bipartite/
> **é›£åº¦ï¼š** Medium
> **æŠ€å·§ï¼š** `Graph`, `BFS`
> **èªè¨€ï¼š** Go

çµ¦å®šä¸€å€‹ undirected graphï¼ˆä»¥ adjacency list çš„å½¢å¼ï¼‰ï¼Œåˆ¤æ–·å®ƒæ˜¯å¦ç‚º[bipartite](https://en.wikipedia.org/wiki/Bipartite_graph)

* Graph BFS
  - æ²’èµ°è¨ªéçš„ node æ‰éœ€è¦é€² queue
  - å¦‚æœæŸå€‹ neighbor å·²ç¶“èµ°è¨ªéï¼Œå®ƒå°±æœƒæœ‰å€‹é¡è‰²ï¼ˆè—æˆ–ç´…ï¼‰ï¼Œæª¢æŸ¥ä¸€ä¸‹æ˜¯å¦å’Œç›®å‰çš„ node é¡è‰²ç›¸åŒ
    - ç›¸åŒï¼šä¸æ˜¯äºŒåˆ†åœ–ï¼Œç«‹åˆ»è¿”å› false
    - ä¸åŒï¼šç¹¼çºŒ BFS
  - æ³¨æ„ï¼š
    - æ¸¬è³‡æœªå¿…æ˜¯ connected graphï¼Œåªç”¨ node 0 ä¸‹å»è·‘ BFS æœƒæ¼æ‰æŸéƒ¨åˆ† subgraph

```go
var (
    visited []bool
    colors []bool
)

func isBipartite(graph [][]int) bool {
    visited = make([]bool, len(graph))
    colors = make([]bool, len(graph)) 

    for nodeIdx := range graph {
        if !visited[nodeIdx] && !isBipartiteImpl(graph, nodeIdx) {
            return false
        }
    }
    return true
}

func isBipartiteImpl(graph [][]int, beginNodeIdx int) bool {
    currentColor := true  // true: blue, false: red 
    q := []int{beginNodeIdx}

    for len(q) > 0 {
        size := len(q)   

        for i := 0; i < size; i++ {
            thisNodeIdx := q[0]
            q = q[1:]

            visited[thisNodeIdx] = true
            colors[thisNodeIdx] = currentColor

            for _, neighborIdx := range graph[thisNodeIdx] {
                // Push all the neighbors of thisNode into the queue
                // for the next iteration of BFS.
                if !visited[neighborIdx] {
                    q = append(q, neighborIdx)
                } else if colors[neighborIdx] == currentColor {
                    return false
                }
            }
        }

        // Invert color
        currentColor = !currentColor
    }

    return true
}
```

### Network Delay Time

> **é¡Œç›®ï¼š** https://leetcode.com/problems/network-delay-time/
> **é›£åº¦ï¼š** Medium
> **æŠ€å·§ï¼š** `Graph`, `Dijkstra`
> **èªè¨€ï¼š** Go

çµ¦ä½ ä¸€å€‹ network graphï¼Œè£¡é¢æœ‰ n å€‹ nodesã€‚è«‹å•å¾ node `k-1` é–‹å§‹ broadcast signal çš„è©±ï¼Œæœ€å¿«è¦èŠ±å¤šä¹…æ™‚é–“æ‰€æœ‰ nodes æ‰èƒ½å…¨éƒ½æ”¶åˆ°è©² signalï¼Ÿ

å¾åœ–è«–çš„è§’åº¦ä¾†è§£é‡‹ï¼Œçµ¦ä½ ï¼š

* ä¸€å€‹ weighted digraphï¼ˆä»¥ weighted adjacency listï¼‰çš„å½¢å¼
* ä¸€å€‹ source node `k`

è«‹æ‰¾å‡ºè©² graph ä¸­èˆ‡ k æœ€é çš„è·é›¢ï¼ˆi.e. æ²¿è·¯æ¬Šé‡çš„åŠ ç¸½ï¼‰

1. Dijkstra (https://youtu.be/pVfj6mxhdMw?t=132)
   - è¼¸å…¥ï¼šweighted adjacency matrix, source node
   - è¼¸å‡ºï¼šå¾ source node åˆ°å…¶ä»–æ‰€æœ‰ nodes çš„ shortest distances
   - æ³¨æ„ï¼šé¡Œç›®çµ¦çš„æ¬Šé‡å¯èƒ½æœƒæœ‰ 0ï¼Œæ‰€ä»¥ä»»å…©ç¯€é»é–“è‹¥æ²’æœ‰ edgeï¼Œåœ¨ `graph` ä¸­è¦ä»¥ -1 ä¾†è¡¨ç¤º
   - è¼¸å‡ºçš„ slice å– max element å°±æ˜¯ç­”æ¡ˆ

```go
// Dijkstra: Single-Source All-Destinations Shortest Path
func dijkstra(graph [][]int, n int, k int) []int {
    visited := make([]bool, n)
    previous := make([]int, n)
    distances := make([]int, n)

    // Set node k (index: k - 1) as the source node.
    for i := 0; i < n; i++ {
        distances[i] = math.MaxInt
    }
    distances[k - 1] = 0

    for sliceContains(visited, false) {
        // Find an unvisited node with the shortest distance from node k.
        i := 0
        minDist := math.MaxInt

        for j := 0; j < n; j++ {
            if !visited[j] && distances[j] <= minDist {
                minDist = distances[j]
                i = j
            }
        }

        for j := 0; j < n; j++ {
            if !visited[j] && graph[i][j] != -1 {
                // If the distance between [i, j] is less than
                // the known distance, update the shortest distance.
                if d := distances[i] + graph[i][j]; d < distances[j] {
                    distances[j] = d
                    previous[i] = i
                }
            }
        }

        visited[i] = true
    }

    fmt.Println(distances)
    return distances
}

func networkDelayTime(times [][]int, n int, k int) int {
    // Build the weighted adjacency matrix of the graph.
    graph := make([][]int, n)

    for i := range graph {
        graph[i] = make([]int, n)
        for j := range graph[i] {
            graph[i][j] = -1
        }
    }

    for _, t := range times {
        src := t[0] - 1
        dst := t[1] - 1
        weight := t[2]

        graph[src][dst] = weight
    }

    if ret := max(dijkstra(graph, n, k)...); ret == math.MaxInt {
        return -1
    } else {
        return ret
    }
}
```

## Dynamic Programming

### Best Time to Buy and Sell Stock

> **é¡Œç›®ï¼š** https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/
> **é›£åº¦ï¼š** Easy
> **æŠ€å·§ï¼š** `DP`
> **èªè¨€ï¼š** C++17

çµ¦ä½ ä¸€å€‹ vector of ints `prices` ä»£è¡¨æŸå¼µè‚¡ç¥¨çš„åƒ¹éŒ¢ï¼Œç¬¬ i å€‹å…ƒç´ ä»£è¡¨å®ƒåœ¨ç¬¬ i å¤©çš„åƒ¹éŒ¢ã€‚

ä½ å¯ä»¥åœ¨ç¬¬ x å¤©ä»¥ä½åƒ¹è²·å…¥è‚¡ç¥¨ï¼Œåœ¨ç¬¬ y å¤©å°‡å®ƒè³£å‡ºï¼Œå…¶ä¸­ `x < y`ï¼Œæ±‚æœ€å¤§çš„ç²åˆ©ï¼Ÿ

* DP
  - ç²åˆ© = è³£å‡ºåƒ¹æ ¼ - è²·å…¥åƒ¹æ ¼
  - åªè¦èƒ½æœ€å¤§åŒ–è³£å‡ºåƒ¹æ ¼ï¼Œä¸”æœ€å°åŒ–è²·å…¥åƒ¹æ ¼ï¼Œå°±èƒ½å‰µé€ å‡ºæœ€å¤§ç²åˆ©
  - `rmax[i]` ä»£è¡¨ï¼šè‹¥åœ¨ç¬¬ i å¤©è²·å…¥ï¼Œæœ€é«˜çš„è³£å‡ºåƒ¹æ ¼å¯ä»¥æ˜¯å¤šå°‘
  - `lmin[i]` ä»£è¡¨ï¼šè‹¥åœ¨ç¬¬ i å¤©è³£å‡ºï¼Œæœ€ä½çš„è²·å…¥åƒ¹æ ¼å¯ä»¥æ˜¯å¤šå°‘

```cpp
class Solution {
 public:
  int maxProfit(vector<int>& prices) {
    const int n = prices.size();

    // [7, 6, 6, 6, 6, 4]
    vector<int> rmax(n);
    rmax[n - 1] = prices[n - 1];
    for (int i = n - 2; i >= 0; i--) {
      rmax[i] = std::max(rmax[i + 1], prices[i]);
    }

    // [7, 1, 1, 1, 1, 1]
    vector<int> lmin(n);
    lmin[0] = prices[0];
    for (int i = 1; i < n; i++) {
      lmin[i] = std::min(lmin[i - 1], prices[i]);
    }

    vector<int> diff(n);
    for (int i = 0; i < n; i++) {
      diff[i] = rmax[i] - lmin[i];
    }

    return *std::max_element(diff.begin(), diff.end());
  }
};
```

### Best Time to Buy and Sell Stock II

> **é¡Œç›®ï¼š** https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/
> **é›£åº¦ï¼š** Medium
> **æŠ€å·§ï¼š** `DP`
> **èªè¨€ï¼š** C++17

å»¶çºŒç¬¬ä¸€é¡Œï¼š
* ç¬¬ä¸€é¡Œåªè¦æ±‚ single transaction çš„æœ€å¤§ç²åˆ©
* ç¬¬äºŒé¡Œéœ€è¦æ±‚ multiple transactions çš„æœ€å¤§ç²åˆ©
  - å¯ä»¥ç•¶æ—¥è²·ã€è³£
  - ä½†ä¸€æ¬¡åªèƒ½æŒæœ‰ä¸€å¼µè‚¡ç¥¨

* DP
  - å¦‚æœå°‡ `prices` ç•«æˆæŠ˜ç·šåœ–ï¼Œæˆ‘å€‘æœƒè§€å¯Ÿåˆ°ï¼Œå°‡æ‰€æœ‰æ–œç‡ > 0 çš„ç·šæ®µçš„ delta y ç´¯åŠ å°±æ˜¯ç­”æ¡ˆ

```cpp
class Solution {
 public:
  int maxProfit(vector<int>& prices) {
    const int n = prices.size();
    int src = 0;
    int ret = 0;

    for (int i = 1; i < n; i++) {
      if (prices[i] < prices[i - 1]) {
        ret += prices[i - 1] - prices[src];
        src = i;
      }
    }
    return ret + (prices[n - 1] - prices[src]);
  }
};
```

### Maximum Subarray

> **é¡Œç›®ï¼š** https://leetcode.com/problems/maximum-subarray/
> **é›£åº¦ï¼š** Medium
> **æŠ€å·§ï¼š** `DP` `Kadane`
> **èªè¨€ï¼š** Go

* Kadane's Algorithm [[ref](https://medium.com/@rsinghal757/kadanes-algorithm-dynamic-programming-how-and-why-does-it-work-3fd8849ed73d)]
  - ç¶­è­·ä¸€å€‹è®Šæ•¸ `localMax`ï¼Œä¸¦æƒä¸€æ¬¡ `nums`ï¼Œæ¯è¼ªæƒåˆ°çš„æ•¸å­—å« `num`
    - `localMax` ä»£è¡¨æˆªè‡³ç‚ºæ­¢ï¼ˆä¸å« `num`ï¼‰çš„ maximum subarray çš„å’Œ
    - çœ‹çœ‹ `localMax` åŠ ä¸Š `num` æ˜¯å¦æœƒæ›´å¤§

```go
func maxSubArray(nums []int) int {
    globalMax := math.MinInt
    localMax := 0
    for _, num := range nums {
        localMax = max(num, num + localMax)
        globalMax = max(globalMax, localMax)
    }

    return globalMax
}
```

### Maximum Product Subarray

> **é¡Œç›®ï¼š** https://leetcode.com/problems/maximum-product-subarray/
> **é›£åº¦ï¼š** Medium
> **æŠ€å·§ï¼š** `DP` `Kadane`
> **èªè¨€ï¼š** Go

* åŸºæ–¼ Kadane's Algorithm
  - `localMax`ï¼šå› ç‚ºæ˜¯ä¹˜æ³•ï¼Œæ‰€ä»¥ä¸€é–‹å§‹å¾—åˆå§‹åŒ–ç‚º 1 è€Œä¸æ˜¯ 0ï¼Œå¦å‰‡ä¹‹å¾Œå†æ€éº¼ä¹˜éƒ½æ˜¯ 0
  - `localMin`ï¼šå› ç‚ºä¹˜æ³•å¯èƒ½è² è² å¾—æ­£ï¼Œé€²è€Œç”¢ç”Ÿä¸€å€‹æ›´å¤§çš„æ­£æ•¸ï¼Œæ‰€ä»¥é‚„è¦é¡å¤–ç¶­è­·æ­¤è®Šæ•¸
  - æƒä¸€æ¬¡ `nums`ï¼Œæ¯è¼ªæƒåˆ°çš„æ•¸å­—å« `num`
    - è‹¥ `num` ç‚ºæ­£æ•¸ï¼Œå‰‡ `num` ä¹˜ä»¥æ­£çš„ `localMax` æœ‰æ©Ÿæœƒç”¢ç”Ÿä¸€å€‹æ›´å¤§çš„æ­£æ•¸
    - è‹¥ `num` ç‚ºè² æ•¸ï¼Œå‰‡ `num` ä¹˜ä»¥è² çš„ `localMin` æœ‰æ©Ÿæœƒç”¢ç”Ÿä¸€å€‹æ›´å¤§çš„æ­£æ•¸

```go
func maxProduct(nums []int) int {
    globalMax := math.MinInt
    localMax, localMin := 1, 1
    for _, num := range nums {
        prod1 := num * localMax
        prod2 := num * localMin
        localMax = max(num, prod1, prod2)
        localMin = min(num, prod1, prod2)
        globalMax = max(globalMax, localMax)
    }

    return globalMax
}
```

### House Robber

> **é¡Œç›®ï¼š** https://leetcode.com/problems/house-robber/
> **é›£åº¦ï¼š** Medium
> **æŠ€å·§ï¼š** `DP`
> **èªè¨€ï¼š** Go

* DP
  - `dp` æ˜¯ä¸€å€‹ä¸€ç¶­çš„ slice
    - `dp[i]` ä»£è¡¨å¾ `nums[0]` æ¶åˆ° `nums[i]` ç‚ºæ­¢ï¼Œæ‰€èƒ½ç²å¾—çš„æœ€å¤§é‡‘é¡
      - `dp[0]` = æ¶åˆ° `nums[0]` ç‚ºæ­¢æœ€å¤šèƒ½æ¶å¤šå°‘ï¼Œé€™é‚Šåªæœ‰ `nums[0]` ä¸€é–“æˆ¿å±‹èƒ½æ¶
      - `dp[1]` = æ¶åˆ° `nums[1]` ç‚ºæ­¢æœ€å¤šèƒ½æ¶å¤šå°‘ï¼Œé€™é‚Šé¸ `nums[0]` èˆ‡ `nums[1]` åƒ¹å€¼è¼ƒé«˜è€…
    - è¦æ¶é€™ä¸€æ£Ÿï¼Œå°±ä¸èƒ½æ¶å®ƒå‰ä¸€æ£Ÿ
      - max(å‰ä¸€æ£Ÿå¯ä»¥æ¶åˆ°çš„æœ€å¤§é‡‘é¡, å‰å‰ä¸€æ£Ÿå¯ä»¥æ¶åˆ°çš„æœ€å¤§é‡‘é¡ + ç¾åœ¨é€™æ£Ÿ)

```go
func rob(nums []int) int {
    if len(nums) == 1 {
        return nums[0]
    }
    if len(nums) == 2 {
        return max(nums[0], nums[1])
    }

    dp := make([]int, len(nums))
    dp[0] = nums[0]
    dp[1] = max(nums[0], nums[1])
    for i := 2; i < len(nums); i++ {
        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])
    }

    return dp[len(nums) - 1]
}
```

### Unique Paths

> **é¡Œç›®ï¼š** https://leetcode.com/problems/unique-paths/
> **é›£åº¦ï¼š** Medium
> **æŠ€å·§ï¼š** `DP`
> **èªè¨€ï¼š** Go

* DP
  - `dp` æ˜¯ä¸€å€‹äºŒç¶­ m x n slice (m rows, n cols)
    - æ¯ä¸€æ ¼ä»£è¡¨ï¼šå¾å·¦ä¸Šè§’èµ°åˆ°è©²é»çš„ç¸½æ–¹æ³•æ•¸
    - ç¬¬ä¸€å€‹ row çš„æ‰€æœ‰æ ¼å­å¡«å…¥ 0
    - ç¬¬ä¸€å€‹ col çš„æ‰€æœ‰æ ¼å­å¡«å…¥ 0
  - æ¯æ¬¡ç§»å‹•åªèƒ½å¾€å³ã€å¾€ä¸‹
    - ä¹Ÿå°±æ˜¯èªªï¼ŒæŠµé”æ¯å€‹æ ¼å­çš„æ–¹æ³•æ•¸ = å·¦é‚Šä¾†çš„æ–¹æ³•æ•¸ + ä¸Šé¢ä¾†çš„æ–¹æ³•æ•¸

```go
func uniquePaths(m int, n int) int {
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }
    
    for i := 0; i < m; i++ {
        dp[i][0] = 1
    }
    for i := 0; i < n; i++ {
        dp[0][i] = 1
    }
    
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        }
    }
    
    return dp[m - 1][n - 1]
}
```

### Unique Paths II

> **é¡Œç›®ï¼š** https://leetcode.com/problems/unique-paths-ii/
> **é›£åº¦ï¼š** Medium
> **æŠ€å·§ï¼š** `DP`
> **èªè¨€ï¼š** Go

* DP
  - è§£æ³•å’Œ Unique Path 87% åƒï¼Œåˆå§‹åŒ–ç¬¬ä¸€å€‹ row èˆ‡ç¬¬ä¸€å€‹ col æ™‚è¨˜å¾—è€ƒæ…®éšœç¤™ç‰©
    - å¦‚æœæƒåˆ°ä¸€åŠé‡åˆ°éšœç¤™ç‰©ï¼Œå¾Œé¢çš„æ ¼å­è‚¯å®šéƒ½ç„¡æ³•æŠµé”
  - å¦‚æœæŸå€‹æ ¼å­æœ‰éšœç¤™ç‰©ï¼Œé‚£éº¼æŠµé”è©²é»çš„æ–¹æ³•æ•¸å¿…ç‚º 0

```go
func uniquePathsWithObstacles(obstacleGrid [][]int) int {
    m := len(obstacleGrid)
    n := len(obstacleGrid[0])
    
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }
    
    for i := 0; i < m; i++ {
        if obstacleGrid[i][0] == 1 {
            break
        }
        dp[i][0] = 1
    }
    
    for i := 0; i < n; i++ {
        if obstacleGrid[0][i] == 1 {
            break
        }
        dp[0][i] = 1
    }
    
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            if obstacleGrid[i][j] == 0 {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
            }
        }
    }
    
    return dp[m - 1][n - 1]
}
```

### Minimum Path Sum

> **é¡Œç›®ï¼š** https://leetcode.com/problems/minimum-path-sum/
> **é›£åº¦ï¼š** Medium
> **æŠ€å·§ï¼š** `DP`
> **èªè¨€ï¼š** Go

* DP
  - è§£æ³•å’Œ Unique Path 87% åƒï¼Œ`dp` å…§æ¯æ ¼å­˜çš„æ˜¯åˆ°é”è©²è™•çš„ minimum path sum

```go
func minPathSum(grid [][]int) int {
    m := len(grid)
    n := len(grid[0])

    dp := make([][]int, m)
    for i := 0; i < m; i++ {
        dp[i] = make([]int, n)
    }

    dp[0][0] = grid[0][0]
    for i := 1; i < m; i++ {
        dp[i][0] = dp[i - 1][0] + grid[i][0]
    }
    for i := 1; i < n; i++ {
        dp[0][i] = dp[0][i - 1] + grid[0][i]
    }

    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = min(dp[i][j - 1] + grid[i][j], dp[i - 1][j] + grid[i][j])
        }
    }

    return dp[m - 1][n - 1]
}
```

### Longest Common Subsequence

> **é¡Œç›®ï¼š** https://leetcode.com/problems/longest-common-subsequence/
> **é›£åº¦ï¼š** Medium
> **æŠ€å·§ï¼š** `DP`
> **èªè¨€ï¼š** Go

äºŒç¶­ DPï¼šè‹¥ char ç›¸åŒå·¦ä¸Šè§’ + 1, å¦å‰‡å·¦é‚Šä¸Šé¢å– max, æœ€å¾Œç­”æ¡ˆåœ¨å³ä¸‹

https://www.youtube.com/watch?v=NnD96abizww

```go
func longestCommonSubsequence(text1 string, text2 string) int {
    m := 1 + len(text2)
    n := 1 + len(text1)
  
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }

    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            if text2[i - 1] == text1[j - 1] {
                dp[i][j] = dp[i - 1][j - 1] + 1
            } else {
                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])
            }
        }
    }

    return dp[m - 1][n - 1]
}
```

### Longest Increasing Subsequence

> **é¡Œç›®ï¼š** https://leetcode.com/problems/longest-increasing-subsequence/
> **é›£åº¦ï¼š** Medium
> **æŠ€å·§ï¼š** `DP`
> **èªè¨€ï¼š** Go

ä¸€ç¶­ DPï¼šBottom-upï¼Œ`dp` slice ä¸­ç¬¬ i å€‹ elementï¼Œä»£è¡¨ `nums` ä¸­ç¬¬ i å€‹ element çµå°¾çš„ LIS é•·åº¦ã€‚

https://www.youtube.com/watch?v=7DKFpWnaxLI

```go
func lengthOfLIS(nums []int) int {
    n := len(nums)
    dp := make([]int, n)

    for i := range dp {
        dp[i] = 1
    }

    for i := 1; i < n; i++ {
        for j := 0; j < i; j++ {
            if nums[j] < nums[i] {
                dp[i] = max(dp[i], dp[j] + 1)
            }
        }
    }

    return max(dp...)
}
```
### Product of Array Except Self

> **é¡Œç›®ï¼š** https://leetcode.com/problems/product-of-array-except-self/
> **é›£åº¦ï¼š** Medium
> **æŠ€å·§ï¼š** `DP`
> **èªè¨€ï¼š** Go

çµ¦ä½ ä¸€å€‹ sliceï¼Œä¾‹å¦‚ï¼šnums = [1,2,3,4]ï¼Œè«‹å›å‚³ [24,12,8,6]ã€‚

1. Bruteforce
   - é¸å®šç¬¬ i å€‹å…ƒç´ ï¼Œè¨ˆç®—å…¶ product of array except self
     - å¾é ­åˆ°å°¾æƒä¸€æ¬¡ï¼Œé‡åˆ°è‡ªå·±å°±è·³é
   - O(N^2)
2. ä¸€ç¶­ DP
   - æº–å‚™å…©å€‹ slice
     - `l`ï¼šè‡ªå·±ä»¥å·¦ï¼ˆä¸å«è‡ªå·±ï¼‰æ‰€æœ‰å…ƒç´ çš„ç©ï¼Œå¦‚ï¼š[1, 1, 2, 6]ï¼Œå¾å·¦åˆ°å³å»º
     - `r`ï¼šè‡ªå·±ä»¥å³ï¼ˆä¸å«è‡ªå·±ï¼‰æ‰€æœ‰å…ƒç´ çš„ç©ï¼Œå¦‚ï¼š[24, 12, 4, 1]ï¼Œå¾å³åˆ°å·¦å»º
   - å°‡ `l` èˆ‡ `r` ç›¸åŒ index çš„å…ƒç´ ä¹˜èµ·ä¾†å°±æ˜¯ç­”æ¡ˆ
   - O(N)

```go
func productExceptSelf(nums []int) []int {
    size := len(nums)

    l := make([]int, size)
    r := make([]int, size)

    l[0] = 1
    r[size - 1] = 1

    // [1, 1, 2, 6]
    for i := 1; i < size; i++ {
        l[i] = l[i - 1] * nums[i - 1]
    }

    // [24, 12, 4, 1]
    for i := size - 2; i >= 0; i-- {
        r[i] = r[i + 1] * nums[i + 1]
    }

    for i := range l {
        l[i] *= r[i]
    }

    return l
}
```

## Simulation

### Spiral Matrix II

> **é¡Œç›®ï¼š** https://leetcode.com/problems/spiral-matrix-ii/
> **é›£åº¦ï¼š** Medium
> **èªè¨€ï¼š** Go

* è¦å¾‹
  - 1x1ï¼š(å³1)
  - 2x2ï¼š(å³1) (ä¸‹1 å·¦1)
  - 3x3ï¼š(å³2) (ä¸‹2 å·¦2) (ä¸Š1 å³1)
  - 4x4ï¼š(å³3) (ä¸‹3 å·¦3) (ä¸Š2 å³2) (ä¸‹1 å·¦1)
  - 5x5ï¼š(å³4) (ä¸‹4 å·¦4) (ä¸Š3 å³3) (ä¸‹2 å·¦2) (ä¸Š1 å³1)
  - 6x6ï¼š...

```go
func generateMatrix(n int) [][]int {
    matrix := make([][]int, n)
    for i := range matrix {
        matrix[i] = make([]int, n)
    }

    row, col := 0, 0
    for i := 1; i <= n; i++ {
        matrix[row][col] = i
        col++
    }
    col--

    i := n + 1
    n2 := int(math.Pow(float64(n), float64(2)))
    dist := n - 1
    for i <= n2 {
        // Down
        for j := 0; j < dist && i <= n2; j, i = j+1, i+1 {
            row++
            matrix[row][col] = i
        }
        // Left
        for j := 0; j < dist && i <= n2; j, i = j+1, i+1 {
            col--
            matrix[row][col] = i
        }

        dist--

        // Up
        for j := 0; j < dist && i <= n2; j, i = j+1, i+1 {
            row--
            matrix[row][col] = i
        }
        // Right
        for j := 0; j < dist && i <= n2; j, i = j+1, i+1 {
            col++
            matrix[row][col] = i
        }

        dist--
    }

    return matrix
}
```

  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2023-04-01 10:37:30" itemprop="dateModified" datetime="2023-04-01T10:37:30+08:00">2023-04-01</time>
  </span>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>Post author:  </strong>aesophor <i class="ic i-at"><em>@</em></i>æ—¥æ–°åˆæ–°
  </li>
  <li class="link">
    <strong>Post link: </strong>
    <a href="https://aesophor.github.io/leetcode/index.html" title="LeetCode åˆ·é¡Œç´€éŒ„">https://aesophor.github.io/leetcode/index.html</a>
  </li>
  <li class="license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
      </div>
      <div class="related panel pjax" data-title="Related">
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="aesophor"
      data-src="/images/avatar.png">
  <p class="name" itemprop="name">aesophor</p>
  <div class="description" itemprop="description">eku</div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">2</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">2</span>
        <span class="name">categories</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">3</span>
        <span class="name">tags</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Flc29waG9y" title="https:&#x2F;&#x2F;github.com&#x2F;aesophor"><i class="ic i-github"></i></span>
      <span class="exturl item instagram" data-url="aHR0cHM6Ly93d3cuaW5zdGFncmFtLmNvbS9hZXNvcGhvci8=" title="https:&#x2F;&#x2F;www.instagram.com&#x2F;aesophor&#x2F;"><i class="ic i-instagram"></i></span>
      <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9hZXNvcGhvcg==" title="https:&#x2F;&#x2F;twitter.com&#x2F;aesophor"><i class="ic i-twitter"></i></span>
      <span class="exturl item linkedin" data-url="aHR0cHM6Ly93d3cubGlua2VkaW4uY29tL2luL2Flc29waG9yLw==" title="https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;aesophor&#x2F;"><i class="ic i-address-card"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>Home</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-user"></i>About</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/about/en-us" rel="section"><i class="ic i-address-card"></i>English</a>
  </li>

        
  <li class="item">
    <a href="/about/zh-tw" rel="section"><i class="ic i-address-card"></i>ä¸­æ–‡</a>
  </li>

  </ul>
        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/leetcode" rel="section"><i class="ic i-magic"></i>LeetCode</a>
  </li>

    
  <li class="item">
    <a href="/leetcode/grind75" rel="section"><i class="ic i-magic"></i>Grind75</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>Random Posts</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Linux/" title="In Linux">Linux</a>
</div>

    <span><a href="/2020/07/20/Arch-Linux-on-MacBook-Pro-11-2-with-Custom-NVMe-M-2-SSD/" title="Arch Linux on MacBook Pro 11,2 with Custom NVMe M.2 SSD">Arch Linux on MacBook Pro 11,2 with Custom NVMe M.2 SSD</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/CTF/" title="In CTF">CTF</a>
</div>

    <span><a href="/2022/08/27/pwnable-tw-secret-garden/" title="[pwnable.tw] Secret Garden (350 pts)">[pwnable.tw] Secret Garden (350 pts)</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>Recent Comments</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2020 â€“ 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">aesophor @ aesophor's Blog</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: 'leetcode/',
    favicon: {
      show: "ï¼ˆâ—Â´3ï½€â—ï¼‰Goooood",
      hide: "(Â´Ğ”ï½€)Booooom"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,fancybox: true,
    copyright: 'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
