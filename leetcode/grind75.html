



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="" href="https://aesophor.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="" href="https://aesophor.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="" href="https://aesophor.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  

<link rel="canonical" href="https://aesophor.github.io/leetcode/grind75">



  <title>LeetCode Grind75 |
aesophor</title>
<meta name="generator" content="Hexo 5.4.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">LeetCode Grind75
  </h1>

          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">aesophor</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
          <img src="https://images.unsplash.com/photo-1533441325263-74682c42d779?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80">
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="page wrap">
    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="en">
  <link itemprop="mainEntityOfPage" href="https://aesophor.github.io/leetcode/grind75.html">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.png">
    <meta itemprop="name" content="aesophor">
    <meta itemprop="description" content="努力不會背叛人，它走不快，但早晚會跟上, eku">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h1 id="Grind-75"><a href="#Grind-75" class="headerlink" title="Grind 75"></a>Grind 75</h1><blockquote>
<p>你得有足够的驱动力强迫自己静下心来，阅读几十页的 Project Handout，理解上千行的代码框架，忍受数个小时的 debug 时光。而这一切，没有学分，没有绩点，没有老师，没有同学，只有一个信念 —— 你在变强。</p>
<p><cite>CSDIY</cite></p>
</blockquote>
<h2 id="Week-1"><a href="#Week-1" class="headerlink" title="Week 1"></a>Week 1</h2><h3 id="Two-Sum"><a href="#Two-Sum" class="headerlink" title="Two Sum"></a>Two Sum</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdHdvLXN1bS8=">https://leetcode.com/problems/two-sum/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>unordered_map</code></p>
</blockquote>
<ul>
<li><p>建一個 map</p>
<ul>
<li>key：num</li>
<li>value：the index of (target - num)</li>
</ul>
</li>
<li><p>掃瞄 nums，對於每個 num ∈ nums</p>
<ul>
<li><p>對於每個 num，用 num 去查詢 complement map</p>
<ul>
<li>若存在，{value, 目前的 index} 就是答案了</li>
<li>不存在，將 {target - num, 目前的 index} 存進去<br>```cpp<br>class Solution {<br>public:<br>vector<int> twoSum(const vector<int> &amp;nums, const int target) {<br>unordered_map&lt;int, int&gt; num_to_complement_idx;</li>
</ul>
<p>for (int i = 0; i &lt; nums.size(); i++) {<br>  const auto it = num_to_complement_idx.find(nums[i]);<br>  if (it != num_to_complement_idx.end()) {</p>
<pre><code>return &#123;i, it-&gt;second&#125;;
</code></pre>
<p>  }<br>  num_to_complement_idx[target - nums[i]] = i;<br>}</p>
<p>return {-1, -1};<br>}<br>};<br>```</p>
</li>
</ul>
</li>
</ul>
<h3 id="Valid-Parentheses"><a href="#Valid-Parentheses" class="headerlink" title="Valid Parentheses"></a>Valid Parentheses</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdmFsaWQtcGFyZW50aGVzZXMv">https://leetcode.com/problems/valid-parentheses/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>stack</code></p>
</blockquote>
<ul>
<li>檢查字串 <code>s</code> 裡括號的合法性<ul>
<li><code>(</code> 不合法</li>
<li><code>([)]</code> 不合法</li>
<li><code>(([]))</code> 合法</li>
</ul>
</li>
</ul>
<pre><code class="cpp">class Solution &#123;
 public:
  bool isValid(const string &amp;s) &#123;
    for (const auto c : s) &#123;
      switch (c) &#123;
      case &#39;(&#39;:
        stack_.push(&#39;)&#39;);
        break;
      case &#39;[&#39;:
        stack_.push(&#39;]&#39;);
        break;
      case &#39;&#123;&#39;:
        stack_.push(&#39;&#125;&#39;);
        break;
      case &#39;)&#39;:
      case &#39;]&#39;:
      case &#39;&#125;&#39;:
        if (stack_.empty() || stack_.top() != c) &#123;
          return false;
        &#125;
        stack_.pop();
        break;
      default:
        return false;
      &#125;
    &#125;

    return stack_.empty();
  &#125;

 private:
  std::stack&lt;char&gt; stack_;
&#125;;
</code></pre>
<h3 id="Merge-Two-Sorted-Lists"><a href="#Merge-Two-Sorted-Lists" class="headerlink" title="Merge Two Sorted Lists"></a>Merge Two Sorted Lists</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWVyZ2UtdHdvLXNvcnRlZC1saXN0cy8=">https://leetcode.com/problems/merge-two-sorted-lists/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>list</code></p>
</blockquote>
<pre><code class="cpp">class Solution &#123;
 public:
  ListNode* mergeTwoLists(ListNode *list1, ListNode *list2) &#123;
    ListNode *head = nullptr;
    ListNode *curr = nullptr;

    while (list1 || list2) &#123;
      ListNode *new_node = nullptr;
      if (list1 &amp;&amp; !list2) &#123;
        new_node = list1;
        list1 = list1-&gt;next;
      &#125; else if (!list1 &amp;&amp; list2) &#123;
        new_node = list2;
        list2 = list2-&gt;next;
      &#125; else &#123;  // list1 &amp;&amp; list2
        if (list1-&gt;val &lt;= list2-&gt;val) &#123;
          new_node = list1;
          list1 = list1-&gt;next;
        &#125; else &#123;
          new_node = list2;
          list2 = list2-&gt;next;
        &#125;
      &#125;

      if (!head) &#123;
        head = new_node;
        curr = new_node;
      &#125; else &#123;
        curr-&gt;next = new_node;
        curr = new_node;
      &#125;
    &#125;

    return head;
  &#125;
&#125;;
</code></pre>
<h3 id="Best-Time-to-Buy-and-Sell-Stock"><a href="#Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="Best Time to Buy and Sell Stock"></a>Best Time to Buy and Sell Stock</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmVzdC10aW1lLXRvLWJ1eS1hbmQtc2VsbC1zdG9jay8=">https://leetcode.com/problems/best-time-to-buy-and-sell-stock/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>array</code> <code>dynamic programming</code></p>
</blockquote>
<ul>
<li>如果將 <code>prices</code> 中每個 price 視為買點，那麼每個買點都會有個最佳賣點<ul>
<li><code>best_sell_prices</code></li>
</ul>
</li>
<li>最佳賣點 = 此點往右（不包含自己）的最大值<ul>
<li>有沒有聞到 &lt;LC&gt; #238 - Product of Array Except Self 的味道？</li>
</ul>
</li>
<li>複雜度：<ul>
<li>Time O(N)</li>
<li>Space O(N)<br>```cpp<br>// best_sell_prices: [6,6,6,6,4,0]<br>// input:            [7,1,5,3,6,4]</li>
</ul>
</li>
</ul>
<p>// best_sell_prices: [6,4,3,1,0]<br>// input:            [7,6,4,3,1]</p>
<p>class Solution {<br> public:<br>  int maxProfit(const vector<int> &amp;prices) {<br>    vector<int> best_sell_prices(prices.size(), 0);<br>    for (int i = prices.size() - 2; i &gt;= 0; i–) {<br>      best_sell_prices[i] = std::max(prices[i + 1], best_sell_prices[i + 1]);<br>    }</p>
<pre><code>int max_profit = 0;
for (int i = 0; i &lt; prices.size(); i++) &#123;
  max_profit = std::max(max_profit, best_sell_prices[i] - prices[i]);
&#125;
return max_profit;
</code></pre>
<p>  }<br>};</p>
<pre><code>
* 上面的邏輯再稍微 distill 一下
  - Time O(N)
  - Space O(1)
```cpp
class Solution &#123;
 public:
  int maxProfit(const vector&lt;int&gt; &amp;prices) &#123;
    int best_sell_price = 0;
    int max_profit = 0;

    for (int i = prices.size() - 2; i &gt;= 0; i--) &#123;
      best_sell_price = std::max(best_sell_price, prices[i + 1]);
      max_profit = std::max(max_profit, best_sell_price - prices[i]);
    &#125;

    return max_profit;
  &#125;
&#125;;
</code></pre>
<h3 id="Valid-Palindrome"><a href="#Valid-Palindrome" class="headerlink" title="Valid Palindrome"></a>Valid Palindrome</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdmFsaWQtcGFsaW5kcm9tZS8=">https://leetcode.com/problems/valid-palindrome/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>two pointers</code></p>
</blockquote>
<pre><code class="cpp">class Solution &#123;
 public:
  bool isPalindrome(const string &amp;s) &#123;
    int l = 0;
    int r = s.size() - 1;

    while (l &lt; r) &#123;
      if (!isalnum(s[l])) &#123;
        l++;
        continue;
      &#125;
      if (!isalnum(s[r])) &#123;
        r--;
        continue;
      &#125;
      if (std::tolower(s[l]) != std::tolower(s[r])) &#123;
        return false;
      &#125;
      l++;
      r--;
    &#125;

    return true;
  &#125;
&#125;;
</code></pre>
<h3 id="Invert-Binary-Tree"><a href="#Invert-Binary-Tree" class="headerlink" title="Invert Binary Tree"></a>Invert Binary Tree</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaW52ZXJ0LWJpbmFyeS10cmVlLw==">https://leetcode.com/problems/invert-binary-tree/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>binary tree</code> <code>recursion</code></p>
</blockquote>
<pre><code class="cpp">class Solution &#123;
 public:
  TreeNode* invertTree(TreeNode* root) &#123;
    if (!root) &#123;
      return nullptr;
    &#125;
    
    std::swap(root-&gt;left, root-&gt;right);   
    invertTree(root-&gt;left);
    invertTree(root-&gt;right);
    return root;
  &#125;
&#125;;
</code></pre>
<h3 id="Valid-Anagram"><a href="#Valid-Anagram" class="headerlink" title="Valid Anagram"></a>Valid Anagram</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdmFsaWQtYW5hZ3JhbS8=">https://leetcode.com/problems/valid-anagram/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>unordered_map</code></p>
</blockquote>
<ul>
<li><p>anagram 的定義：同字母異序字、重組字、變位字</p>
</li>
<li><p>用 unordered_map 紀錄各個字母出現的頻率，任何一個字的頻率不對就 return false</p>
</li>
<li><p>長度不一樣就不用比了，肯定不是 anagram</p>
<pre><code class="cpp">class Solution &#123;
public:
bool isAnagram(string s, string t) &#123;
  if (s.size() != t.size()) &#123;
    return false;
  &#125;

  std::unordered_map&lt;char, int&gt; char_freqs;
  for (const auto c : s) &#123;
    char_freqs[c]++;
  &#125;

  for (const auto c : t) &#123;
    auto it = char_freqs.find(c);
    if (it == char_freqs.end()) &#123;
      return false;
    &#125;

    if (--it-&gt;second == 0) &#123;
      char_freqs.erase(it);
    &#125;
  &#125;

  return true;
&#125;
&#125;;
</code></pre>
</li>
</ul>
<h3 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmluYXJ5LXNlYXJjaC8=">https://leetcode.com/problems/binary-search/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>binary search</code></p>
</blockquote>
<pre><code class="cpp">class Solution &#123;
 public:
  int search(const vector&lt;int&gt; &amp;nums, const int target) &#123;
    int l = 0;
    int r = nums.size() - 1; 
    int m;

    while (l &lt;= r) &#123;
      m = l + (r - l) / 2;
      if (nums[m] == target) &#123;
        return m;
      &#125; else if (nums[m] &lt; target) &#123;
        l = m + 1;
      &#125; else &#123;  // nums[m] &gt; target
        r = m - 1;
      &#125;
    &#125;

    return -1;
  &#125;
&#125;;
</code></pre>
<h3 id="Flood-Fill"><a href="#Flood-Fill" class="headerlink" title="Flood Fill"></a>Flood Fill</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvZmxvb2QtZmlsbC8=">https://leetcode.com/problems/flood-fill/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>matrix</code> <code>single-source bfs</code></p>
</blockquote>
<ul>
<li><p>小畫家的 paint bucket/fill tool</p>
</li>
<li><p>Single-source matrix bfs</p>
</li>
<li><p>BFS 過程中，記得不要走出界，也不要走到不是原本顏色的 pixel</p>
<pre><code class="cpp">class Solution &#123;
public:
vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt; &amp;image,
                              const int sr,
                              const int sc,
                              const int new_color) &#123;
  const int old_color = image[sr][sc]; 
  if (old_color == new_color) &#123;
    return image;
  &#125;
  
  std::queue&lt;std::pair&lt;int, int&gt;&gt; q;
  q.push(&#123;sr, sc&#125;);
  while (q.size()) &#123;
    const auto [r, c] = q.front();
    q.pop();

    image[r][c] = new_color;

    if (r - 1 &gt;= 0 &amp;&amp; image[r - 1][c] == old_color) &#123;
      q.push(&#123;r - 1, c&#125;);
    &#125;
    if (r + 1 &lt; image.size() &amp;&amp; image[r + 1][c] == old_color) &#123;
      q.push(&#123;r + 1, c&#125;);
    &#125;
    if (c - 1 &gt;= 0 &amp;&amp; image[r][c - 1] == old_color) &#123;
      q.push(&#123;r, c - 1&#125;);
    &#125;
    if (c + 1 &gt;= 0 &amp;&amp; image[r][c + 1] == old_color) &#123;
      q.push(&#123;r, c + 1&#125;);
    &#125;
  &#125;

  return image;
&#125;
&#125;;
</code></pre>
</li>
</ul>
<h3 id="Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="Lowest Common Ancestor of a Binary Search Tree"></a>Lowest Common Ancestor of a Binary Search Tree</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbG93ZXN0LWNvbW1vbi1hbmNlc3Rvci1vZi1hLWJpbmFyeS1zZWFyY2gtdHJlZS8=">https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>binary-search-tree</code></p>
</blockquote>
<p>第一次寫的時候沒注意到有 binary search tree 的 sorted property 可以利用，所以寫了一個 generic binary tree 的 solution。</p>
<p>題目給你一棵 BST，然後給你 BST 中的兩個 tree node <code>p, q</code>，要你找出它們的 lowest common ancestor (grandparent node)，並且自己也算是自己的 ancestor。</p>
<ul>
<li>如果 current node <code>root</code> 比兩個 target nodes <code>p, q</code> 小，就往 right subtree 找</li>
<li>如果 current node <code>root</code> 比兩個 target nodes <code>p, q</code> 大，就往 left subtree 找</li>
<li>如果 current node <code>root</code> 和 <code>p, q</code> 相比是一大一小，代表 <code>p, q</code> 必定在自己下面的一左一右。</li>
</ul>
<pre><code class="cpp">class Solution &#123;
 public:
  TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) &#123;
    // Remember to exploit the property of a binary search tree! :-^)
    if (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) &#123;
      return lowestCommonAncestor(root-&gt;right, p, q);
    &#125; else if (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) &#123;
      return lowestCommonAncestor(root-&gt;left, p, q);
    &#125; else &#123;
      return root;
    &#125;
  &#125;
&#125;;
</code></pre>
<h3 id="Balanced-Binary-Tree"><a href="#Balanced-Binary-Tree" class="headerlink" title="Balanced Binary Tree"></a>Balanced Binary Tree</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmFsYW5jZWQtYmluYXJ5LXRyZWUv">https://leetcode.com/problems/balanced-binary-tree/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>binary-tree</code> <code>dfs</code></p>
</blockquote>
<p>每一個 node 都去找它左右子樹的深度，深度的差只能是 0 或 1，不能是 2 (含) 以上。</p>
<pre><code class="cpp">class Solution &#123;
 public:
  bool isBalanced(TreeNode *root) &#123;
    getDepth(root);
    return is_balanced_;
  &#125;

 private:
  int getDepth(TreeNode *node) &#123;
    if (!node) &#123;
      return 0;
    &#125;

    int l_depth = getDepth(node-&gt;left);
    int r_depth = getDepth(node-&gt;right);
    is_balanced_ &amp;= std::abs(l_depth - r_depth) &lt;= 1;
    return std::max(l_depth, r_depth) + 1;
  &#125;
  
  bool is_balanced_ = true;
&#125;;
</code></pre>
<h3 id="Linked-List-Cycle"><a href="#Linked-List-Cycle" class="headerlink" title="Linked List Cycle"></a>Linked List Cycle</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbGlua2VkLWxpc3QtY3ljbGUv">https://leetcode.com/problems/linked-list-cycle/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>two pointers</code></p>
</blockquote>
<p>Fast &amp; Slow Pointers</p>
<ul>
<li><p>如果 linked list 沒 cycle 的話，while loop 必定能走完，最終回傳 false</p>
</li>
<li><p>如果 linked list 有 cycle 的話，while loop 必定無窮迴圈</p>
<ul>
<li><p>讓 fast pointer 一次走兩步</p>
</li>
<li><p>讓 slow pointer 一次走一步</p>
</li>
<li><p>如果有 cycle 的話，有朝一日 fast pointer 和 slow pointer 必會相等</p>
<pre><code class="cpp">class Solution &#123;
public:
bool hasCycle(ListNode *head) &#123;
ListNode *fast = head;
ListNode *slow = head;

while (fast &amp;&amp; slow) &#123;
  fast = fast-&gt;next;
  if (!fast) &#123;
    return false;
  &#125;
  fast = fast-&gt;next;
  slow = slow-&gt;next;

  if (fast == slow) &#123;
    return true;
  &#125;
&#125;

return false;
&#125;
&#125;;
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="Implement-Queue-using-Stacks"><a href="#Implement-Queue-using-Stacks" class="headerlink" title="Implement Queue using Stacks"></a>Implement Queue using Stacks</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaW1wbGVtZW50LXF1ZXVlLXVzaW5nLXN0YWNrcy8=">https://leetcode.com/problems/implement-queue-using-stacks/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>stack</code></p>
</blockquote>
<p>開一個 stack，存放資料</p>
<ul>
<li><p>push() - 直接 push 到這個 stack 裡面就行了</p>
</li>
<li><p>pop() - 開一個 tmp stack</p>
<ul>
<li>將原本的 stack 的資料一個一個 pop 出來然後 push 進 tmp stack，然後返回 tmp stack 的 top element</li>
<li>記得再把 tmp stack 的東西倒回原本的 stack<br>```cpp<br>class MyQueue {<br>public:<br>MyQueue() : stack_() {}</li>
</ul>
<p>void push(int x) {<br>  stack_.push(x);<br>}</p>
<p>int pop() {<br>  std::stack<int> tmp_stack;<br>  while (stack_.size()) {</p>
<pre><code>tmp_stack.push(stack_.top());
stack_.pop();
</code></pre>
<p>  }</p>
<p>  int ret = tmp_stack.top();<br>  tmp_stack.pop();<br>  while (tmp_stack.size()) {</p>
<pre><code>stack_.push(tmp_stack.top());
tmp_stack.pop();
</code></pre>
<p>  }</p>
<p>  return ret;<br>}</p>
<p>int peek() {<br>  std::stack<int> tmp_stack;<br>  while (stack_.size()) {</p>
<pre><code>tmp_stack.push(stack_.top());
stack_.pop();
</code></pre>
<p>  }</p>
<p>  int ret = tmp_stack.top();<br>  while (tmp_stack.size()) {</p>
<pre><code>stack_.push(tmp_stack.top());
tmp_stack.pop();
</code></pre>
<p>  }</p>
<p>  return ret;<br>}</p>
<p>bool empty() {<br>  return stack_.empty();<br>}</p>
</li>
</ul>
<p> private:<br>  std::stack<int> stack_;<br>};</p>
<p>/**</p>
<ul>
<li>Your MyQueue object will be instantiated and called as such:</li>
<li>MyQueue* obj = new MyQueue();</li>
<li>obj-&gt;push(x);</li>
<li>int param_2 = obj-&gt;pop();</li>
<li>int param_3 = obj-&gt;peek();</li>
<li>bool param_4 = obj-&gt;empty();</li>
<li>/<br>```</li>
</ul>
<h2 id="Week-2"><a href="#Week-2" class="headerlink" title="Week 2"></a>Week 2</h2><h3 id="First-Bad-Version"><a href="#First-Bad-Version" class="headerlink" title="First Bad Version"></a>First Bad Version</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvZmlyc3QtYmFkLXZlcnNpb24v">https://leetcode.com/problems/first-bad-version/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>binary search</code></p>
</blockquote>
<pre><code class="cpp">// The API isBadVersion is defined for you.
// bool isBadVersion(int version);

class Solution &#123;
 public:
  int firstBadVersion(int n) &#123;
    int l = 0;
    int r = n;
    int m;

    while (l &lt;= r) &#123;
      m = l + (r - l) / 2;
      if (isBadVersion(m)) &#123;
        r = m - 1;
      &#125; else &#123;
        l = m + 1;
      &#125;
    &#125;

    return l;
  &#125;
&#125;;
</code></pre>
<h3 id="Ransom-Note"><a href="#Ransom-Note" class="headerlink" title="Ransom Note"></a>Ransom Note</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcmFuc29tLW5vdGUv">https://leetcode.com/problems/ransom-note/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>unordered_map</code></p>
</blockquote>
<p>問你 magazine 裡面的字母是否為 ransomNote 的 superset, 必須考量字母頻率。</p>
<pre><code class="cpp">class Solution &#123;
 public:
  bool canConstruct(const string &amp;ransomNote, const string &amp;magazine) &#123;
    std::unordered_map&lt;char, int&gt; char_freqs;
    for (const auto c : magazine) &#123;
      char_freqs[c]++;
    &#125;

    for (const auto c : ransomNote) &#123;
      auto it = char_freqs.find(c);
      if (it == char_freqs.end()) &#123;
        return false;
      &#125;

      it-&gt;second--;
      if (it-&gt;second == 0) &#123;
        char_freqs.erase(it);
      &#125;
    &#125;

    return true;
  &#125;
&#125;;
</code></pre>
<h3 id="Climbing-Stairs"><a href="#Climbing-Stairs" class="headerlink" title="Climbing Stairs"></a>Climbing Stairs</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY2xpbWJpbmctc3RhaXJzLw==">https://leetcode.com/problems/climbing-stairs/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>dynamic programming</code> <code>bottom up</code></p>
</blockquote>
<pre><code class="cpp">class Solution &#123;
 public:
  int climbStairs(int n) &#123;
    uint64_t dp[50] = &#123;0, 1, 2&#125;;
    for (int i = 3; i &lt; 50; i++) &#123;
      dp[i] = dp[i - 1] + dp[i - 2];
    &#125;
    return dp[n];
  &#125;
&#125;;
</code></pre>
<h3 id="Longest-Palindrome"><a href="#Longest-Palindrome" class="headerlink" title="Longest Palindrome"></a>Longest Palindrome</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbG9uZ2VzdC1wYWxpbmRyb21lLw==">https://leetcode.com/problems/longest-palindrome/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>unordered_map</code></p>
</blockquote>
<pre><code class="cpp">class Solution &#123;
 public:
  int longestPalindrome(const string &amp;s) &#123;
    std::unordered_map&lt;char, int&gt; char_freqs;
    for (const auto c : s) &#123;
      char_freqs[c]++;
    &#125;

    int len = std::any_of(char_freqs.begin(),
                          char_freqs.end(),
                          [](const std::pair&lt;char, int&gt; &amp;entry) &#123;
                            return entry.second % 2 == 1;
                          &#125;);
    for (const auto &amp;[c, f] : char_freqs) &#123;
      len += 2 * (f / 2);
    &#125;
    return len;
  &#125;
&#125;;
</code></pre>
<h3 id="Reverse-Linked-List"><a href="#Reverse-Linked-List" class="headerlink" title="Reverse Linked List"></a>Reverse Linked List</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcmV2ZXJzZS1saW5rZWQtbGlzdC8=">https://leetcode.com/problems/reverse-linked-list/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>linked list</code></p>
</blockquote>
<ul>
<li>Iterative solution<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1XMUJMR2dXWmhLOA==">https://www.youtube.com/watch?v=W1BLGgWZhK8</span></li>
</ul>
</li>
<li>Recursive solution<ul>
<li>將自己下一個 node 指向自己</li>
<li>回傳 new head! 回傳 new head! 回傳 new head!<br>```cpp<br>class Solution {<br>public:<br>ListNode *reverseList(ListNode *head) {<br>return reverseListRecursively(head);<br>}</li>
</ul>
</li>
</ul>
<p> private:<br>  ListNode *reverseListIteratively(ListNode *head) {<br>    if (!head) {<br>      return nullptr;<br>    }</p>
<pre><code>ListNode *new_head = nullptr;
ListNode *next = nullptr;

while (head) &#123;
  next = head-&gt;next;
  head-&gt;next = new_head;
  new_head = head;
  head = next;
&#125;

return new_head;
</code></pre>
<p>  }</p>
<p>  ListNode *reverseListRecursively(ListNode *head) {<br>    if (!head || !head-&gt;next) {<br>      return head;<br>    }</p>
<pre><code>ListNode *new_head = reverseListRecursively(head-&gt;next);
head-&gt;next-&gt;next = head;
head-&gt;next = nullptr;
return new_head;
</code></pre>
<p>  }<br>};</p>
<pre><code>
### Majority Element
&gt; **題目：** https://leetcode.com/problems/majority-element/
&gt; **難度：** Easy
&gt; **語言：** C++17
&gt; **技巧：** `sorting`

給你一串 unsorted 的數字，並且裡面有某個數字的出現頻率必定超過總數的一半，請找出該數字為何。
```cpp
//              -------
// odd:  &#123;0, 1, 2, 3, 4&#125;  =&gt; 5 / 2 = 2
//        -------
//           -------
// even: &#123;0, 1, 2, 3&#125;     =&gt; 4 / 2 = 2
//        -------
class Solution &#123;
 public:
  int majorityElement(vector&lt;int&gt;&amp; nums) &#123;
    std::sort(nums.begin(), nums.end());
    return nums[nums.size() / 2];
  &#125;
&#125;;
</code></pre>
<h3 id="Diameter-of-Binary-Tree"><a href="#Diameter-of-Binary-Tree" class="headerlink" title="Diameter of Binary Tree"></a>Diameter of Binary Tree</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvZGlhbWV0ZXItb2YtYmluYXJ5LXRyZWUv">https://leetcode.com/problems/diameter-of-binary-tree/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>binary tree</code> <code>dfs</code></p>
</blockquote>
<pre><code class="cpp">class Solution &#123;
 public:
  int diameterOfBinaryTree(TreeNode *root) &#123;
    getDepth(root);
    return max_diameter_;
  &#125;

 private:
  int getDepth(TreeNode *node) &#123;
    if (!node) &#123;
      return 0;
    &#125;

    int l_depth = getDepth(node-&gt;left);
    int r_depth = getDepth(node-&gt;right);
    max_diameter_ = std::max(max_diameter_, l_depth + r_depth);
    return std::max(l_depth, r_depth) + 1;
  &#125;

  int max_diameter_ = 0;
&#125;;
</code></pre>
<h3 id="Add-Binary"><a href="#Add-Binary" class="headerlink" title="Add Binary"></a>Add Binary</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYWRkLWJpbmFyeS8=">https://leetcode.com/problems/add-binary/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>string</code> <code>bit manipulation</code></p>
</blockquote>
<pre><code class="cpp">class Solution &#123;
 public:
  string addBinary(string a, string b) &#123;
    bool carry = false;
    int digit = 0;
    int i = 0;
    int j = 0;
    string result;

    std::reverse(a.begin(), a.end());
    std::reverse(b.begin(), b.end());

    while (i &lt; a.size() || j &lt; b.size() || carry) &#123;
      digit = carry;
      if (i &lt; a.size()) &#123;
        digit += a[i] - &#39;0&#39;;
        i++;
      &#125;
      if (j &lt; b.size()) &#123;
        digit += b[j] - &#39;0&#39;;
        j++;
      &#125;
      result.push_back(&#39;0&#39; + digit % 2);
      carry = digit &gt; 1;
    &#125;

    std::reverse(result.begin(), result.end());
    return result; 
  &#125;
&#125;;
</code></pre>
<h3 id="Middle-of-the-Linked-List"><a href="#Middle-of-the-Linked-List" class="headerlink" title="Middle of the Linked List"></a>Middle of the Linked List</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWlkZGxlLW9mLXRoZS1saW5rZWQtbGlzdC8=">https://leetcode.com/problems/middle-of-the-linked-list/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>linked list</code> <code>two pointers</code></p>
</blockquote>
<p>快慢指標，走完 <code>slow</code> 就是答案。</p>
<p>有個 edge case 要特別注意，就是當 list size 為奇數時，快指標走到最後一個節點就要提早 break loop 了。</p>
<p>面試時可以自己簡單拿 odd &amp; even size 的兩條 linked lists 自己驗證一下，就不會漏掉這個 case 了。</p>
<pre><code class="cpp">class Solution &#123;
 public:
  ListNode *middleNode(ListNode *head) &#123;
    ListNode *fast = head;
    ListNode *slow = head;

    while (fast &amp;&amp; slow &amp;&amp; fast-&gt;next) &#123;
      fast = fast-&gt;next;
      if (fast) &#123;
        fast = fast-&gt;next;
      &#125;
      slow = slow-&gt;next;
    &#125;

    return slow;
  &#125;
&#125;;
</code></pre>
<h3 id="Maximum-Depth-of-Binary-Tree"><a href="#Maximum-Depth-of-Binary-Tree" class="headerlink" title="Maximum Depth of Binary Tree"></a>Maximum Depth of Binary Tree</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWF4aW11bS1kZXB0aC1vZi1iaW5hcnktdHJlZS8=">https://leetcode.com/problems/maximum-depth-of-binary-tree/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>binary tree</code> <code>dfs</code></p>
</blockquote>
<pre><code class="cpp">class Solution &#123;
 public:
  int maxDepth(TreeNode *root) &#123;
    getDepth(root);
    return max_depth_;
  &#125;

 private:
  int getDepth(TreeNode *node) &#123;
    if (!node) &#123;
      return 0;
    &#125;

    int l_depth = getDepth(node-&gt;left);
    int r_depth = getDepth(node-&gt;right);
    int current_depth = std::max(l_depth, r_depth) + 1;
    max_depth_ = std::max(max_depth_, current_depth);
    return current_depth;
  &#125;

  int max_depth_ = 0;
&#125;;
</code></pre>
<h3 id="Contains-Duplicate"><a href="#Contains-Duplicate" class="headerlink" title="Contains Duplicate"></a>Contains Duplicate</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY29udGFpbnMtZHVwbGljYXRlLw==">https://leetcode.com/problems/contains-duplicate/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>unordered_set</code></p>
</blockquote>
<pre><code class="cpp">class Solution &#123;
 public:
  bool containsDuplicate(const vector&lt;int&gt; &amp;nums) &#123;
    std::unordered_set&lt;int&gt; appeared; 

    for (const auto n : nums) &#123;
      if (appeared.find(n) != appeared.end()) &#123;
        return true;
      &#125;
      appeared.emplace(n);
    &#125;

    return false;
  &#125;
&#125;;
</code></pre>
<h3 id="Maximum-Subarray"><a href="#Maximum-Subarray" class="headerlink" title="Maximum Subarray"></a>Maximum Subarray</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWF4aW11bS1zdWJhcnJheS8=">https://leetcode.com/problems/maximum-subarray/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>dynamic programming</code> <code>kadane</code></p>
</blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0Byc2luZ2hhbDc1Ny9rYWRhbmVzLWFsZ29yaXRobS1keW5hbWljLXByb2dyYW1taW5nLWhvdy1hbmQtd2h5LWRvZXMtaXQtd29yay0zZmQ4ODQ5ZWQ3M2Q=">https://medium.com/@rsinghal757/kadanes-algorithm-dynamic-programming-how-and-why-does-it-work-3fd8849ed73d</span></p>
<pre><code class="cpp">class Solution &#123;
 public:
  int maxSubArray(const vector&lt;int&gt; &amp;nums) &#123;
    int global_max = std::numeric_limits&lt;int&gt;::lowest();
    int local_max = 0;

    for (const auto n : nums) &#123;
      local_max = std::max(n, local_max + n);
      global_max = std::max(global_max, local_max);
    &#125;
    return global_max;
  &#125;
&#125;;
</code></pre>
<h2 id="Week-3"><a href="#Week-3" class="headerlink" title="Week 3"></a>Week 3</h2><h3 id="Merge-Intervals"><a href="#Merge-Intervals" class="headerlink" title="Merge Intervals"></a>Merge Intervals</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWVyZ2UtaW50ZXJ2YWxzLw==">https://leetcode.com/problems/merge-intervals/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>array</code> <code>interval</code></p>
</blockquote>
<ul>
<li><p>因為測資會有 unsorted intervals，所以要先對 intervals 根據左界進行 ascending 排序</p>
</li>
<li><p>掃一次 intervals</p>
<ul>
<li><p>與 last merged interval 無 overlap：就直接 append</p>
</li>
<li><p>與 last merged interval 有 overlap：更新右界，看是原本的大，還是新的大</p>
<pre><code class="cpp">class Solution &#123;
public:
vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt; &amp;intervals) &#123;
std::sort(intervals.begin(),
          intervals.end(),
          [](const auto &amp;i1, const auto &amp;i2) &#123;
            if (i1[0] &lt; i2[0]) return true;
            if (i1[0] &gt; i2[0]) return false;
            if (i1[1] &lt; i2[1]) return true;
            if (i1[1] &gt; i2[1]) return false;
            return false;
          &#125;);

std::vector&lt;std::vector&lt;int&gt;&gt; ret;
for (int i = 0; i &lt; intervals.size(); i++) &#123;
  const auto &amp;interval = intervals[i];
  if (ret.empty() || ret.back()[1] &lt; interval[0]) &#123;  // not overlapped
    ret.emplace_back(interval);
  &#125; else &#123;  // overlapped
    ret.back()[1] = std::max(ret.back()[1], interval[1]);
  &#125;
&#125;
return ret;
&#125;
&#125;;
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="Insert-Interval"><a href="#Insert-Interval" class="headerlink" title="Insert Interval"></a>Insert Interval</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaW5zZXJ0LWludGVydmFsLw==">https://leetcode.com/problems/insert-interval/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>array</code> <code>interval</code></p>
</blockquote>
<ol>
<li><p>暴力解：</p>
<ul>
<li>將 <code>new_interval</code> append 到 <code>intervals</code> 並根據左界進行 ascending sort</li>
<li>將此問題 reduce 成 Merge Intervals</li>
</ul>
</li>
<li><p>比較有效率的解法：</p>
<ul>
<li>從頭掃描 intervals<ul>
<li>若與 <code>new_interval</code> 無 overlapped，直接 append 到 <code>ret</code></li>
<li>若與 <code>new_interval</code> 有 overlapped，確認目前掃描到的 <code>interval</code> 與 <code>new_interval</code> 融合後的左右界</li>
</ul>
</li>
<li>將 <code>new_interval</code> append 到 <code>ret</code></li>
<li>從剛剛掃描暫停的地方繼續，往後掃完 <code>intervals</code> 剩餘的部分<ul>
<li>因為不確定 <code>new_interval</code> 所橫跨的範圍多大，故此部分的邏輯同 Merge Intervals 的解法<br>```cpp<br>class Solution {<br>public:<br>vector&lt;vector<int>&gt; insert(vector&lt;vector<int>&gt; &amp;intervals,<pre><code>                  vector&lt;int&gt; &amp;new_interval) &#123;
</code></pre>
std::vector&lt;std::vector<int>&gt; ret;<br>int i = 0;</li>
</ul>
</li>
</ul>
<p> for (; i &lt; intervals.size(); i++) {<br>   const auto &amp;interval = intervals[i];<br>   if (new_interval[0] &lt;= interval[1]) {  // overlapped</p>
<pre><code> new_interval[0] = std::min(new_interval[0], interval[0]);
 break;
</code></pre>
<p>   }<br>   ret.emplace_back(interval);<br> }</p>
<p> ret.emplace_back(new_interval);</p>
<p> for (; i &lt; intervals.size(); i++) {<br>   const auto &amp;interval = intervals[i];<br>   if (ret.back()[1] &lt; interval[0]) {  // not overlapped</p>
<pre><code> ret.emplace_back(interval);
</code></pre>
<p>   } else {  // overlapped</p>
<pre><code> ret.back()[1] = std::max(ret.back()[1], interval[1]);
</code></pre>
<p>   }<br> }</p>
<p> return ret;<br>}<br>};<br>```</p>
</li>
</ol>
<h3 id="01-Matrix"><a href="#01-Matrix" class="headerlink" title="01 Matrix"></a>01 Matrix</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtbGV2ZWwtb3JkZXItdHJhdmVyc2FsLw==">https://leetcode.com/problems/binary-tree-level-order-traversal/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>matrix</code> <code>multi-source bfs</code></p>
</blockquote>
<ol>
<li><p>解法一：對 <code>mat</code> 中每個 1 做 BFS，找到最近的 0 的距離後填入 <code>ret</code> 中 =&gt; TLE</p>
</li>
<li><p>解法二：從 <code>mat</code> 中所有 0 同時做 BFS，平行擴散。第一個到達 1 者，當下的 <code>dist</code> 就是該點和它最近的 0 的距離。<br>```cpp<br>// 解法一 (TLE)<br>class Solution {<br>public:<br>vector&lt;vector<int>&gt; updateMatrix(const vector&lt;vector<int>&gt; &amp;mat) {<br> const int m = mat.size();<br> const int n = mat[0].size();</p>
<p> vector&lt;vector<int>&gt; ret(m);<br> for (auto &amp;row : ret) {<br>   row = vector<int>(n);<br> }</p>
<p> for (int i = 0; i &lt; m; i++) {<br>   for (int j = 0; j &lt; n; j++) {</p>
<pre><code> ret[i][j] = bfs(mat, m, n, i, j);
</code></pre>
<p>   }<br> }<br> return ret;<br>}</p>
</li>
</ol>
<p> private:<br>  int bfs(const vector&lt;vector<int>&gt; &amp;mat,<br>          const int m,<br>          const int n,<br>          const int sr,<br>          const int sc) {<br>    if (mat[sr][sc] == 0) {<br>      return 0;<br>    }</p>
<pre><code>vector&lt;vector&lt;bool&gt;&gt; visited(m);
for (auto &amp;row : visited) &#123;
  row = vector&lt;bool&gt;(n, false);
&#125;

int dist = 0;
queue&lt;pair&lt;int, int&gt;&gt; q;
q.push(&#123;sr, sc&#125;);
while (q.size()) &#123;
  int len = q.size();
  for (int i = 0; i &lt; len; i++) &#123;
    const auto [r, c] = q.front();
    q.pop();

    if (mat[r][c] == 0) &#123;
      return dist;
    &#125;
    visited[r][c] = true;

    if (r - 1 &gt;= 0 &amp;&amp; !visited[r - 1][c]) &#123;
      q.push(&#123;r - 1, c&#125;);
    &#125;
    if (r + 1 &lt; mat.size() &amp;&amp; !visited[r + 1][c]) &#123;
      q.push(&#123;r + 1, c&#125;);
    &#125;
    if (c - 1 &gt;= 0 &amp;&amp; !visited[r][c - 1]) &#123;
      q.push(&#123;r, c - 1&#125;);
    &#125;
    if (c + 1 &lt; mat[0].size() &amp;&amp; !visited[r][c + 1]) &#123;
      q.push(&#123;r, c + 1&#125;);
    &#125;
  &#125;
  dist++;
&#125;

return -1;  // shouldn&#39;t have reached here.
</code></pre>
<p>  }<br>};</p>
<pre><code>
```cpp
// 解法二 (AC)
class Solution &#123;
 public:
  vector&lt;vector&lt;int&gt;&gt; updateMatrix(const vector&lt;vector&lt;int&gt;&gt; &amp;mat) &#123;
    const int uninitialized = std::numeric_limits&lt;int&gt;::max();
    const int m = mat.size();
    const int n = mat[0].size();

    vector&lt;vector&lt;int&gt;&gt; ret(m);
    for (auto &amp;row : ret) &#123;
      row = vector&lt;int&gt;(n, 0);
    &#125;

    queue&lt;pair&lt;int, int&gt;&gt; q;
    for (int i = 0; i &lt; m; i++) &#123;
      for (int j = 0; j &lt; n; j++) &#123;
        if (mat[i][j] == 0) &#123;
          ret[i][j] = 0;
          q.push(&#123;i, j&#125;);
        &#125; else &#123;
          ret[i][j] = uninitialized;
        &#125;
      &#125;
    &#125;

    int dist = 0;
    while (q.size()) &#123;
      int len = q.size();
      for (int i = 0; i &lt; len; i++) &#123;
        const auto [r, c] = q.front();
        q.pop();

        if (ret[r][c] == uninitialized) &#123;
          ret[r][c] = dist;
        &#125;

        if (r - 1 &gt;= 0 &amp;&amp; ret[r - 1][c] == uninitialized) &#123;
          q.push(&#123;r - 1, c&#125;);
        &#125;
        if (r + 1 &lt; m &amp;&amp; ret[r + 1][c] == uninitialized) &#123;
          q.push(&#123;r + 1, c&#125;);
        &#125;
        if (c - 1 &gt;= 0 &amp;&amp; ret[r][c - 1] == uninitialized) &#123;
          q.push(&#123;r, c - 1&#125;);
        &#125;
        if (c + 1 &lt; n &amp;&amp; ret[r][c + 1] == uninitialized) &#123;
          q.push(&#123;r, c + 1&#125;);
        &#125;
      &#125;
      dist++;
    &#125;

    return ret;
  &#125;
&#125;;
</code></pre>
<h3 id="K-Closest-Points-to-Origin"><a href="#K-Closest-Points-to-Origin" class="headerlink" title="K Closest Points to Origin"></a>K Closest Points to Origin</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvay1jbG9zZXN0LXBvaW50cy10by1vcmlnaW4v">https://leetcode.com/problems/k-closest-points-to-origin/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>sorting</code> <code>priority_queue</code></p>
</blockquote>
<ol>
<li>解法一：計算各點和 (0, 0) 的歐式距離後以之進行升冪排序，取前 k 個點回傳。</li>
<li>解法二：使用 max heap<ul>
<li>各個點進入 priority queue 的時候，自動按歐式距離降冪排序</li>
<li>priority queue size 大於 k 的時候，front 會是歐式距離最大的點，將它 pop 掉，讓 size 維持在 <code>&lt;= k</code></li>
</ul>
</li>
<li>解法三：使用 min heap<ul>
<li>各個點進入 priority queue 的時候，自動按歐式距離升冪排序</li>
<li>最後 pop k 次，放入 <code>ret</code> 中並回傳之。</li>
</ul>
</li>
</ol>
<pre><code class="cpp">class Solution &#123;
 public:
  vector&lt;vector&lt;int&gt;&gt; kClosest(vector&lt;vector&lt;int&gt;&gt; &amp;points, int k) &#123;
    return kClosestMaxHeap(points, k);
  &#125;

 private:
  vector&lt;vector&lt;int&gt;&gt; kClosestSorting(vector&lt;vector&lt;int&gt;&gt; &amp;points, int k) &#123;
    std::sort(points.begin(),
              points.end(),
              [](const vector&lt;int&gt; &amp;p1, const vector&lt;int&gt; &amp;p2) &#123;
                return std::hypotf(p1[0], p1[1]) &lt; std::hypotf(p2[0], p2[1]);
              &#125;);

    return vector(points.begin(), points.begin() + k);
  &#125;

  vector&lt;vector&lt;int&gt;&gt; kClosestMaxHeap(vector&lt;vector&lt;int&gt;&gt; &amp;points, int k) &#123;
    priority_queue&lt;pair&lt;float, int&gt;&gt; pq;
    for (int i = 0; i &lt; points.size(); i++) &#123;
      const auto &amp;point = points[i];
      pq.push(&#123;std::hypotf(point[0], point[1]), i&#125;);
      if (pq.size() &gt; k) &#123;
        pq.pop();
      &#125;
    &#125;

    vector&lt;vector&lt;int&gt;&gt; ret;
    ret.reserve(k);
    while (pq.size()) &#123;
      ret.emplace_back(points[pq.top().second]);
      pq.pop();
    &#125;
    return ret;
  &#125;

  vector&lt;vector&lt;int&gt;&gt; kClosestMinHeap(vector&lt;vector&lt;int&gt;&gt; &amp;points, int k) &#123;
    // pair&lt;float, int&gt; =&gt; pair&lt;distance, points_idx&gt;
    // * sorted by distance in asc order =&gt; greater
    // * sorted by distance in desc order =&gt; less
    using T = pair&lt;float, int&gt;;
    priority_queue&lt;T, vector&lt;T&gt;, greater&lt;T&gt;&gt; pq;
    for (int i = 0; i &lt; points.size(); i++) &#123;
      const auto &amp;point = points[i];
      pq.push(&#123;std::hypotf(point[0], point[1]), i&#125;);
    &#125;

    vector&lt;vector&lt;int&gt;&gt; ret(k);
    for (int i = 0; i &lt; k; i++) &#123;
      ret[i] = points[pq.top().second];
      pq.pop();
    &#125;
    return ret;
  &#125;
&#125;;
</code></pre>
<h3 id="Longest-Substring-Without-Repeating-Characters"><a href="#Longest-Substring-Without-Repeating-Characters" class="headerlink" title="Longest Substring Without Repeating Characters"></a>Longest Substring Without Repeating Characters</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbG9uZ2VzdC1zdWJzdHJpbmctd2l0aG91dC1yZXBlYXRpbmctY2hhcmFjdGVycy8=">https://leetcode.com/problems/longest-substring-without-repeating-characters/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>string</code> <code>sliding window</code> <code>two pointers</code></p>
</blockquote>
<ol>
<li><p>Bruteforce</p>
<ul>
<li>選一個 begin<ul>
<li>選一個 end<ul>
<li>掃描 [begin, end] 內的字元是否有重複</li>
</ul>
</li>
</ul>
</li>
<li>O(N^3)</li>
</ul>
</li>
<li><p>Sliding Window</p>
<ul>
<li>準備一個 map<ul>
<li>key：s 中出現過的字元</li>
<li>value：該字元最後一次出現的 index</li>
</ul>
</li>
<li><code>l</code> 與 <code>r</code> 分別代表 window 左右界<ul>
<li>規則：window 中不可出現重複字元</li>
</ul>
</li>
<li>不斷擴張 window 右界，同時檢查此次擴張是否會使 window 變得不合法<ul>
<li>若合法，繼續擴張</li>
<li>不合法，必須讓它再次合法</li>
</ul>
</li>
<li>對於每個字元 c ∈ s，我們讓<ul>
<li>若 c 已經在目前的 window 內（即：l ≤ i ≤ r）<ul>
<li>則目前 window 已無效，故更新 <code>l</code> 為最後出現的 idx + 1 使得 window 再次合法</li>
</ul>
</li>
<li>用 <code>max()</code> 更新 <code>max_len</code>，最後回傳之</li>
<li>將 <code>c</code> 的最後出現 index（即：<code>r</code>）記下來</li>
</ul>
</li>
<li>O(N)<br>```cpp<br>class Solution {<br>public:<br>int lengthOfLongestSubstring(const string &amp;s) {<br>std::unordered_map&lt;char, int&gt; last_appeared_idx;<br>int max_len = 0;<br>int l = 0;</li>
</ul>
<p> for (int r = 0; r &lt; s.size(); r++) {<br>   // If this character has already appeared before,<br>   // and if it’s within the current window…<br>   auto it = last_appeared_idx.find(s[r]);<br>   if (it != last_appeared_idx.end() &amp;&amp; it-&gt;second &gt;= l) {</p>
<pre><code> l = it-&gt;second + 1;
</code></pre>
<p>   }</p>
<p>   last_appeared_idx[s[r]] = r;<br>   max_len = std::max(max_len, r - l + 1);<br> }</p>
<p> return max_len;<br>}<br>};<br>```</p>
</li>
</ol>
<h3 id="Binary-Tree-Level-Order-Traversal"><a href="#Binary-Tree-Level-Order-Traversal" class="headerlink" title="Binary Tree Level Order Traversal"></a>Binary Tree Level Order Traversal</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtbGV2ZWwtb3JkZXItdHJhdmVyc2FsLw==">https://leetcode.com/problems/binary-tree-level-order-traversal/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>binary tree</code> <code>single-source bfs</code></p>
</blockquote>
<pre><code class="cpp">class Solution &#123;
 public:
  vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode *root) &#123;
    if (!root) &#123;
      return &#123;&#125;;
    &#125;
 
    std::vector&lt;std::vector&lt;int&gt;&gt; ret;
    std::queue&lt;TreeNode *&gt; q;

    q.push(root);
    while (q.size()) &#123;
      ret.push_back(&#123;&#125;);

      int len = q.size();
      for (int i = 0; i &lt; len; i++) &#123;
        TreeNode *curr = q.front();
        q.pop();
        ret.back().push_back(curr-&gt;val);

        if (curr-&gt;left) &#123;
          q.push(curr-&gt;left);
        &#125;
        if (curr-&gt;right) &#123;
          q.push(curr-&gt;right);
        &#125;
      &#125;
    &#125;

    return ret;
  &#125;
&#125;;
</code></pre>
<h3 id="Clone-Graph"><a href="#Clone-Graph" class="headerlink" title="Clone Graph"></a>Clone Graph</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY2xvbmUtZ3JhcGgv">https://leetcode.com/problems/clone-graph/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>graph</code> <code>dfs</code> <code>unordered_map</code></p>
</blockquote>
<p>開一個 unordered_map 紀錄 old node -&gt; new node 的映射關係。</p>
<pre><code class="cpp">class Solution &#123;
 public:
  Node *cloneGraph(Node *node) &#123;
    if (!node) &#123;
      return nullptr;
    &#125;

    if (auto it = old_to_new_.find(node); it != old_to_new_.end()) &#123;
      return it-&gt;second;
    &#125;

    auto cloned_node = new Node(node-&gt;val);
    cloned_node-&gt;neighbors.reserve(node-&gt;neighbors.size());
    old_to_new_.emplace(node, cloned_node);

    for (const auto neighbor : node-&gt;neighbors) &#123;
      auto cloned_neighbor = cloneGraph(neighbor);
      cloned_node-&gt;neighbors.emplace_back(cloned_neighbor);
    &#125;

    return cloned_node;
  &#125;

 private:
  std::unordered_map&lt;Node *, Node *&gt; old_to_new_;
&#125;;
</code></pre>
<h3 id="Evaluate-Reverse-Polish-Notation"><a href="#Evaluate-Reverse-Polish-Notation" class="headerlink" title="Evaluate Reverse Polish Notation"></a>Evaluate Reverse Polish Notation</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvZXZhbHVhdGUtcmV2ZXJzZS1wb2xpc2gtbm90YXRpb24v">https://leetcode.com/problems/evaluate-reverse-polish-notation/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>stack</code></p>
</blockquote>
<p>開一個 stack，正向掃 <code>tokens</code></p>
<ul>
<li><p>遇到 operand 就 push to stack</p>
</li>
<li><p>遇到 operator 就 pop from stack 兩次，運算完將結果再次 push to stack</p>
</li>
<li><p>最後答案會在 stack top<br>```cpp<br>class Solution {<br>public:<br>int evalRPN(const vector<string> &amp;tokens) {<br>  std::stack<int> st; </p>
<p>  for (const auto &amp;token : tokens) {</p>
<pre><code>if (!isOperator(token)) &#123;
  st.push(std::atoi(token.c_str()));
  continue;
&#125;

int operand2 = st.top();
st.pop();
int operand1 = st.top();
st.pop();
st.push(eval(token[0], operand1, operand2));
</code></pre>
<p>  }</p>
<p>  return st.top();<br>}</p>
</li>
</ul>
<p> private:<br>  bool isOperator(const std::string &amp;token) {<br>    return token == “+” || token == “-“ || token == “*” || token == “/“;<br>  }</p>
<p>  int eval(const char op, const int operand1, const int operand2) {<br>    switch (op) {<br>    case ‘+’:<br>      return operand1 + operand2;<br>    case ‘-‘:<br>      return operand1 - operand2;<br>    case ‘*’:<br>      return operand1 * operand2;<br>    case ‘/‘:<br>      return operand1 / operand2;<br>    default:<br>      return 0;<br>    }<br>  }<br>};</p>
<pre><code>
</code></pre>

  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2023-04-04 01:01:50" itemprop="dateModified" datetime="2023-04-04T01:01:50+08:00">2023-04-04</time>
  </span>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>Post author:  </strong>aesophor <i class="ic i-at"><em>@</em></i>
  </li>
  <li class="link">
    <strong>Post link: </strong>
    <a href="https://aesophor.github.io/leetcode/grind75.html" title="LeetCode Grind75">https://aesophor.github.io/leetcode/grind75.html</a>
  </li>
  <li class="license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Grind-75"><span class="toc-number">1.</span> <span class="toc-text">Grind 75</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Week-1"><span class="toc-number">1.1.</span> <span class="toc-text">Week 1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Two-Sum"><span class="toc-number">1.1.1.</span> <span class="toc-text">Two Sum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Valid-Parentheses"><span class="toc-number">1.1.2.</span> <span class="toc-text">Valid Parentheses</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Merge-Two-Sorted-Lists"><span class="toc-number">1.1.3.</span> <span class="toc-text">Merge Two Sorted Lists</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Best-Time-to-Buy-and-Sell-Stock"><span class="toc-number">1.1.4.</span> <span class="toc-text">Best Time to Buy and Sell Stock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Valid-Palindrome"><span class="toc-number">1.1.5.</span> <span class="toc-text">Valid Palindrome</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Invert-Binary-Tree"><span class="toc-number">1.1.6.</span> <span class="toc-text">Invert Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Valid-Anagram"><span class="toc-number">1.1.7.</span> <span class="toc-text">Valid Anagram</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binary-Search"><span class="toc-number">1.1.8.</span> <span class="toc-text">Binary Search</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flood-Fill"><span class="toc-number">1.1.9.</span> <span class="toc-text">Flood Fill</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><span class="toc-number">1.1.10.</span> <span class="toc-text">Lowest Common Ancestor of a Binary Search Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Balanced-Binary-Tree"><span class="toc-number">1.1.11.</span> <span class="toc-text">Balanced Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linked-List-Cycle"><span class="toc-number">1.1.12.</span> <span class="toc-text">Linked List Cycle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Implement-Queue-using-Stacks"><span class="toc-number">1.1.13.</span> <span class="toc-text">Implement Queue using Stacks</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Week-2"><span class="toc-number">1.2.</span> <span class="toc-text">Week 2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#First-Bad-Version"><span class="toc-number">1.2.1.</span> <span class="toc-text">First Bad Version</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ransom-Note"><span class="toc-number">1.2.2.</span> <span class="toc-text">Ransom Note</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Climbing-Stairs"><span class="toc-number">1.2.3.</span> <span class="toc-text">Climbing Stairs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Longest-Palindrome"><span class="toc-number">1.2.4.</span> <span class="toc-text">Longest Palindrome</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reverse-Linked-List"><span class="toc-number">1.2.5.</span> <span class="toc-text">Reverse Linked List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Diameter-of-Binary-Tree"><span class="toc-number">1.2.6.</span> <span class="toc-text">Diameter of Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Add-Binary"><span class="toc-number">1.2.7.</span> <span class="toc-text">Add Binary</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Middle-of-the-Linked-List"><span class="toc-number">1.2.8.</span> <span class="toc-text">Middle of the Linked List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Maximum-Depth-of-Binary-Tree"><span class="toc-number">1.2.9.</span> <span class="toc-text">Maximum Depth of Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Contains-Duplicate"><span class="toc-number">1.2.10.</span> <span class="toc-text">Contains Duplicate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Maximum-Subarray"><span class="toc-number">1.2.11.</span> <span class="toc-text">Maximum Subarray</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Week-3"><span class="toc-number">1.3.</span> <span class="toc-text">Week 3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Merge-Intervals"><span class="toc-number">1.3.1.</span> <span class="toc-text">Merge Intervals</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Insert-Interval"><span class="toc-number">1.3.2.</span> <span class="toc-text">Insert Interval</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#01-Matrix"><span class="toc-number">1.3.3.</span> <span class="toc-text">01 Matrix</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#K-Closest-Points-to-Origin"><span class="toc-number">1.3.4.</span> <span class="toc-text">K Closest Points to Origin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Longest-Substring-Without-Repeating-Characters"><span class="toc-number">1.3.5.</span> <span class="toc-text">Longest Substring Without Repeating Characters</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binary-Tree-Level-Order-Traversal"><span class="toc-number">1.3.6.</span> <span class="toc-text">Binary Tree Level Order Traversal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Clone-Graph"><span class="toc-number">1.3.7.</span> <span class="toc-text">Clone Graph</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Evaluate-Reverse-Polish-Notation"><span class="toc-number">1.3.8.</span> <span class="toc-text">Evaluate Reverse Polish Notation</span></a></li></ol></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="Related">
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="aesophor"
      data-src="/images/avatar.png">
  <p class="name" itemprop="name">aesophor</p>
  <div class="description" itemprop="description">eku</div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">2</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">2</span>
        <span class="name">categories</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">3</span>
        <span class="name">tags</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Flc29waG9y" title="https:&#x2F;&#x2F;github.com&#x2F;aesophor"><i class="ic i-github"></i></span>
      <span class="exturl item instagram" data-url="aHR0cHM6Ly93d3cuaW5zdGFncmFtLmNvbS9hZXNvcGhvci8=" title="https:&#x2F;&#x2F;www.instagram.com&#x2F;aesophor&#x2F;"><i class="ic i-instagram"></i></span>
      <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9hZXNvcGhvcg==" title="https:&#x2F;&#x2F;twitter.com&#x2F;aesophor"><i class="ic i-twitter"></i></span>
      <span class="exturl item linkedin" data-url="aHR0cHM6Ly93d3cubGlua2VkaW4uY29tL2luL2Flc29waG9yLw==" title="https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;aesophor&#x2F;"><i class="ic i-address-card"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>Home</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-user"></i>About</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/about/en-us" rel="section"><i class="ic i-address-card"></i>English</a>
  </li>

        
  <li class="item">
    <a href="/about/zh-tw" rel="section"><i class="ic i-address-card"></i>中文</a>
  </li>

  </ul>
        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/leetcode/grind75" rel="section"><i class="ic i-magic"></i>Grind75</a>
  </li>

    
  <li class="item">
    <a href="/leetcode" rel="section"><i class="ic i-magic"></i>LeetCode</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>Random Posts</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/CTF/" title="In CTF">CTF</a>
</div>

    <span><a href="/2022/08/27/pwnable-tw-secret-garden/" title="[pwnable.tw] Secret Garden (350 pts)">[pwnable.tw] Secret Garden (350 pts)</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Linux/" title="In Linux">Linux</a>
</div>

    <span><a href="/2020/07/20/Arch-Linux-on-MacBook-Pro-11-2-with-Custom-NVMe-M-2-SSD/" title="Arch Linux on MacBook Pro 11,2 with Custom NVMe M.2 SSD">Arch Linux on MacBook Pro 11,2 with Custom NVMe M.2 SSD</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>Recent Comments</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2020 – 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">aesophor @ aesophor</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: 'leetcode/grind75',
    favicon: {
      show: "（●´3｀●）Goooood",
      hide: "(´Д｀)Booooom"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,fancybox: true,
    copyright: 'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
