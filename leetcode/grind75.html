



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="" href="https://aesophor.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="" href="https://aesophor.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="" href="https://aesophor.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  

<link rel="canonical" href="https://aesophor.github.io/leetcode/grind75">



  <title>LeetCode Grind75 |
aesophor</title>
<meta name="generator" content="Hexo 5.4.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">LeetCode Grind75
  </h1>

          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">aesophor</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
          <img src="https://images.unsplash.com/photo-1533441325263-74682c42d779?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80">
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="page wrap">
    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="en">
  <link itemprop="mainEntityOfPage" href="https://aesophor.github.io/leetcode/grind75.html">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.png">
    <meta itemprop="name" content="aesophor">
    <meta itemprop="description" content="努力不會背叛人，它走不快，但早晚會跟上, eku">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h1 id="Grind-75"><a href="#Grind-75" class="headerlink" title="Grind 75"></a>Grind 75</h1><blockquote>
<p>你得有足够的驱动力强迫自己静下心来，阅读几十页的 Project Handout，理解上千行的代码框架，忍受数个小时的 debug 时光。而这一切，没有学分，没有绩点，没有老师，没有同学，只有一个信念 —— 你在变强。</p>
<p><cite>CSDIY</cite></p>
</blockquote>
<h2 id="Week-1"><a href="#Week-1" class="headerlink" title="Week 1"></a>Week 1</h2><h3 id="Two-Sum"><a href="#Two-Sum" class="headerlink" title="Two Sum"></a>Two Sum</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdHdvLXN1bS8=">https://leetcode.com/problems/two-sum/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>unordered_map</code></p>
</blockquote>
<ul>
<li>建一個 map<ul>
<li>key：num</li>
<li>value：the index of (target - num)</li>
</ul>
</li>
<li>掃瞄 nums，對於每個 num ∈ nums<ul>
<li>對於每個 num，用 num 去查詢 complement map<ul>
<li>若存在，{value, 目前的 index} 就是答案了</li>
<li>不存在，將 {target - num, 目前的 index} 存進去</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="cpp">class Solution &#123;
 public:
  vector&lt;int&gt; twoSum(const vector&lt;int&gt; &amp;nums, const int target) &#123;
    unordered_map&lt;int, int&gt; num_to_complement_idx;

    for (int i = 0; i &lt; nums.size(); i++) &#123;
      const auto it = num_to_complement_idx.find(nums[i]);
      if (it != num_to_complement_idx.end()) &#123;
        return &#123;i, it-&gt;second&#125;;
      &#125;
      num_to_complement_idx[target - nums[i]] = i;
    &#125;

    return &#123;-1, -1&#125;;
  &#125;
&#125;;
</code></pre>
<h3 id="Valid-Parentheses"><a href="#Valid-Parentheses" class="headerlink" title="Valid Parentheses"></a>Valid Parentheses</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdmFsaWQtcGFyZW50aGVzZXMv">https://leetcode.com/problems/valid-parentheses/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>stack</code></p>
</blockquote>
<ul>
<li>檢查字串 <code>s</code> 裡括號的合法性<ul>
<li><code>(</code> 不合法</li>
<li><code>([)]</code> 不合法</li>
<li><code>(([]))</code> 合法</li>
</ul>
</li>
</ul>
<pre><code class="cpp">class Solution &#123;
 public:
  bool isValid(const string &amp;s) &#123;
    for (const auto c : s) &#123;
      switch (c) &#123;
      case &#39;(&#39;:
        stack_.push(&#39;)&#39;);
        break;
      case &#39;[&#39;:
        stack_.push(&#39;]&#39;);
        break;
      case &#39;&#123;&#39;:
        stack_.push(&#39;&#125;&#39;);
        break;
      case &#39;)&#39;:
      case &#39;]&#39;:
      case &#39;&#125;&#39;:
        if (stack_.empty() || stack_.top() != c) &#123;
          return false;
        &#125;
        stack_.pop();
        break;
      default:
        return false;
      &#125;
    &#125;

    return stack_.empty();
  &#125;

 private:
  stack&lt;char&gt; stack_;
&#125;;
</code></pre>
<h3 id="Merge-Two-Sorted-Lists"><a href="#Merge-Two-Sorted-Lists" class="headerlink" title="Merge Two Sorted Lists"></a>Merge Two Sorted Lists</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWVyZ2UtdHdvLXNvcnRlZC1saXN0cy8=">https://leetcode.com/problems/merge-two-sorted-lists/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>list</code></p>
</blockquote>
<pre><code class="cpp">class Solution &#123;
 public:
  ListNode* mergeTwoLists(ListNode *list1, ListNode *list2) &#123;
    ListNode *head = nullptr;
    ListNode *curr = nullptr;

    while (list1 || list2) &#123;
      ListNode *new_node = nullptr;
      if (list1 &amp;&amp; !list2) &#123;
        new_node = list1;
        list1 = list1-&gt;next;
      &#125; else if (!list1 &amp;&amp; list2) &#123;
        new_node = list2;
        list2 = list2-&gt;next;
      &#125; else &#123;  // list1 &amp;&amp; list2
        if (list1-&gt;val &lt;= list2-&gt;val) &#123;
          new_node = list1;
          list1 = list1-&gt;next;
        &#125; else &#123;
          new_node = list2;
          list2 = list2-&gt;next;
        &#125;
      &#125;

      if (!head) &#123;
        head = new_node;
        curr = new_node;
      &#125; else &#123;
        curr-&gt;next = new_node;
        curr = new_node;
      &#125;
    &#125;

    return head;
  &#125;
&#125;;
</code></pre>
<h3 id="Best-Time-to-Buy-and-Sell-Stock"><a href="#Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="Best Time to Buy and Sell Stock"></a>Best Time to Buy and Sell Stock</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmVzdC10aW1lLXRvLWJ1eS1hbmQtc2VsbC1zdG9jay8=">https://leetcode.com/problems/best-time-to-buy-and-sell-stock/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>array</code> <code>dynamic programming</code></p>
</blockquote>
<ul>
<li>如果將 <code>prices</code> 中每個 price 視為買點，那麼每個買點都會有個最佳賣點<ul>
<li><code>best_sell_prices</code></li>
</ul>
</li>
<li>最佳賣點 = 此點往右（不包含自己）的最大值<ul>
<li>有沒有聞到 &lt;LC&gt; #238 - Product of Array Except Self 的味道？</li>
</ul>
</li>
<li>複雜度：<ul>
<li>Time O(N)</li>
<li>Space O(N)</li>
</ul>
</li>
</ul>
<pre><code class="cpp">// best_sell_prices: [6,6,6,6,4,0]
// input:            [7,1,5,3,6,4]

// best_sell_prices: [6,4,3,1,0]
// input:            [7,6,4,3,1]

class Solution &#123;
 public:
  int maxProfit(const vector&lt;int&gt; &amp;prices) &#123;
    vector&lt;int&gt; best_sell_prices(prices.size(), 0);
    for (int i = prices.size() - 2; i &gt;= 0; i--) &#123;
      best_sell_prices[i] = std::max(prices[i + 1], best_sell_prices[i + 1]);
    &#125;

    int max_profit = 0;
    for (int i = 0; i &lt; prices.size(); i++) &#123;
      max_profit = std::max(max_profit, best_sell_prices[i] - prices[i]);
    &#125;
    return max_profit;
  &#125;
&#125;;
</code></pre>
<ul>
<li>上面的邏輯再稍微 distill 一下<ul>
<li>Time O(N)</li>
<li>Space O(1)</li>
</ul>
</li>
</ul>
<pre><code class="cpp">class Solution &#123;
 public:
  int maxProfit(const vector&lt;int&gt; &amp;prices) &#123;
    int best_sell_price = 0;
    int max_profit = 0;

    for (int i = prices.size() - 2; i &gt;= 0; i--) &#123;
      best_sell_price = std::max(best_sell_price, prices[i + 1]);
      max_profit = std::max(max_profit, best_sell_price - prices[i]);
    &#125;

    return max_profit;
  &#125;
&#125;;
</code></pre>
<h3 id="Valid-Palindrome"><a href="#Valid-Palindrome" class="headerlink" title="Valid Palindrome"></a>Valid Palindrome</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdmFsaWQtcGFsaW5kcm9tZS8=">https://leetcode.com/problems/valid-palindrome/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>two pointers</code></p>
</blockquote>
<pre><code class="cpp">class Solution &#123;
 public:
  bool isPalindrome(const string &amp;s) &#123;
    int l = 0;
    int r = s.size() - 1;

    while (l &lt; r) &#123;
      if (!isalnum(s[l])) &#123;
        l++;
        continue;
      &#125;
      if (!isalnum(s[r])) &#123;
        r--;
        continue;
      &#125;
      if (std::tolower(s[l]) != std::tolower(s[r])) &#123;
        return false;
      &#125;
      l++;
      r--;
    &#125;

    return true;
  &#125;
&#125;;
</code></pre>
<h3 id="Invert-Binary-Tree"><a href="#Invert-Binary-Tree" class="headerlink" title="Invert Binary Tree"></a>Invert Binary Tree</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaW52ZXJ0LWJpbmFyeS10cmVlLw==">https://leetcode.com/problems/invert-binary-tree/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>binary tree</code> <code>recursion</code></p>
</blockquote>
<pre><code class="cpp">class Solution &#123;
 public:
  TreeNode* invertTree(TreeNode* root) &#123;
    if (!root) &#123;
      return nullptr;
    &#125;
    
    std::swap(root-&gt;left, root-&gt;right);   
    invertTree(root-&gt;left);
    invertTree(root-&gt;right);
    return root;
  &#125;
&#125;;
</code></pre>
<h3 id="Valid-Anagram"><a href="#Valid-Anagram" class="headerlink" title="Valid Anagram"></a>Valid Anagram</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdmFsaWQtYW5hZ3JhbS8=">https://leetcode.com/problems/valid-anagram/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>unordered_map</code></p>
</blockquote>
<ul>
<li>anagram 的定義：同字母異序字、重組字、變位字</li>
<li>用 unordered_map 紀錄各個字母出現的頻率，任何一個字的頻率不對就 return false</li>
<li>長度不一樣就不用比了，肯定不是 anagram</li>
</ul>
<pre><code class="cpp">class Solution &#123;
 public:
  bool isAnagram(string s, string t) &#123;
    if (s.size() != t.size()) &#123;
      return false;
    &#125;

    unordered_map&lt;char, int&gt; char_freqs;
    for (const auto c : s) &#123;
      char_freqs[c]++;
    &#125;

    for (const auto c : t) &#123;
      auto it = char_freqs.find(c);
      if (it == char_freqs.end()) &#123;
        return false;
      &#125;

      if (--it-&gt;second == 0) &#123;
        char_freqs.erase(it);
      &#125;
    &#125;

    return true;
  &#125;
&#125;;
</code></pre>
<h3 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmluYXJ5LXNlYXJjaC8=">https://leetcode.com/problems/binary-search/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>binary search</code></p>
</blockquote>
<pre><code class="cpp">class Solution &#123;
 public:
  int search(const vector&lt;int&gt; &amp;nums, const int target) &#123;
    int l = 0;
    int r = nums.size() - 1; 
    int m;

    while (l &lt;= r) &#123;
      m = l + (r - l) / 2;
      if (nums[m] == target) &#123;
        return m;
      &#125; else if (nums[m] &lt; target) &#123;
        l = m + 1;
      &#125; else &#123;  // nums[m] &gt; target
        r = m - 1;
      &#125;
    &#125;

    return -1;
  &#125;
&#125;;
</code></pre>
<h3 id="Flood-Fill"><a href="#Flood-Fill" class="headerlink" title="Flood Fill"></a>Flood Fill</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvZmxvb2QtZmlsbC8=">https://leetcode.com/problems/flood-fill/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>matrix</code> <code>single-source bfs</code></p>
</blockquote>
<ul>
<li>小畫家的 paint bucket/fill tool</li>
<li>Single-source matrix bfs</li>
<li>BFS 過程中，記得不要走出界，也不要走到不是原本顏色的 pixel</li>
</ul>
<pre><code class="cpp">class Solution &#123;
 public:
  vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt; &amp;image,
                                const int sr,
                                const int sc,
                                const int new_color) &#123;
    const int old_color = image[sr][sc]; 
    if (old_color == new_color) &#123;
      return image;
    &#125;
    
    queue&lt;pair&lt;int, int&gt;&gt; q;
    q.push(&#123;sr, sc&#125;);
    while (q.size()) &#123;
      const auto [r, c] = q.front();
      q.pop();

      image[r][c] = new_color;

      if (r - 1 &gt;= 0 &amp;&amp; image[r - 1][c] == old_color) &#123;
        q.push(&#123;r - 1, c&#125;);
      &#125;
      if (r + 1 &lt; image.size() &amp;&amp; image[r + 1][c] == old_color) &#123;
        q.push(&#123;r + 1, c&#125;);
      &#125;
      if (c - 1 &gt;= 0 &amp;&amp; image[r][c - 1] == old_color) &#123;
        q.push(&#123;r, c - 1&#125;);
      &#125;
      if (c + 1 &gt;= 0 &amp;&amp; image[r][c + 1] == old_color) &#123;
        q.push(&#123;r, c + 1&#125;);
      &#125;
    &#125;

    return image;
  &#125;
&#125;;
</code></pre>
<h3 id="Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="Lowest Common Ancestor of a Binary Search Tree"></a>Lowest Common Ancestor of a Binary Search Tree</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbG93ZXN0LWNvbW1vbi1hbmNlc3Rvci1vZi1hLWJpbmFyeS1zZWFyY2gtdHJlZS8=">https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>binary search tree</code></p>
</blockquote>
<p>第一次寫的時候沒注意到有 binary search tree 的 sorted property 可以利用，所以寫了一個 generic binary tree 的 solution。</p>
<p>題目給你一棵 BST，然後給你 BST 中的兩個 tree node <code>p, q</code>，要你找出它們的 lowest common ancestor (grandparent node)，並且自己也算是自己的 ancestor。</p>
<ul>
<li>如果 current node <code>root</code> 比兩個 target nodes <code>p, q</code> 小，就往 right subtree 找</li>
<li>如果 current node <code>root</code> 比兩個 target nodes <code>p, q</code> 大，就往 left subtree 找</li>
<li>如果 current node <code>root</code> 和 <code>p, q</code> 相比是一大一小，代表 <code>p, q</code> 必定在自己下面的一左一右。</li>
</ul>
<pre><code class="cpp">class Solution &#123;
 public:
  TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) &#123;
    // Remember to exploit the property of a binary search tree! :-^)
    if (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) &#123;
      return lowestCommonAncestor(root-&gt;right, p, q);
    &#125; else if (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) &#123;
      return lowestCommonAncestor(root-&gt;left, p, q);
    &#125; else &#123;
      return root;
    &#125;
  &#125;
&#125;;
</code></pre>
<h3 id="Balanced-Binary-Tree"><a href="#Balanced-Binary-Tree" class="headerlink" title="Balanced Binary Tree"></a>Balanced Binary Tree</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmFsYW5jZWQtYmluYXJ5LXRyZWUv">https://leetcode.com/problems/balanced-binary-tree/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>binary tree</code> <code>dfs</code></p>
</blockquote>
<p>每一個 node 都去找它左右子樹的深度，深度的差只能是 0 或 1，不能是 2 (含) 以上。</p>
<pre><code class="cpp">class Solution &#123;
 public:
  bool isBalanced(TreeNode *root) &#123;
    getDepth(root);
    return is_balanced_;
  &#125;

 private:
  int getDepth(TreeNode *node) &#123;
    if (!node) &#123;
      return 0;
    &#125;

    int l_depth = getDepth(node-&gt;left);
    int r_depth = getDepth(node-&gt;right);
    int current_depth = std::max(l_depth, r_depth) + 1;
    is_balanced_ &amp;= std::abs(l_depth - r_depth) &lt;= 1;
    return current_depth;
  &#125;
  
  bool is_balanced_ = true;
&#125;;
</code></pre>
<h3 id="Linked-List-Cycle"><a href="#Linked-List-Cycle" class="headerlink" title="Linked List Cycle"></a>Linked List Cycle</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbGlua2VkLWxpc3QtY3ljbGUv">https://leetcode.com/problems/linked-list-cycle/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>two pointers</code></p>
</blockquote>
<p>Fast &amp; Slow Pointers</p>
<ul>
<li>如果 linked list 沒 cycle 的話，while loop 必定能走完，最終回傳 false</li>
<li>如果 linked list 有 cycle 的話，while loop 必定無窮迴圈<ul>
<li>讓 fast pointer 一次走兩步</li>
<li>讓 slow pointer 一次走一步</li>
<li>如果有 cycle 的話，有朝一日 fast pointer 和 slow pointer 必會相等</li>
</ul>
</li>
</ul>
<pre><code class="cpp">class Solution &#123;
 public:
  bool hasCycle(ListNode *head) &#123;
    ListNode *fast = head;
    ListNode *slow = head;

    while (fast &amp;&amp; slow) &#123;
      fast = fast-&gt;next;
      if (!fast) &#123;
        return false;
      &#125;
      fast = fast-&gt;next;
      slow = slow-&gt;next;

      if (fast == slow) &#123;
        return true;
      &#125;
    &#125;

    return false;
  &#125;
&#125;;
</code></pre>
<h3 id="Implement-Queue-using-Stacks"><a href="#Implement-Queue-using-Stacks" class="headerlink" title="Implement Queue using Stacks"></a>Implement Queue using Stacks</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaW1wbGVtZW50LXF1ZXVlLXVzaW5nLXN0YWNrcy8=">https://leetcode.com/problems/implement-queue-using-stacks/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>stack</code></p>
</blockquote>
<p>開一個 stack，存放資料</p>
<ul>
<li>push() - 直接 push 到這個 stack 裡面就行了</li>
<li>pop() - 開一個 tmp stack<ul>
<li>將原本的 stack 的資料一個一個 pop 出來然後 push 進 tmp stack，然後返回 tmp stack 的 top element</li>
<li>記得再把 tmp stack 的東西倒回原本的 stack</li>
</ul>
</li>
</ul>
<pre><code class="cpp">class MyQueue &#123;
 public:
  MyQueue() : stack_() &#123;&#125;
    
  void push(int x) &#123;
    stack_.push(x);
  &#125;
    
  int pop() &#123;
    stack&lt;int&gt; tmp_stack;
    while (stack_.size()) &#123;
      tmp_stack.push(stack_.top());
      stack_.pop();
    &#125;

    int ret = tmp_stack.top();
    tmp_stack.pop();
    while (tmp_stack.size()) &#123;
      stack_.push(tmp_stack.top());
      tmp_stack.pop();
    &#125;

    return ret;
  &#125;
    
  int peek() &#123;
    stack&lt;int&gt; tmp_stack;
    while (stack_.size()) &#123;
      tmp_stack.push(stack_.top());
      stack_.pop();
    &#125;

    int ret = tmp_stack.top();
    while (tmp_stack.size()) &#123;
      stack_.push(tmp_stack.top());
      tmp_stack.pop();
    &#125;

    return ret;
  &#125;
    
  bool empty() &#123;
    return stack_.empty();
  &#125;

 private:
  stack&lt;int&gt; stack_;
&#125;;

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj-&gt;push(x);
 * int param_2 = obj-&gt;pop();
 * int param_3 = obj-&gt;peek();
 * bool param_4 = obj-&gt;empty();
 */
</code></pre>
<h2 id="Week-2"><a href="#Week-2" class="headerlink" title="Week 2"></a>Week 2</h2><h3 id="First-Bad-Version"><a href="#First-Bad-Version" class="headerlink" title="First Bad Version"></a>First Bad Version</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvZmlyc3QtYmFkLXZlcnNpb24v">https://leetcode.com/problems/first-bad-version/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>binary search</code></p>
</blockquote>
<pre><code class="cpp">// The API isBadVersion is defined for you.
// bool isBadVersion(int version);

class Solution &#123;
 public:
  int firstBadVersion(int n) &#123;
    int l = 0;
    int r = n;
    int m;

    while (l &lt;= r) &#123;
      m = l + (r - l) / 2;
      if (isBadVersion(m)) &#123;
        r = m - 1;
      &#125; else &#123;
        l = m + 1;
      &#125;
    &#125;

    return l;
  &#125;
&#125;;
</code></pre>
<h3 id="Ransom-Note"><a href="#Ransom-Note" class="headerlink" title="Ransom Note"></a>Ransom Note</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcmFuc29tLW5vdGUv">https://leetcode.com/problems/ransom-note/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>unordered_map</code></p>
</blockquote>
<p>問你 magazine 裡面的字母是否為 ransomNote 的 superset, 必須考量字母頻率。</p>
<pre><code class="cpp">class Solution &#123;
 public:
  bool canConstruct(const string &amp;ransomNote, const string &amp;magazine) &#123;
    unordered_map&lt;char, int&gt; char_freqs;
    for (const auto c : magazine) &#123;
      char_freqs[c]++;
    &#125;

    for (const auto c : ransomNote) &#123;
      auto it = char_freqs.find(c);
      if (it == char_freqs.end()) &#123;
        return false;
      &#125;

      it-&gt;second--;
      if (it-&gt;second == 0) &#123;
        char_freqs.erase(it);
      &#125;
    &#125;

    return true;
  &#125;
&#125;;
</code></pre>
<h3 id="Climbing-Stairs"><a href="#Climbing-Stairs" class="headerlink" title="Climbing Stairs"></a>Climbing Stairs</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY2xpbWJpbmctc3RhaXJzLw==">https://leetcode.com/problems/climbing-stairs/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>dynamic programming</code> <code>bottom up</code></p>
</blockquote>
<pre><code class="cpp">class Solution &#123;
 public:
  int climbStairs(int n) &#123;
    uint64_t dp[50] = &#123;0, 1, 2&#125;;
    for (int i = 3; i &lt; 50; i++) &#123;
      dp[i] = dp[i - 1] + dp[i - 2];
    &#125;
    return dp[n];
  &#125;
&#125;;
</code></pre>
<h3 id="Longest-Palindrome"><a href="#Longest-Palindrome" class="headerlink" title="Longest Palindrome"></a>Longest Palindrome</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbG9uZ2VzdC1wYWxpbmRyb21lLw==">https://leetcode.com/problems/longest-palindrome/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>unordered_map</code></p>
</blockquote>
<pre><code class="cpp">class Solution &#123;
 public:
  int longestPalindrome(const string &amp;s) &#123;
    unordered_map&lt;char, int&gt; char_freqs;
    for (const auto c : s) &#123;
      char_freqs[c]++;
    &#125;

    int len = std::any_of(char_freqs.begin(),
                          char_freqs.end(),
                          [](const pair&lt;char, int&gt; &amp;entry) &#123;
                            return entry.second % 2 == 1;
                          &#125;);
    for (const auto &amp;[c, f] : char_freqs) &#123;
      len += 2 * (f / 2);
    &#125;
    return len;
  &#125;
&#125;;
</code></pre>
<h3 id="Reverse-Linked-List"><a href="#Reverse-Linked-List" class="headerlink" title="Reverse Linked List"></a>Reverse Linked List</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcmV2ZXJzZS1saW5rZWQtbGlzdC8=">https://leetcode.com/problems/reverse-linked-list/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>linked list</code></p>
</blockquote>
<ul>
<li>Iterative solution<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1XMUJMR2dXWmhLOA==">https://www.youtube.com/watch?v=W1BLGgWZhK8</span></li>
</ul>
</li>
<li>Recursive solution<ul>
<li>將自己下一個 node 指向自己</li>
<li>回傳 new head! 回傳 new head! 回傳 new head!</li>
</ul>
</li>
</ul>
<pre><code class="cpp">class Solution &#123;
 public:
  ListNode *reverseList(ListNode *head) &#123;
    return reverseListRecursively(head);
  &#125;

 private:
  ListNode *reverseListIteratively(ListNode *head) &#123;
    if (!head) &#123;
      return nullptr;
    &#125;

    ListNode *new_head = nullptr;
    ListNode *next = nullptr;

    while (head) &#123;
      next = head-&gt;next;
      head-&gt;next = new_head;
      new_head = head;
      head = next;
    &#125;

    return new_head;
  &#125;

  ListNode *reverseListRecursively(ListNode *head) &#123;
    if (!head || !head-&gt;next) &#123;
      return head;
    &#125;

    ListNode *new_head = reverseListRecursively(head-&gt;next);
    head-&gt;next-&gt;next = head;
    head-&gt;next = nullptr;
    return new_head;
  &#125;
&#125;;
</code></pre>
<h3 id="Majority-Element"><a href="#Majority-Element" class="headerlink" title="Majority Element"></a>Majority Element</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWFqb3JpdHktZWxlbWVudC8=">https://leetcode.com/problems/majority-element/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>sorting</code></p>
</blockquote>
<p>給你一串 unsorted 的數字，並且裡面有某個數字的出現頻率必定超過總數的一半，請找出該數字為何。</p>
<pre><code class="cpp">//              -------
// odd:  &#123;0, 1, 2, 3, 4&#125;  =&gt; 5 / 2 = 2
//        -------
//           -------
// even: &#123;0, 1, 2, 3&#125;     =&gt; 4 / 2 = 2
//        -------
class Solution &#123;
 public:
  int majorityElement(vector&lt;int&gt;&amp; nums) &#123;
    std::sort(nums.begin(), nums.end());
    return nums[nums.size() / 2];
  &#125;
&#125;;
</code></pre>
<h3 id="Diameter-of-Binary-Tree"><a href="#Diameter-of-Binary-Tree" class="headerlink" title="Diameter of Binary Tree"></a>Diameter of Binary Tree</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvZGlhbWV0ZXItb2YtYmluYXJ5LXRyZWUv">https://leetcode.com/problems/diameter-of-binary-tree/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>binary tree</code> <code>dfs</code></p>
</blockquote>
<pre><code class="cpp">class Solution &#123;
 public:
  int diameterOfBinaryTree(TreeNode *root) &#123;
    getDepth(root);
    return max_diameter_;
  &#125;

 private:
  int getDepth(TreeNode *node) &#123;
    if (!node) &#123;
      return 0;
    &#125;

    int l_depth = getDepth(node-&gt;left);
    int r_depth = getDepth(node-&gt;right);
    int current_depth = std::max(l_depth, r_depth) + 1;

    int diameter = l_depth + r_depth;
    max_diameter_ = std::max(max_diameter_, diameter);

    return current_depth;
  &#125;

  int max_diameter_ = 0;
&#125;;
</code></pre>
<h3 id="Add-Binary"><a href="#Add-Binary" class="headerlink" title="Add Binary"></a>Add Binary</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYWRkLWJpbmFyeS8=">https://leetcode.com/problems/add-binary/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>string</code> <code>bit manipulation</code></p>
</blockquote>
<pre><code class="cpp">class Solution &#123;
 public:
  string addBinary(string a, string b) &#123;
    bool carry = false;
    int digit = 0;
    int i = 0;
    int j = 0;
    string result;

    std::reverse(a.begin(), a.end());
    std::reverse(b.begin(), b.end());

    while (i &lt; a.size() || j &lt; b.size() || carry) &#123;
      digit = carry;
      if (i &lt; a.size()) &#123;
        digit += a[i] - &#39;0&#39;;
        i++;
      &#125;
      if (j &lt; b.size()) &#123;
        digit += b[j] - &#39;0&#39;;
        j++;
      &#125;
      result.push_back(&#39;0&#39; + digit % 2);
      carry = digit &gt; 1;
    &#125;

    std::reverse(result.begin(), result.end());
    return result; 
  &#125;
&#125;;
</code></pre>
<h3 id="Middle-of-the-Linked-List"><a href="#Middle-of-the-Linked-List" class="headerlink" title="Middle of the Linked List"></a>Middle of the Linked List</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWlkZGxlLW9mLXRoZS1saW5rZWQtbGlzdC8=">https://leetcode.com/problems/middle-of-the-linked-list/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>linked list</code> <code>two pointers</code></p>
</blockquote>
<p>快慢指標，走完 <code>slow</code> 就是答案。</p>
<p>有個 edge case 要特別注意，就是當 list size 為奇數時，快指標走到最後一個節點就要提早 break loop 了。</p>
<p>面試時可以自己簡單拿 odd &amp; even size 的兩條 linked lists 自己驗證一下，就不會漏掉這個 case 了。</p>
<pre><code class="cpp">class Solution &#123;
 public:
  ListNode *middleNode(ListNode *head) &#123;
    ListNode *fast = head;
    ListNode *slow = head;

    while (fast &amp;&amp; slow &amp;&amp; fast-&gt;next) &#123;
      fast = fast-&gt;next;
      if (fast) &#123;
        fast = fast-&gt;next;
      &#125;
      slow = slow-&gt;next;
    &#125;

    return slow;
  &#125;
&#125;;
</code></pre>
<h3 id="Maximum-Depth-of-Binary-Tree"><a href="#Maximum-Depth-of-Binary-Tree" class="headerlink" title="Maximum Depth of Binary Tree"></a>Maximum Depth of Binary Tree</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWF4aW11bS1kZXB0aC1vZi1iaW5hcnktdHJlZS8=">https://leetcode.com/problems/maximum-depth-of-binary-tree/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>binary tree</code> <code>dfs</code></p>
</blockquote>
<pre><code class="cpp">class Solution &#123;
 public:
  int maxDepth(TreeNode *root) &#123;
    getDepth(root);
    return max_depth_;
  &#125;

 private:
  int getDepth(TreeNode *node) &#123;
    if (!node) &#123;
      return 0;
    &#125;

    int l_depth = getDepth(node-&gt;left);
    int r_depth = getDepth(node-&gt;right);
    int current_depth = std::max(l_depth, r_depth) + 1;
    max_depth_ = std::max(max_depth_, current_depth);
    return current_depth;
  &#125;

  int max_depth_ = 0;
&#125;;
</code></pre>
<h3 id="Contains-Duplicate"><a href="#Contains-Duplicate" class="headerlink" title="Contains Duplicate"></a>Contains Duplicate</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY29udGFpbnMtZHVwbGljYXRlLw==">https://leetcode.com/problems/contains-duplicate/</span><br><strong>難度：</strong> Easy<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>unordered_set</code></p>
</blockquote>
<pre><code class="cpp">class Solution &#123;
 public:
  bool containsDuplicate(const vector&lt;int&gt; &amp;nums) &#123;
    unordered_set&lt;int&gt; appeared; 

    for (const auto n : nums) &#123;
      if (appeared.find(n) != appeared.end()) &#123;
        return true;
      &#125;
      appeared.emplace(n);
    &#125;

    return false;
  &#125;
&#125;;
</code></pre>
<h3 id="Maximum-Subarray"><a href="#Maximum-Subarray" class="headerlink" title="Maximum Subarray"></a>Maximum Subarray</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWF4aW11bS1zdWJhcnJheS8=">https://leetcode.com/problems/maximum-subarray/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>array</code> <code>dynamic programming</code> <code>kadane</code></p>
</blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0Byc2luZ2hhbDc1Ny9rYWRhbmVzLWFsZ29yaXRobS1keW5hbWljLXByb2dyYW1taW5nLWhvdy1hbmQtd2h5LWRvZXMtaXQtd29yay0zZmQ4ODQ5ZWQ3M2Q=">https://medium.com/@rsinghal757/kadanes-algorithm-dynamic-programming-how-and-why-does-it-work-3fd8849ed73d</span></p>
<pre><code class="cpp">class Solution &#123;
 public:
  int maxSubArray(const vector&lt;int&gt; &amp;nums) &#123;
    int global_max = std::numeric_limits&lt;int&gt;::lowest();
    int local_max = 0;

    for (const auto n : nums) &#123;
      local_max = std::max(n, local_max + n);
      global_max = std::max(global_max, local_max);
    &#125;
    return global_max;
  &#125;
&#125;;
</code></pre>
<h2 id="Week-3"><a href="#Week-3" class="headerlink" title="Week 3"></a>Week 3</h2><h3 id="Insert-Interval"><a href="#Insert-Interval" class="headerlink" title="Insert Interval"></a>Insert Interval</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaW5zZXJ0LWludGVydmFsLw==">https://leetcode.com/problems/insert-interval/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>array</code> <code>interval</code></p>
</blockquote>
<ol>
<li>暴力解：<ul>
<li>將 <code>new_interval</code> append 到 <code>intervals</code> 並根據左界進行 ascending sort</li>
<li>將此問題 reduce 成 Merge Intervals（見 Week 5 的 Merge Intervals）</li>
</ul>
</li>
<li>比較有效率的解法：<ul>
<li>從頭掃描 intervals<ul>
<li>若與 <code>new_interval</code> 無 overlapped，直接 append 到 <code>ret</code></li>
<li>若與 <code>new_interval</code> 有 overlapped，確認目前掃描到的 <code>interval</code> 與 <code>new_interval</code> 融合後的左右界</li>
</ul>
</li>
<li>將 <code>new_interval</code> append 到 <code>ret</code></li>
<li>從剛剛掃描暫停的地方繼續，往後掃完 <code>intervals</code> 剩餘的部分<ul>
<li>因為不確定 <code>new_interval</code> 所橫跨的範圍多大，故此部分的邏輯同 Merge Intervals 的解法</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code class="cpp">class Solution &#123;
 public:
  vector&lt;vector&lt;int&gt;&gt; insert(vector&lt;vector&lt;int&gt;&gt; &amp;intervals,
                             vector&lt;int&gt; &amp;new_interval) &#123;
    vector&lt;vector&lt;int&gt;&gt; ret;
    int i = 0;

    for (; i &lt; intervals.size(); i++) &#123;
      const auto &amp;interval = intervals[i];
      if (new_interval[0] &lt;= interval[1]) &#123;  // overlapped
        new_interval[0] = std::min(new_interval[0], interval[0]);
        break;
      &#125;
      ret.emplace_back(interval);
    &#125;

    ret.emplace_back(new_interval);

    for (; i &lt; intervals.size(); i++) &#123;
      const auto &amp;interval = intervals[i];
      if (ret.back()[1] &lt; interval[0]) &#123;  // not overlapped
        ret.emplace_back(interval);
      &#125; else &#123;  // overlapped
        ret.back()[1] = std::max(ret.back()[1], interval[1]);
      &#125;
    &#125;

    return ret;
  &#125;
&#125;;
</code></pre>
<h3 id="01-Matrix"><a href="#01-Matrix" class="headerlink" title="01 Matrix"></a>01 Matrix</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtbGV2ZWwtb3JkZXItdHJhdmVyc2FsLw==">https://leetcode.com/problems/binary-tree-level-order-traversal/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>matrix</code> <code>multi-source bfs</code></p>
</blockquote>
<ol>
<li>解法一：對 <code>mat</code> 中每個 1 做 BFS，找到最近的 0 的距離後填入 <code>ret</code> 中 =&gt; TLE</li>
<li>解法二：從 <code>mat</code> 中所有 0 同時做 BFS，平行擴散。第一個到達 1 者，當下的 <code>dist</code> 就是該點和它最近的 0 的距離。</li>
</ol>
<pre><code class="cpp">// 解法一 (TLE)
class Solution &#123;
 public:
  vector&lt;vector&lt;int&gt;&gt; updateMatrix(const vector&lt;vector&lt;int&gt;&gt; &amp;mat) &#123;
    const int m = mat.size();
    const int n = mat[0].size();

    vector&lt;vector&lt;int&gt;&gt; ret(m);
    for (auto &amp;row : ret) &#123;
      row = vector&lt;int&gt;(n);
    &#125;

    for (int i = 0; i &lt; m; i++) &#123;
      for (int j = 0; j &lt; n; j++) &#123;
        ret[i][j] = bfs(mat, m, n, i, j);
      &#125;
    &#125;
    return ret;
  &#125;

 private:
  int bfs(const vector&lt;vector&lt;int&gt;&gt; &amp;mat,
          const int m,
          const int n,
          const int sr,
          const int sc) &#123;
    if (mat[sr][sc] == 0) &#123;
      return 0;
    &#125;

    vector&lt;vector&lt;bool&gt;&gt; visited(m);
    for (auto &amp;row : visited) &#123;
      row = vector&lt;bool&gt;(n, false);
    &#125;

    int dist = 0;
    queue&lt;pair&lt;int, int&gt;&gt; q;
    q.push(&#123;sr, sc&#125;);
    while (q.size()) &#123;
      int len = q.size();
      for (int i = 0; i &lt; len; i++) &#123;
        const auto [r, c] = q.front();
        q.pop();

        if (mat[r][c] == 0) &#123;
          return dist;
        &#125;
        visited[r][c] = true;

        if (r - 1 &gt;= 0 &amp;&amp; !visited[r - 1][c]) &#123;
          q.push(&#123;r - 1, c&#125;);
        &#125;
        if (r + 1 &lt; mat.size() &amp;&amp; !visited[r + 1][c]) &#123;
          q.push(&#123;r + 1, c&#125;);
        &#125;
        if (c - 1 &gt;= 0 &amp;&amp; !visited[r][c - 1]) &#123;
          q.push(&#123;r, c - 1&#125;);
        &#125;
        if (c + 1 &lt; mat[0].size() &amp;&amp; !visited[r][c + 1]) &#123;
          q.push(&#123;r, c + 1&#125;);
        &#125;
      &#125;
      dist++;
    &#125;

    return -1;  // shouldn&#39;t have reached here.
  &#125;
&#125;;
</code></pre>
<pre><code class="cpp">// 解法二 (AC)
class Solution &#123;
 public:
  vector&lt;vector&lt;int&gt;&gt; updateMatrix(const vector&lt;vector&lt;int&gt;&gt; &amp;mat) &#123;
    const int uninitialized = std::numeric_limits&lt;int&gt;::max();
    const int m = mat.size();
    const int n = mat[0].size();

    vector&lt;vector&lt;int&gt;&gt; ret(m);
    for (auto &amp;row : ret) &#123;
      row = vector&lt;int&gt;(n, 0);
    &#125;

    queue&lt;pair&lt;int, int&gt;&gt; q;
    for (int i = 0; i &lt; m; i++) &#123;
      for (int j = 0; j &lt; n; j++) &#123;
        if (mat[i][j] == 0) &#123;
          ret[i][j] = 0;
          q.push(&#123;i, j&#125;);
        &#125; else &#123;
          ret[i][j] = uninitialized;
        &#125;
      &#125;
    &#125;

    int dist = 0;
    while (q.size()) &#123;
      int len = q.size();
      for (int i = 0; i &lt; len; i++) &#123;
        const auto [r, c] = q.front();
        q.pop();

        if (ret[r][c] == uninitialized) &#123;
          ret[r][c] = dist;
        &#125;

        if (r - 1 &gt;= 0 &amp;&amp; ret[r - 1][c] == uninitialized) &#123;
          q.push(&#123;r - 1, c&#125;);
        &#125;
        if (r + 1 &lt; m &amp;&amp; ret[r + 1][c] == uninitialized) &#123;
          q.push(&#123;r + 1, c&#125;);
        &#125;
        if (c - 1 &gt;= 0 &amp;&amp; ret[r][c - 1] == uninitialized) &#123;
          q.push(&#123;r, c - 1&#125;);
        &#125;
        if (c + 1 &lt; n &amp;&amp; ret[r][c + 1] == uninitialized) &#123;
          q.push(&#123;r, c + 1&#125;);
        &#125;
      &#125;
      dist++;
    &#125;

    return ret;
  &#125;
&#125;;
</code></pre>
<h3 id="K-Closest-Points-to-Origin"><a href="#K-Closest-Points-to-Origin" class="headerlink" title="K Closest Points to Origin"></a>K Closest Points to Origin</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvay1jbG9zZXN0LXBvaW50cy10by1vcmlnaW4v">https://leetcode.com/problems/k-closest-points-to-origin/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>sorting</code> <code>priority_queue</code></p>
</blockquote>
<ol>
<li>解法一：計算各點和 (0, 0) 的歐式距離後以之進行升冪排序，取前 k 個點回傳。</li>
<li>解法二：使用 max heap<ul>
<li>各個點進入 priority queue 的時候，自動按歐式距離降冪排序</li>
<li>priority queue size 大於 k 的時候，front 會是歐式距離最大的點，將它 pop 掉，讓 size 維持在 <code>&lt;= k</code></li>
</ul>
</li>
<li>解法三：使用 min heap<ul>
<li>各個點進入 priority queue 的時候，自動按歐式距離升冪排序</li>
<li>最後 pop k 次，放入 <code>ret</code> 中並回傳之。</li>
</ul>
</li>
</ol>
<pre><code class="cpp">class Solution &#123;
 public:
  vector&lt;vector&lt;int&gt;&gt; kClosest(vector&lt;vector&lt;int&gt;&gt; &amp;points, int k) &#123;
    return kClosestMaxHeap(points, k);
  &#125;

 private:
  vector&lt;vector&lt;int&gt;&gt; kClosestSorting(vector&lt;vector&lt;int&gt;&gt; &amp;points, int k) &#123;
    std::sort(points.begin(),
              points.end(),
              [](const vector&lt;int&gt; &amp;p1, const vector&lt;int&gt; &amp;p2) &#123;
                return std::hypotf(p1[0], p1[1]) &lt; std::hypotf(p2[0], p2[1]);
              &#125;);

    return vector(points.begin(), points.begin() + k);
  &#125;

  vector&lt;vector&lt;int&gt;&gt; kClosestMaxHeap(vector&lt;vector&lt;int&gt;&gt; &amp;points, int k) &#123;
    priority_queue&lt;pair&lt;float, int&gt;&gt; pq;
    for (int i = 0; i &lt; points.size(); i++) &#123;
      const auto &amp;point = points[i];
      pq.push(&#123;std::hypotf(point[0], point[1]), i&#125;);
      if (pq.size() &gt; k) &#123;
        pq.pop();
      &#125;
    &#125;

    vector&lt;vector&lt;int&gt;&gt; ret;
    ret.reserve(k);
    while (pq.size()) &#123;
      ret.emplace_back(points[pq.top().second]);
      pq.pop();
    &#125;
    return ret;
  &#125;

  vector&lt;vector&lt;int&gt;&gt; kClosestMinHeap(vector&lt;vector&lt;int&gt;&gt; &amp;points, int k) &#123;
    // pair&lt;float, int&gt; =&gt; pair&lt;distance, points_idx&gt;
    // * sorted by distance in asc order =&gt; greater
    // * sorted by distance in desc order =&gt; less
    using T = pair&lt;float, int&gt;;
    priority_queue&lt;T, vector&lt;T&gt;, greater&lt;T&gt;&gt; pq;
    for (int i = 0; i &lt; points.size(); i++) &#123;
      const auto &amp;point = points[i];
      pq.push(&#123;std::hypotf(point[0], point[1]), i&#125;);
    &#125;

    vector&lt;vector&lt;int&gt;&gt; ret(k);
    for (int i = 0; i &lt; k; i++) &#123;
      ret[i] = points[pq.top().second];
      pq.pop();
    &#125;
    return ret;
  &#125;
&#125;;
</code></pre>
<h3 id="Longest-Substring-Without-Repeating-Characters"><a href="#Longest-Substring-Without-Repeating-Characters" class="headerlink" title="Longest Substring Without Repeating Characters"></a>Longest Substring Without Repeating Characters</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbG9uZ2VzdC1zdWJzdHJpbmctd2l0aG91dC1yZXBlYXRpbmctY2hhcmFjdGVycy8=">https://leetcode.com/problems/longest-substring-without-repeating-characters/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>string</code> <code>sliding window</code> <code>two pointers</code></p>
</blockquote>
<ol>
<li>Bruteforce<ul>
<li>選一個 begin<ul>
<li>選一個 end<ul>
<li>掃描 [begin, end] 內的字元是否有重複</li>
</ul>
</li>
</ul>
</li>
<li>O(N^3)</li>
</ul>
</li>
<li>Sliding Window<ul>
<li>準備一個 map<ul>
<li>key：s 中出現過的字元</li>
<li>value：該字元最後一次出現的 index</li>
</ul>
</li>
<li><code>l</code> 與 <code>r</code> 分別代表 window 左右界<ul>
<li>規則：window 中不可出現重複字元</li>
</ul>
</li>
<li>不斷擴張 window 右界，同時檢查此次擴張是否會使 window 變得不合法<ul>
<li>若合法，繼續擴張</li>
<li>不合法，必須讓它再次合法</li>
</ul>
</li>
<li>對於每個字元 c ∈ s，我們讓<ul>
<li>若 c 已經在目前的 window 內（即：l ≤ i ≤ r）<ul>
<li>則目前 window 已無效，故更新 <code>l</code> 為最後出現的 idx + 1 使得 window 再次合法</li>
</ul>
</li>
<li>用 <code>max()</code> 更新 <code>max_len</code>，最後回傳之</li>
<li>將 <code>c</code> 的最後出現 index（即：<code>r</code>）記下來</li>
</ul>
</li>
<li>O(N)</li>
</ul>
</li>
</ol>
<pre><code class="cpp">class Solution &#123;
 public:
  int lengthOfLongestSubstring(const string &amp;s) &#123;
    unordered_map&lt;char, int&gt; last_appeared_idx;
    int max_len = 0;

    for (int l = 0, r = 0; r &lt; s.size(); r++) &#123;
      // If this character has already appeared before,
      // and if it&#39;s within the current window...
      auto it = last_appeared_idx.find(s[r]);
      if (it != last_appeared_idx.end() &amp;&amp; it-&gt;second &gt;= l) &#123;
        l = it-&gt;second + 1;
      &#125;

      last_appeared_idx[s[r]] = r;
      max_len = std::max(max_len, r - l + 1);
    &#125;

    return max_len;
  &#125;
&#125;;
</code></pre>
<h3 id="3Sum"><a href="#3Sum" class="headerlink" title="3Sum"></a>3Sum</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvM3N1bS8=">https://leetcode.com/problems/3sum/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>array</code> <code>sorting</code> <code>two pointers</code></p>
</blockquote>
<ol>
<li>暴力解<ul>
<li>三層 for loop, 太蛋疼了, 和單戀一樣痛苦, 別浪費時間去想了</li>
<li>O(N^3)</li>
</ul>
</li>
<li>Two Pointers<ul>
<li>和 Two sum 不同之處在於, Two sum 要我們回傳 index, 但這題要回傳 value<ul>
<li>因此, Two sum 不能排序測資, 但 Three sum 可以</li>
</ul>
</li>
<li>兩層 for loop<ul>
<li>外層 for loop 固定一個數字</li>
<li>對該數字右邊的部分, 用 Two pointers 做類似 binary search 的事情<ul>
<li>如果 <code>nums[i] + nums[l] + nums[r] == 0</code>, 記錄下來, <code>l++; r--</code></li>
<li>如果 <code>nums[i] + nums[l] + nums[r] &lt; 0</code>, 代表需要大一點的數字, <code>l++</code></li>
<li>如果 <code>nums[i] + nums[l] + nums[r] &gt; 0</code>, 代表需要小一點的數字, <code>r++</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code class="cpp">class Solution &#123;
 public:
  vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt; &amp;nums) &#123;
    const int n = nums.size();
    set&lt;vector&lt;int&gt;&gt; triplets;

    std::sort(nums.begin(), nums.end());
    for (int i = 0; i &lt; n; i++) &#123;
      int l = i + 1;
      int r = n - 1;
      int sum;
      if (l &gt;= n || r &gt;= n) &#123;
        continue;
      &#125;
      while (l &lt; r) &#123;
        sum = nums[i] + nums[l] + nums[r];
        if (sum == 0) &#123;
          triplets.insert(&#123;nums[i], nums[l], nums[r]&#125;);
          l++;
          r--;
        &#125; else if (sum &lt; 0) &#123;
          l++;          
        &#125; else &#123;  // sum &gt; 0
          r--;
        &#125;
      &#125;
    &#125;

    return vector(triplets.begin(), triplets.end());
  &#125;
&#125;;
</code></pre>
<h3 id="Binary-Tree-Level-Order-Traversal"><a href="#Binary-Tree-Level-Order-Traversal" class="headerlink" title="Binary Tree Level Order Traversal"></a>Binary Tree Level Order Traversal</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtbGV2ZWwtb3JkZXItdHJhdmVyc2FsLw==">https://leetcode.com/problems/binary-tree-level-order-traversal/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>binary tree</code> <code>single-source bfs</code></p>
</blockquote>
<pre><code class="cpp">class Solution &#123;
 public:
  vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode *root) &#123;
    if (!root) &#123;
      return &#123;&#125;;
    &#125;
 
    vector&lt;vector&lt;int&gt;&gt; ret;
    queue&lt;TreeNode *&gt; q;

    q.push(root);
    while (q.size()) &#123;
      ret.push_back(&#123;&#125;);

      int len = q.size();
      for (int i = 0; i &lt; len; i++) &#123;
        TreeNode *curr = q.front();
        q.pop();
        ret.back().push_back(curr-&gt;val);

        if (curr-&gt;left) &#123;
          q.push(curr-&gt;left);
        &#125;
        if (curr-&gt;right) &#123;
          q.push(curr-&gt;right);
        &#125;
      &#125;
    &#125;

    return ret;
  &#125;
&#125;;
</code></pre>
<h3 id="Clone-Graph"><a href="#Clone-Graph" class="headerlink" title="Clone Graph"></a>Clone Graph</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY2xvbmUtZ3JhcGgv">https://leetcode.com/problems/clone-graph/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>graph</code> <code>dfs</code> <code>unordered_map</code></p>
</blockquote>
<p>開一個 unordered_map 紀錄 old node -&gt; new node 的映射關係。</p>
<pre><code class="cpp">class Solution &#123;
 public:
  Node *cloneGraph(Node *node) &#123;
    if (!node) &#123;
      return nullptr;
    &#125;

    if (auto it = old_to_new_.find(node); it != old_to_new_.end()) &#123;
      return it-&gt;second;
    &#125;

    auto cloned_node = new Node(node-&gt;val);
    cloned_node-&gt;neighbors.reserve(node-&gt;neighbors.size());
    old_to_new_.emplace(node, cloned_node);

    for (const auto neighbor : node-&gt;neighbors) &#123;
      auto cloned_neighbor = cloneGraph(neighbor);
      cloned_node-&gt;neighbors.emplace_back(cloned_neighbor);
    &#125;

    return cloned_node;
  &#125;

 private:
  unordered_map&lt;Node *, Node *&gt; old_to_new_;
&#125;;
</code></pre>
<h3 id="Evaluate-Reverse-Polish-Notation"><a href="#Evaluate-Reverse-Polish-Notation" class="headerlink" title="Evaluate Reverse Polish Notation"></a>Evaluate Reverse Polish Notation</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvZXZhbHVhdGUtcmV2ZXJzZS1wb2xpc2gtbm90YXRpb24v">https://leetcode.com/problems/evaluate-reverse-polish-notation/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>stack</code></p>
</blockquote>
<p>開一個 stack，正向掃 <code>tokens</code></p>
<ul>
<li>遇到 operand 就 push to stack</li>
<li>遇到 operator 就 pop from stack 兩次，運算完將結果再次 push to stack</li>
<li>最後答案會在 stack top</li>
</ul>
<pre><code class="cpp">class Solution &#123;
 public:
  int evalRPN(const vector&lt;string&gt; &amp;tokens) &#123;
    stack&lt;int&gt; st; 

    for (const auto &amp;token : tokens) &#123;
      if (!isOperator(token)) &#123;
        st.push(std::atoi(token.c_str()));
        continue;
      &#125;

      int operand2 = st.top();
      st.pop();
      int operand1 = st.top();
      st.pop();
      st.push(eval(token[0], operand1, operand2));
    &#125;

    return st.top();
  &#125;

 private:
  bool isOperator(const string &amp;token) &#123;
    return token == &quot;+&quot; || token == &quot;-&quot; || token == &quot;*&quot; || token == &quot;/&quot;;
  &#125;

  int eval(const char op, const int operand1, const int operand2) &#123;
    switch (op) &#123;
    case &#39;+&#39;:
      return operand1 + operand2;
    case &#39;-&#39;:
      return operand1 - operand2;
    case &#39;*&#39;:
      return operand1 * operand2;
    case &#39;/&#39;:
      return operand1 / operand2;
    default:
      return 0;
    &#125;
  &#125;
&#125;;
</code></pre>
<h2 id="Week-4"><a href="#Week-4" class="headerlink" title="Week 4"></a>Week 4</h2><h3 id="Course-Schedule"><a href="#Course-Schedule" class="headerlink" title="Course Schedule"></a>Course Schedule</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY291cnNlLXNjaGVkdWxlLw==">https://leetcode.com/problems/course-schedule/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>digraph</code> <code>single-source bfs</code></p>
</blockquote>
<p>使用 single-source BFS 檢查 directed graph 是否有 cyclic path</p>
<ul>
<li>每個有 outgoing edge 的 node 都檢查</li>
<li>只要 BFS 會走回自己, 就有 cyclic path</li>
</ul>
<pre><code class="cpp">class Solution &#123;
  using AdjacencyList = vector&lt;vector&lt;int&gt;&gt;;
  using Digraph = AdjacencyList;

 public:
  bool canFinish(const int n, const vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) &#123;
    if (prerequisites.empty()) &#123;
      return true;
    &#125;

    Digraph digraph = buildDigraph(n, prerequisites);
    for (int i = 0; i &lt; n; i++) &#123;
      if (hasCyclicPath(digraph, i)) &#123;
        return false;
      &#125;
    &#125;
    return true;
  &#125;

 private:
  Digraph buildDigraph(const int n, const vector&lt;vector&lt;int&gt;&gt; &amp;edges) &#123;
    Digraph digraph(n);
    for (const auto &amp;edge : edges) &#123;
      const int src = edge[0];
      const int dst = edge[1];
      digraph[src].emplace_back(dst);
    &#125;
    return digraph;
  &#125;

  bool hasCyclicPath(const Digraph &amp;digraph, const int src) &#123;
    vector&lt;bool&gt; visited(digraph.size(), false);
    queue&lt;int&gt; q;

    q.push(src);
    while (q.size()) &#123;
      int len = q.size();
      for (int i = 0; i &lt; len; i++) &#123;
        const auto node = q.front();
        q.pop();

        for (int j = 0; j &lt; digraph[node].size(); j++) &#123;
          const auto neighbor = digraph[node][j];
          if (neighbor == src) &#123;
            return true;
          &#125;
          if (!visited[neighbor]) &#123;
            q.push(neighbor);
          &#125;
          visited[neighbor] = true;
        &#125;
      &#125;
    &#125;
    return false;
  &#125;
&#125;;
</code></pre>
<h3 id="Implement-Trie-Prefix-Tree"><a href="#Implement-Trie-Prefix-Tree" class="headerlink" title="Implement Trie (Prefix Tree)"></a>Implement Trie (Prefix Tree)</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaW1wbGVtZW50LXRyaWUtcHJlZml4LXRyZWUv">https://leetcode.com/problems/implement-trie-prefix-tree/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>trie</code></p>
</blockquote>
<ul>
<li><code>Trie::search()</code> 記得檢查 end of word mark, <code>Trie::startsWith()</code> 不需要。</li>
<li>經過實測，<code>Trie::Node::children</code> 用 <code>vector/list</code> 去做是最快的，用 <code>map/unordered_map</code> 反而慢了。</li>
</ul>
<pre><code class="cpp">class Trie &#123;
 private:
  struct Node &#123;
    char val;
    map&lt;char, Node&gt; children;
    bool end_of_word;
  &#125;;

 public:
  Trie() : root_() &#123;&#125;
 
  void insert(const string &amp;word) &#123;
    Node *curr = &amp;root_;
    for (const auto c : word) &#123;
      Node new_node = &#123;c, &#123;&#125;, false&#125;;
      const auto [it, _] = curr-&gt;children.emplace(c, std::move(new_node));
      curr = &amp;it-&gt;second;
    &#125;
    curr-&gt;end_of_word = true;
  &#125;
    
  bool search(const string &amp;word) &#123;
    Node *node = walk(word);
    return node ? node-&gt;end_of_word : false;
  &#125;
    
  bool startsWith(const string &amp;prefix) &#123;
    return walk(prefix);
  &#125;

 private:
  Node *walk(const string &amp;s) &#123;
    Node *curr = &amp;root_;
    for (const auto c : s) &#123;
      auto it = curr-&gt;children.find(c);
      if (it != curr-&gt;children.end()) &#123;
        curr = &amp;it-&gt;second;
        continue;
      &#125;
      return nullptr;
    &#125;
    return curr;
  &#125;

  Node root_;
&#125;;

/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj-&gt;insert(word);
 * bool param_2 = obj-&gt;search(word);
 * bool param_3 = obj-&gt;startsWith(prefix);
 */
</code></pre>
<h3 id="Coin-Change"><a href="#Coin-Change" class="headerlink" title="Coin Change"></a>Coin Change</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY29pbi1jaGFuZ2Uv">https://leetcode.com/problems/coin-change/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>dynamic programming</code></p>
</blockquote>
<ul>
<li>DP<ul>
<li>bottom up 建表</li>
<li><code>dp[0]</code> 代表 0 元只能用 0 個硬幣湊出來（相當合理）</li>
<li><code>dp[i] = min(dp[i], dp[i - coin] + 1)</code> 為狀態轉移方程<ul>
<li>如果我們要湊出金額 i，那麼我們可以從 i - coin 的金額狀態湊出來，再加上一個面值為 coin 的硬幣，即可湊出金額 i</li>
<li>因此 dp[i] 的值應該是在所有可能的 i - coin 狀態中取最小值加 1。</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="cpp">class Solution &#123;
 public:
  int coinChange(const vector&lt;int&gt; &amp;coins, const int amount) &#123;
    constexpr int kMax = 10005;
    vector&lt;int&gt; dp(kMax, amount + 1);
    dp[0] = 0;

    for (const auto coin : coins) &#123;
      for (int i = coin; i &lt; kMax; i++) &#123;
        dp[i] = std::min(dp[i], dp[i - coin] + 1);
      &#125;
    &#125;
    return dp[amount] == amount + 1 ? -1 : dp[amount];
  &#125;
&#125;;
</code></pre>
<h3 id="Product-of-Array-Except-Self"><a href="#Product-of-Array-Except-Self" class="headerlink" title="Product of Array Except Self"></a>Product of Array Except Self</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcHJvZHVjdC1vZi1hcnJheS1leGNlcHQtc2VsZi8=">https://leetcode.com/problems/product-of-array-except-self/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>array</code> <code>dynamic programming</code></p>
</blockquote>
<ol>
<li>Bruteforce<ul>
<li>選定第 i 個元素，計算其 product of array except self</li>
<li>從頭到尾掃一次，遇到自己就跳過</li>
<li>O(N^2)</li>
</ul>
</li>
<li>一維 DP<ul>
<li>準備兩個 vector<ul>
<li><code>l_prod</code> ：自己以左（不含自己）所有元素的積，如：[1, 1, 2, 6]，從左到右建</li>
<li><code>r_prod</code> ：自己以右（不含自己）所有元素的積，如：[24, 12, 4, 1]，從右到左建</li>
</ul>
</li>
<li>將 <code>l_prod</code> 與 <code>r_prod</code> 相同 index 的元素乘起來就是答案</li>
<li>O(N)</li>
</ul>
</li>
</ol>
<pre><code class="cpp">class Solution &#123;
 public:
  vector&lt;int&gt; productExceptSelf(const vector&lt;int&gt;&amp; nums) &#123;
    const size_t n = nums.size();

    vector&lt;int&gt; l_prod(n, 1);
    for (int i = 1; i &lt; n; i++) &#123;
      l_prod[i] = l_prod[i - 1] * nums[i - 1];
    &#125;

    vector&lt;int&gt; r_prod(n, 1);
    r_prod[n - 1] = 1;
    for (int i = n - 2; i &gt;= 0; i--) &#123;
      r_prod[i] = r_prod[i + 1] * nums[i + 1];
    &#125;

    vector&lt;int&gt; ret(n);
    for (int i = 0; i &lt; n; i++) &#123;
      ret[i] = l_prod[i] * r_prod[i];
    &#125;
    return ret;
  &#125;
&#125;;
</code></pre>
<h3 id="Min-Stack"><a href="#Min-Stack" class="headerlink" title="Min Stack"></a>Min Stack</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWluLXN0YWNrLw==">https://leetcode.com/problems/min-stack/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>stack</code> <code>design</code></p>
</blockquote>
<p>讓 current value 與 current min 同進退。</p>
<pre><code class="cpp">class MinStack &#123;
 public:
  MinStack() : stack_() &#123;&#125;

  void push(int val) &#123;
    if (stack_.empty()) &#123;
      stack_.push(&#123;val, val&#125;);
    &#125; else &#123;
      stack_.push(&#123;val, std::min(val, stack_.top().second)&#125;);
    &#125;
  &#125;
    
  void pop() &#123;
    stack_.pop();
  &#125;
    
  int top() &#123;
    return stack_.top().first;
  &#125;
 
  int getMin() &#123;
    return stack_.top().second;
  &#125;

 private:
  stack&lt;pair&lt;int, int&gt;&gt; stack_;
&#125;;

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj-&gt;push(val);
 * obj-&gt;pop();
 * int param_3 = obj-&gt;top();
 * int param_4 = obj-&gt;getMin();
 */
</code></pre>
<h3 id="Validate-Binary-Search-Tree"><a href="#Validate-Binary-Search-Tree" class="headerlink" title="Validate Binary Search Tree"></a>Validate Binary Search Tree</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdmFsaWRhdGUtYmluYXJ5LXNlYXJjaC10cmVlLw==">https://leetcode.com/problems/validate-binary-search-tree/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>binary search tree</code></p>
</blockquote>
<ul>
<li>誤區：不能單純檢查每個 node 的關係是否為 <code>node-&gt;left-&gt;val &lt; node-&gt;val &lt; node-&gt;right-&gt;val</code></li>
<li>正解：遞迴檢查 <code>node-&gt;val</code> 是否介於 lowerbound 與 upperbound 之間<ul>
<li>往左 subtree 走時，lowerbound 不變，upperbound 改為自己 (node-&gt;val)</li>
<li>往右 subtree 走時，lowerbound 改為自己 (node-&gt;val)，upperbound 不變</li>
</ul>
</li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1zNkFURWtpcHpvdw==">https://www.youtube.com/watch?v=s6ATEkipzow</span></li>
</ul>
<pre><code class="cpp">class Solution &#123;
 public:
  bool isValidBST(TreeNode *root) &#123;
    return isValidBSTImpl(root,
                          std::numeric_limits&lt;int64_t&gt;::min(),
                          std::numeric_limits&lt;int64_t&gt;::max());
  &#125;

 private:
  bool isValidBSTImpl(TreeNode *node, const int64_t lowerbound, const int64_t upperbound) &#123;
    if (!node) &#123;
      return true;
    &#125;

    if (node-&gt;val &lt;= lowerbound || node-&gt;val &gt;= upperbound) &#123;
      return false;
    &#125;

    return isValidBSTImpl(node-&gt;left, lowerbound, node-&gt;val) &amp;&amp;
           isValidBSTImpl(node-&gt;right, node-&gt;val, upperbound);
  &#125;
&#125;;
</code></pre>
<h2 id="Week-5"><a href="#Week-5" class="headerlink" title="Week 5"></a>Week 5</h2><h3 id="Merge-Intervals"><a href="#Merge-Intervals" class="headerlink" title="Merge Intervals"></a>Merge Intervals</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWVyZ2UtaW50ZXJ2YWxzLw==">https://leetcode.com/problems/merge-intervals/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>array</code> <code>interval</code></p>
</blockquote>
<ul>
<li>因為測資會有 unsorted intervals，所以要先對 intervals 根據左界進行 ascending 排序</li>
<li>掃一次 intervals<ul>
<li>與 last merged interval 無 overlap：就直接 append</li>
<li>與 last merged interval 有 overlap：更新右界，看是原本的大，還是新的大</li>
</ul>
</li>
</ul>
<pre><code class="cpp">class Solution &#123;
 public:
  vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt; &amp;intervals) &#123;
    std::sort(intervals.begin(),
              intervals.end(),
              [](const auto &amp;i1, const auto &amp;i2) &#123;
                if (i1[0] &lt; i2[0]) return true;
                if (i1[0] &gt; i2[0]) return false;
                if (i1[1] &lt; i2[1]) return true;
                if (i1[1] &gt; i2[1]) return false;
                return false;
              &#125;);

    vector&lt;vector&lt;int&gt;&gt; ret;
    for (int i = 0; i &lt; intervals.size(); i++) &#123;
      const auto &amp;interval = intervals[i];
      if (ret.empty() || ret.back()[1] &lt; interval[0]) &#123;  // not overlapped
        ret.emplace_back(interval);
      &#125; else &#123;  // overlapped
        ret.back()[1] = std::max(ret.back()[1], interval[1]);
      &#125;
    &#125;
    return ret;
  &#125;
&#125;;
</code></pre>
<h3 id="Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="Lowest Common Ancestor of a Binary Tree"></a>Lowest Common Ancestor of a Binary Tree</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbG93ZXN0LWNvbW1vbi1hbmNlc3Rvci1vZi1hLWJpbmFyeS10cmVlLw==">https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>binary tree</code></p>
</blockquote>
<ol>
<li>使用 recursion + backtracking 維護 current path<ul>
<li>遇到 p 就複製 current path 到 path of p</li>
<li>遇到 q 就複製 current path 到 path of q</li>
<li>當 path of p 和 path of q 都準備好時，尋找 longest common prefix 中的最後一個 node</li>
</ul>
</li>
<li>使用 recursion<ul>
<li>找到 p 就回傳 p, 找到 q 就回傳 q, 沒找到就回 nullptr</li>
<li>左右 subtree 都 non-null 時，該 node 就是答案</li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1Lb2JRY3hkYVpLWQ==">https://www.youtube.com/watch?v=KobQcxdaZKY</span></li>
</ul>
</li>
</ol>
<pre><code class="cpp">class Solution &#123;
 public:
  TreeNode* lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) &#123;
    if (!root) &#123;
      return nullptr;
    &#125;

    if (root == p || root == q) &#123;
      return root;
    &#125;

    TreeNode *l = lowestCommonAncestor(root-&gt;left, p, q);
    TreeNode *r = lowestCommonAncestor(root-&gt;right, p, q);
    if (l &amp;&amp; r) &#123;
      return root;
    &#125; else if (l &amp;&amp; !r) &#123;
      return l;
    &#125; else if (!l &amp;&amp; r) &#123;
      return r;
    &#125; else &#123;
      return nullptr;
    &#125;
  &#125;
&#125;;
</code></pre>
<h2 id="Week-6"><a href="#Week-6" class="headerlink" title="Week 6"></a>Week 6</h2><h3 id="Binary-Tree-Right-Side-View"><a href="#Binary-Tree-Right-Side-View" class="headerlink" title="Binary Tree Right Side View"></a>Binary Tree Right Side View</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtcmlnaHQtc2lkZS12aWV3Lw==">https://leetcode.com/problems/binary-tree-right-side-view/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>binary tree</code> <code>bfs</code></p>
</blockquote>
<p>用 binary tree BFS 搜集各個 level 的 values, 最後將每個 level 的 last node val 放到一個 vector 回傳。</p>
<pre><code class="cpp">class Solution &#123;
 public:
  vector&lt;int&gt; rightSideView(TreeNode *root) &#123;
    if (!root) &#123;
      return &#123;&#125;;
    &#125;
 
    vector&lt;vector&lt;int&gt;&gt; levels;
    queue&lt;TreeNode *&gt; q;

    q.push(root);
    while (q.size()) &#123;
      levels.emplace_back();
      int len = q.size();
      for (int i = 0; i &lt; len; i++) &#123;
        auto node = q.front();
        q.pop();

        levels.back().emplace_back(node-&gt;val);

        if (node-&gt;left) &#123;
          q.push(node-&gt;left);
        &#125;
        if (node-&gt;right) &#123;
          q.push(node-&gt;right);
        &#125;
      &#125;
    &#125;

    vector&lt;int&gt; ret(levels.size());
    for (int i = 0; i &lt; ret.size(); i++) &#123;
      ret[i] = levels[i].back();
    &#125;
    return ret;
  &#125;
&#125;;
</code></pre>
<h3 id="Longest-Palindromic-Substring"><a href="#Longest-Palindromic-Substring" class="headerlink" title="Longest Palindromic Substring"></a>Longest Palindromic Substring</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbG9uZ2VzdC1wYWxpbmRyb21pYy1zdWJzdHJpbmcv">https://leetcode.com/problems/longest-palindromic-substring/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>string</code></p>
</blockquote>
<ul>
<li>Expand around center, 分為兩種情況<ul>
<li>palindromic substring 長度為 odd</li>
<li>palindromic substring 長度為 even</li>
</ul>
</li>
<li>用 string_view 避免 excessive copying</li>
</ul>
<pre><code class="cpp">class Solution &#123;
 public:
  string longestPalindrome(const string &amp;s) &#123;
    string_view ret;
    
    for (int i = 0; i &lt; s.size(); i++) &#123;
      string_view candidate = expandAroundCenter(s, i, i);
      if (candidate.size() &gt; ret.size()) &#123;
        ret = candidate;
      &#125;
    &#125;

    for (int i = 0; i &lt; s.size() - 1; i++) &#123;
      string_view candidate = expandAroundCenter(s, i, i + 1);
      if (candidate.size() &gt; ret.size()) &#123;
        ret = candidate;
      &#125;
    &#125;

    return string(ret.begin(), ret.end());
  &#125;

 private:
  string_view expandAroundCenter(const string &amp;s, const int src1, const int src2) &#123;
    string_view ret;
    int l = src1;
    int r = src2;

    while (l &gt;= 0 &amp;&amp; r &lt; s.size() &amp;&amp; s[l] == s[r]) &#123;
      string_view candidate(s.data() + l, r - l + 1);
      if (candidate.size() &gt; ret.size()) &#123;
        ret = candidate;
      &#125;
      l--;
      r++;
    &#125;
    return ret;
  &#125;
&#125;;
</code></pre>
<h3 id="Unique-Paths"><a href="#Unique-Paths" class="headerlink" title="Unique Paths"></a>Unique Paths</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdW5pcXVlLXBhdGhzLw==">https://leetcode.com/problems/unique-paths/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>matrix</code> <code>dynamic programming</code></p>
</blockquote>
<ul>
<li>DP<ul>
<li><code>dp</code> 是一個二維 m x n matrix (m rows, n cols)<ul>
<li>每一格代表：從左上角走到該點的總方法數</li>
<li>第一個 row 的所有格子填入 0</li>
<li>第一個 col 的所有格子填入 0</li>
</ul>
</li>
<li>每次移動只能往右、往下<ul>
<li>也就是說，抵達每個格子的方法數 = 左邊來的方法數 + 上面來的方法數</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="cpp">class Solution &#123;
 public:
  int uniquePaths(int m, int n) &#123;
    int dp[m][n];
    memset(dp, 0, sizeof(dp));

    for (int i = 0; i &lt; m; i++) &#123;
      dp[i][0] = 1;
    &#125;
    for (int i = 0; i &lt; n; i++) &#123;
      dp[0][i] = 1;
    &#125;

    for (int i = 1; i &lt; m; i++) &#123;
      for (int j = 1; j &lt; n; j++) &#123;
        dp[i][j] += dp[i - 1][j] + dp[i][j - 1];
      &#125;
    &#125;
    return dp[m - 1][n - 1];
  &#125;
&#125;;
</code></pre>
<h3 id="Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="Construct Binary Tree from Preorder and Inorder Traversal"></a>Construct Binary Tree from Preorder and Inorder Traversal</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY29uc3RydWN0LWJpbmFyeS10cmVlLWZyb20tcHJlb3JkZXItYW5kLWlub3JkZXItdHJhdmVyc2FsLw==">https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>binary tree</code></p>
</blockquote>
<ul>
<li>preorder 的第一個節點是 root<ul>
<li>用 root 的值, 定位到 inorder root 的 index</li>
</ul>
</li>
<li>inorder root 以左為 left subtree, 以右為 right subtree<ul>
<li>做出 left subtree 的 preorder &amp; inorder</li>
<li>做出 right subtree 的 preorder &amp; inorder</li>
<li>遞迴處理</li>
</ul>
</li>
</ul>
<pre><code class="cpp">class Solution &#123;
 public:
  TreeNode *buildTree(const vector&lt;int&gt; &amp;preorder, const vector&lt;int&gt; &amp;inorder) &#123;
    if (preorder.empty()) &#123;
      return nullptr;
    &#125;

    auto root_inorder_it = std::find(inorder.begin(), inorder.end(), preorder.front());
    if (root_inorder_it == inorder.end()) &#123;
      return nullptr;
    &#125;

    TreeNode *root = new TreeNode(preorder.front());

    vector&lt;int&gt; left_subtree_inorder(inorder.begin(), root_inorder_it);
    vector&lt;int&gt; left_subtree_preorder(
        preorder.begin() + 1, preorder.begin() + 1 + left_subtree_inorder.size());
    root-&gt;left = buildTree(left_subtree_preorder, left_subtree_inorder);

    vector&lt;int&gt; right_subtree_inorder(root_inorder_it + 1, inorder.end());
    vector&lt;int&gt; right_subtree_preorder(
        preorder.begin() + 1 + left_subtree_preorder.size(), preorder.end());
    root-&gt;right = buildTree(right_subtree_preorder, right_subtree_inorder);

    return root;
  &#125;
&#125;;
</code></pre>
<h2 id="Week-7"><a href="#Week-7" class="headerlink" title="Week 7"></a>Week 7</h2><h3 id="Container-With-Most-Water"><a href="#Container-With-Most-Water" class="headerlink" title="Container With Most Water"></a>Container With Most Water</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY29udGFpbmVyLXdpdGgtbW9zdC13YXRlci8=">https://leetcode.com/problems/container-with-most-water/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>array</code> <code>two pointers</code> <code>greedy</code></p>
</blockquote>
<ul>
<li>Greedy: Make the locally optimal choice at each stage.<ul>
<li>two pointers <code>l</code> <code>r</code>, 從最外面開始往內檢查</li>
<li>計算當下的面積, 必要時更新 <code>max_area</code></li>
<li>比較 <code>height[l]</code> 和 <code>height[r]</code>, 較小者往中間走, 嘗試讓它更高</li>
</ul>
</li>
</ul>
<pre><code class="cpp">class Solution &#123;
 public:
  int maxArea(vector&lt;int&gt;&amp; height) &#123;
    int l = 0;
    int r = height.size() - 1;
    int max_area = 0;

    while (l &lt; r) &#123;
      int area = (r - l) * std::min(height[l], height[r]);
      max_area = std::max(max_area, area);

      if (height[l] &lt;= height[r]) &#123;
        l++;
      &#125; else &#123;
        r--;
      &#125;
    &#125;

    return max_area;
  &#125;
&#125;;
</code></pre>
<h3 id="LRU-Cache"><a href="#LRU-Cache" class="headerlink" title="LRU Cache"></a>LRU Cache</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbHJ1LWNhY2hlLw==">https://leetcode.com/problems/lru-cache/</span><br><strong>難度：</strong> Medium<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>hash table</code> <code>linked list</code> <code>design</code></p>
</blockquote>
<ul>
<li>資料結構<ul>
<li><code>unordered_map</code> 存放 key-value mapping</li>
<li><code>list</code> 存放 LRU keys</li>
<li>再加開一個 <code>unordered_map</code> 存放 key to LRU-keys-list-iterator 的 mapping =&gt; Promote: O(1)</li>
</ul>
</li>
<li>get() 和 put() existing key 要記得 promote 該 key 為 MRU<ul>
<li>可以用 list::splice() 將 list 的 last element 移動到 list head</li>
</ul>
</li>
</ul>
<pre><code class="cpp">class LRUCache &#123;
 public:
  LRUCache(int capacity)
      : capacity_(capacity),
        map_(),
        iter_cache_(),
        lru_keys_() &#123;&#125;
 
  int get(int key) &#123;
    auto it = map_.find(key);
    if (it == map_.end()) &#123;
      return -1;
    &#125;

    // If key already exists, promote the key as MRU.
    lru_keys_.splice(lru_keys_.begin(), lru_keys_, iter_cache_[key]);
    return it-&gt;second;
  &#125;
 
  void put(int key, int value) &#123;
    // If key already exists, promote the key as MRU.
    auto it = map_.find(key);
    if (it != map_.end()) &#123;
      it-&gt;second = value;
      lru_keys_.splice(lru_keys_.begin(), lru_keys_, iter_cache_[key]);
      return;
    &#125;

    // Evict the LRU entry.
    if (map_.size() &gt;= capacity_) &#123;
      map_.erase(lru_keys_.back());
      iter_cache_.erase(key);
      lru_keys_.pop_back();
    &#125;

    map_.emplace(key, value);
    lru_keys_.emplace_front(key);
    iter_cache_.emplace(key, lru_keys_.begin());
  &#125;

 private:
  int capacity_;
  std::unordered_map&lt;int, int&gt; map_;
  std::unordered_map&lt;int, std::list&lt;int&gt;::iterator&gt; iter_cache_;
  std::list&lt;int&gt; lru_keys_;
&#125;;
</code></pre>
<h2 id="Week-8"><a href="#Week-8" class="headerlink" title="Week 8"></a>Week 8</h2><h3 id="Trapping-Rain-Water"><a href="#Trapping-Rain-Water" class="headerlink" title="Trapping Rain Water"></a>Trapping Rain Water</h3><blockquote>
<p><strong>題目：</strong> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdHJhcHBpbmctcmFpbi13YXRlci8=">https://leetcode.com/problems/trapping-rain-water/</span><br><strong>難度：</strong> Hard<br><strong>語言：</strong> C++17<br><strong>技巧：</strong> <code>array</code> <code>dynamic programming</code></p>
</blockquote>
<ul>
<li>對於每個點，我們需要知道<ul>
<li>左邊最高高度</li>
<li>右邊最高高度</li>
</ul>
</li>
<li>然後就可以算每個點能累積多少單位的水，加總即答案</li>
</ul>
<pre><code class="cpp">class Solution &#123;
 public:
  int trap(const vector&lt;int&gt; &amp;height) &#123;
    const int n = height.size();

    vector&lt;int&gt; l_highest(n, 0); 
    for (int i = 1; i &lt; n; i++) &#123;
      l_highest[i] = std::max(l_highest[i - 1], height[i - 1]);
    &#125;

    vector&lt;int&gt; r_highest(n, 0);
    for (int i = n - 2; i &gt;= 0; i--) &#123;
      r_highest[i] = std::max(r_highest[i + 1], height[i + 1]);
    &#125;

    int total_area = 0;
    for (int i = 0; i &lt; n; i++) &#123;
      int local_area = std::min(l_highest[i], r_highest[i]) - height[i];
      if (local_area &gt; 0) &#123;
        total_area += local_area;
      &#125;
    &#125;
    return total_area;
  &#125;
&#125;;
</code></pre>

  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2023-04-14 00:23:35" itemprop="dateModified" datetime="2023-04-14T00:23:35+08:00">2023-04-14</time>
  </span>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>Post author:  </strong>aesophor <i class="ic i-at"><em>@</em></i>
  </li>
  <li class="link">
    <strong>Post link: </strong>
    <a href="https://aesophor.github.io/leetcode/grind75.html" title="LeetCode Grind75">https://aesophor.github.io/leetcode/grind75.html</a>
  </li>
  <li class="license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Grind-75"><span class="toc-number">1.</span> <span class="toc-text">Grind 75</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Week-1"><span class="toc-number">1.1.</span> <span class="toc-text">Week 1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Two-Sum"><span class="toc-number">1.1.1.</span> <span class="toc-text">Two Sum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Valid-Parentheses"><span class="toc-number">1.1.2.</span> <span class="toc-text">Valid Parentheses</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Merge-Two-Sorted-Lists"><span class="toc-number">1.1.3.</span> <span class="toc-text">Merge Two Sorted Lists</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Best-Time-to-Buy-and-Sell-Stock"><span class="toc-number">1.1.4.</span> <span class="toc-text">Best Time to Buy and Sell Stock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Valid-Palindrome"><span class="toc-number">1.1.5.</span> <span class="toc-text">Valid Palindrome</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Invert-Binary-Tree"><span class="toc-number">1.1.6.</span> <span class="toc-text">Invert Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Valid-Anagram"><span class="toc-number">1.1.7.</span> <span class="toc-text">Valid Anagram</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binary-Search"><span class="toc-number">1.1.8.</span> <span class="toc-text">Binary Search</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flood-Fill"><span class="toc-number">1.1.9.</span> <span class="toc-text">Flood Fill</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><span class="toc-number">1.1.10.</span> <span class="toc-text">Lowest Common Ancestor of a Binary Search Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Balanced-Binary-Tree"><span class="toc-number">1.1.11.</span> <span class="toc-text">Balanced Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linked-List-Cycle"><span class="toc-number">1.1.12.</span> <span class="toc-text">Linked List Cycle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Implement-Queue-using-Stacks"><span class="toc-number">1.1.13.</span> <span class="toc-text">Implement Queue using Stacks</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Week-2"><span class="toc-number">1.2.</span> <span class="toc-text">Week 2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#First-Bad-Version"><span class="toc-number">1.2.1.</span> <span class="toc-text">First Bad Version</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ransom-Note"><span class="toc-number">1.2.2.</span> <span class="toc-text">Ransom Note</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Climbing-Stairs"><span class="toc-number">1.2.3.</span> <span class="toc-text">Climbing Stairs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Longest-Palindrome"><span class="toc-number">1.2.4.</span> <span class="toc-text">Longest Palindrome</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reverse-Linked-List"><span class="toc-number">1.2.5.</span> <span class="toc-text">Reverse Linked List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Majority-Element"><span class="toc-number">1.2.6.</span> <span class="toc-text">Majority Element</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Diameter-of-Binary-Tree"><span class="toc-number">1.2.7.</span> <span class="toc-text">Diameter of Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Add-Binary"><span class="toc-number">1.2.8.</span> <span class="toc-text">Add Binary</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Middle-of-the-Linked-List"><span class="toc-number">1.2.9.</span> <span class="toc-text">Middle of the Linked List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Maximum-Depth-of-Binary-Tree"><span class="toc-number">1.2.10.</span> <span class="toc-text">Maximum Depth of Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Contains-Duplicate"><span class="toc-number">1.2.11.</span> <span class="toc-text">Contains Duplicate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Maximum-Subarray"><span class="toc-number">1.2.12.</span> <span class="toc-text">Maximum Subarray</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Week-3"><span class="toc-number">1.3.</span> <span class="toc-text">Week 3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Insert-Interval"><span class="toc-number">1.3.1.</span> <span class="toc-text">Insert Interval</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#01-Matrix"><span class="toc-number">1.3.2.</span> <span class="toc-text">01 Matrix</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#K-Closest-Points-to-Origin"><span class="toc-number">1.3.3.</span> <span class="toc-text">K Closest Points to Origin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Longest-Substring-Without-Repeating-Characters"><span class="toc-number">1.3.4.</span> <span class="toc-text">Longest Substring Without Repeating Characters</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3Sum"><span class="toc-number">1.3.5.</span> <span class="toc-text">3Sum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binary-Tree-Level-Order-Traversal"><span class="toc-number">1.3.6.</span> <span class="toc-text">Binary Tree Level Order Traversal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Clone-Graph"><span class="toc-number">1.3.7.</span> <span class="toc-text">Clone Graph</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Evaluate-Reverse-Polish-Notation"><span class="toc-number">1.3.8.</span> <span class="toc-text">Evaluate Reverse Polish Notation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Week-4"><span class="toc-number">1.4.</span> <span class="toc-text">Week 4</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Course-Schedule"><span class="toc-number">1.4.1.</span> <span class="toc-text">Course Schedule</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Implement-Trie-Prefix-Tree"><span class="toc-number">1.4.2.</span> <span class="toc-text">Implement Trie (Prefix Tree)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Coin-Change"><span class="toc-number">1.4.3.</span> <span class="toc-text">Coin Change</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Product-of-Array-Except-Self"><span class="toc-number">1.4.4.</span> <span class="toc-text">Product of Array Except Self</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Min-Stack"><span class="toc-number">1.4.5.</span> <span class="toc-text">Min Stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Validate-Binary-Search-Tree"><span class="toc-number">1.4.6.</span> <span class="toc-text">Validate Binary Search Tree</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Week-5"><span class="toc-number">1.5.</span> <span class="toc-text">Week 5</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Merge-Intervals"><span class="toc-number">1.5.1.</span> <span class="toc-text">Merge Intervals</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lowest-Common-Ancestor-of-a-Binary-Tree"><span class="toc-number">1.5.2.</span> <span class="toc-text">Lowest Common Ancestor of a Binary Tree</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Week-6"><span class="toc-number">1.6.</span> <span class="toc-text">Week 6</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Binary-Tree-Right-Side-View"><span class="toc-number">1.6.1.</span> <span class="toc-text">Binary Tree Right Side View</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Longest-Palindromic-Substring"><span class="toc-number">1.6.2.</span> <span class="toc-text">Longest Palindromic Substring</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unique-Paths"><span class="toc-number">1.6.3.</span> <span class="toc-text">Unique Paths</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><span class="toc-number">1.6.4.</span> <span class="toc-text">Construct Binary Tree from Preorder and Inorder Traversal</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Week-7"><span class="toc-number">1.7.</span> <span class="toc-text">Week 7</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Container-With-Most-Water"><span class="toc-number">1.7.1.</span> <span class="toc-text">Container With Most Water</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LRU-Cache"><span class="toc-number">1.7.2.</span> <span class="toc-text">LRU Cache</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Week-8"><span class="toc-number">1.8.</span> <span class="toc-text">Week 8</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Trapping-Rain-Water"><span class="toc-number">1.8.1.</span> <span class="toc-text">Trapping Rain Water</span></a></li></ol></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="Related">
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="aesophor"
      data-src="/images/avatar.png">
  <p class="name" itemprop="name">aesophor</p>
  <div class="description" itemprop="description">eku</div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">2</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">2</span>
        <span class="name">categories</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">3</span>
        <span class="name">tags</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Flc29waG9y" title="https:&#x2F;&#x2F;github.com&#x2F;aesophor"><i class="ic i-github"></i></span>
      <span class="exturl item instagram" data-url="aHR0cHM6Ly93d3cuaW5zdGFncmFtLmNvbS9hZXNvcGhvci8=" title="https:&#x2F;&#x2F;www.instagram.com&#x2F;aesophor&#x2F;"><i class="ic i-instagram"></i></span>
      <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9hZXNvcGhvcg==" title="https:&#x2F;&#x2F;twitter.com&#x2F;aesophor"><i class="ic i-twitter"></i></span>
      <span class="exturl item linkedin" data-url="aHR0cHM6Ly93d3cubGlua2VkaW4uY29tL2luL2Flc29waG9yLw==" title="https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;aesophor&#x2F;"><i class="ic i-address-card"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>Home</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-user"></i>About</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/about/en-us" rel="section"><i class="ic i-address-card"></i>English</a>
  </li>

        
  <li class="item">
    <a href="/about/zh-tw" rel="section"><i class="ic i-address-card"></i>中文</a>
  </li>

  </ul>
        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/leetcode/grind75" rel="section"><i class="ic i-magic"></i>Grind75</a>
  </li>

    
  <li class="item">
    <a href="/leetcode" rel="section"><i class="ic i-magic"></i>LeetCode</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>Random Posts</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/CTF/" title="In CTF">CTF</a>
</div>

    <span><a href="/2022/08/27/pwnable-tw-secret-garden/" title="[pwnable.tw] Secret Garden (350 pts)">[pwnable.tw] Secret Garden (350 pts)</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Linux/" title="In Linux">Linux</a>
</div>

    <span><a href="/2020/07/20/Arch-Linux-on-MacBook-Pro-11-2-with-Custom-NVMe-M-2-SSD/" title="Arch Linux on MacBook Pro 11,2 with Custom NVMe M.2 SSD">Arch Linux on MacBook Pro 11,2 with Custom NVMe M.2 SSD</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>Recent Comments</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2020 – 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">aesophor @ aesophor</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: 'leetcode/grind75',
    favicon: {
      show: "（●´3｀●）Goooood",
      hide: "(´Д｀)Booooom"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,fancybox: true,
    copyright: 'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
