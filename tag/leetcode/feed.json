{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"leetcode\" tag",
    "description": "{software,reverse} engineer",
    "home_page_url": "https://aesophor.github.io",
    "items": [
        {
            "id": "https://aesophor.github.io/2022/08/21/LC-0001-Two-Sums/",
            "url": "https://aesophor.github.io/2022/08/21/LC-0001-Two-Sums/",
            "title": "LC#0001 - Two Sums",
            "date_published": "2022-08-21T06:05:49.000Z",
            "content_html": "<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>以前刷題總是不寫 writeup，漫無目標的亂刷，導致久了就會忘記解法。最近受到兩位 SQLab 學長的激勵，分別是 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9iY2xpbi50dy9hYm91dC8=\">Kevin Lin (bclin717)</span> 與 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL1RvbW15V3UtZmRna2hka2do\">Tommy Wu (fdgkhdkgh)</span>，決定這輪刷題要養成好習慣：將解題過程記錄下來。</p>\n<h1 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a>Problem</h1><p>給定一串數字 <code>nums</code>，以及一個目標 <code>target</code>。</p>\n<p>請從 <code>nums</code> 中找到兩個數字 s.t. 兩數之和為 <code>target</code>，並回傳那兩數的 index。</p>\n<h1 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h1><p><img data-src=\"fig.png\"></p>\n<h1 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution\"></a>Solution</h1><ol>\n<li>建一個 map：<ul>\n<li>key 為目前數字的 complement，即 target - 目前數字</li>\n<li>value 為目前數字的 index</li>\n</ul>\n</li>\n<li>線性掃描 <code>nums</code>，假設目前掃描到的數字 index 為 <code>i</code>，檢查 map 中是否存在 key = <code>nums[i]</code><ul>\n<li>若存在，返回兩個 index：<code>i</code> 與 <code>map[nums[i]]</code></li>\n<li>不存在，對 map 插入 {<code>target - nums[i]</code>, <code>i</code>}</li>\n</ul>\n</li>\n</ol>\n<pre><code class=\"cpp\">class Solution &#123;\n public:\n  vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;\n    std::map&lt;int, int&gt; complementIdx;\n\n    for (int i = 0; i &lt; nums.size(); i++) &#123;\n        if (complementIdx.count(nums[i])) &#123;\n            return &#123;i, complementIdx[nums[i]]&#125;;\n        &#125;\n        complementIdx.insert(&#123;target - nums[i], i&#125;);\n    &#125;\n\n    return &#123;-1, -1&#125;;\n  &#125;\n&#125;;\n</code></pre>\n<h1 id=\"Complexity-Analysis\"><a href=\"#Complexity-Analysis\" class=\"headerlink\" title=\"Complexity Analysis\"></a>Complexity Analysis</h1><ul>\n<li>Time: O(n) - worst case 需要掃到尾才能找到答案</li>\n<li>Space: O(n) - worst case 同上, map 需要存將近 n 個 entries</li>\n</ul>\n<h1 id=\"Result\"><a href=\"#Result\" class=\"headerlink\" title=\"Result\"></a>Result</h1><pre><code>Runtime: 7 ms, faster than 98.41% of C++ online submissions for Two Sum.\nMemory Usage: 11.2 MB, less than 18.59% of C++ online submissions for Two Sum.\n</code></pre>\n",
            "tags": [
                "leetcode"
            ]
        }
    ]
}